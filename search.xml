<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux中使用fork创建子进程详解及示例程序</title>
      <link href="/posts/1603677970/"/>
      <url>/posts/1603677970/</url>
      
        <content type="html"><![CDATA[<h1 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h1><h2 id="1-1-什么是进程"><a href="#1-1-什么是进程" class="headerlink" title="1.1. 什么是进程"></a>1.1. 什么是进程</h2><p>当可执行文件开始运行之后，就变为了系统中的一个<strong>进程</strong>，一个程序（可执行文件）运行起来之后可以创建多个进程执行，称之为多进程程序。</p><p>每个进程包含有<strong>进程运行环境、内存地址空间、进程ID</strong>、和至少一个被称为线程的执行控制流等资源。</p><p>系统中所有的这些进程实体共享计算机系统的 CPU、外设、内存等资源。</p><h2 id="1-2-进程的状态"><a href="#1-2-进程的状态" class="headerlink" title="1.2. 进程的状态"></a>1.2. 进程的状态</h2><p>系统中的一个CPU在某一个时刻只能执行一个进程，系统中存在的这些多个进程按照一定的规则轮流交替执行，所以每个进程会产生不同的状态：</p><ul><li><code>R</code>：运行态或者就绪态，一旦等待CPU，立马执行；</li><li><code>S</code>：可中断的睡眠状态（因为等待某种事件的发生而被挂起）；</li><li><code>D</code>：不可中断的睡眠状态（此时不能响应异步信号）；</li><li><code>T</code>：暂停状态；</li><li><code>W</code>：退出状态，进程即将被销毁；</li><li><code>Z</code>：退出状态，进程成为僵尸进程；</li></ul><p><img src="https://img-blog.csdnimg.cn/20200313185646266.png" alt=""></p><h1 id="2-编写多进程程序——创建子进程"><a href="#2-编写多进程程序——创建子进程" class="headerlink" title="2. 编写多进程程序——创建子进程"></a>2. 编写多进程程序——创建子进程</h1><h2 id="2-1-头文件"><a href="#2-1-头文件" class="headerlink" title="2.1. 头文件"></a>2.1. 头文件</h2><p>在使用多进程编程的API时，必须首先包含以下头文件：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span>        </span><span class="token comment" spellcheck="true">//定义了fork函数</span></code></pre><h2 id="2-2-创建进程"><a href="#2-2-创建进程" class="headerlink" title="2.2. 创建进程"></a>2.2. 创建进程</h2><p>函数原型如下：</p><pre class=" language-c"><code class="language-c">pid_t <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>fork函数用来创建子进程，它是<font color="red"><strong>通过复制父进程得到的子进程</strong></font>，所以：</p><ul><li>子进程将继承父进程的整个地址空间；</li><li>子进程只有pid号和父进程不一样；</li></ul><p>fork函数会复制出子进程，接着子进程和父进程都处于就绪状态，开始由内核调度执行，所以，被调用的fork函数会<font color="red"><strong>返回两次</strong></font>：</p><ul><li>父进程返回一次，返回的 pid_t 类型的值为新创建的子进程的pid；</li><li>子进程返回一次，返回的 pid_t 类型的值为0；</li></ul><p>如果创建失败，父进程会返回-1。</p><p>另外，pid_t类型其实就是short类型。</p><h2 id="2-3-获取PID的函数"><a href="#2-3-获取PID的函数" class="headerlink" title="2.3. 获取PID的函数"></a>2.3. 获取PID的函数</h2><p>在头文件<code>&lt;unistd.h&gt;</code>中定义，原型如下：</p><ul><li><p>获取自己的pid</p><pre class=" language-c"><code class="language-c">pid_t <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>在子进程中获取父进程的pid</p><pre class=" language-c"><code class="language-c">pid_t <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="2-4-创建子进程的示例代码"><a href="#2-4-创建子进程的示例代码" class="headerlink" title="2.4. 创建子进程的示例代码"></a>2.4. 创建子进程的示例代码</h2></li></ul><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief  使用fork创建子进程示例程序 * @author Mculover666 * @note   创建一个子进程，打印父进程和子进程的pid，并测试n的值*/</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    pid_t pid<span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//测试父进程和子进程是否共享一个n</span>    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 创建子进程失败 */</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fork fail.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 子进程执行的程序 */</span>        n <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am child, my pid = %d, my father pid = %d, n = %d.\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 父进程要执行的程序 */</span>        n <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am father, my pid = %d, my child pid = %d, n = %d.\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pid<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>编译：</p><pre class=" language-bash"><code class="language-bash">gcc 02-fork_test.c -o 02-fork_test.o</code></pre><p>执行：</p><p><img src="https://img-blog.csdnimg.cn/20200313193621861.png" alt=""></p><p>由执行结果可以看到，n变量被子进程fork过去之后，在子进程中就有了一个新的变量n，所以父进程执行后n = 2，子进程执行后n = 1，不是同一个n。</p><h2 id="2-5-移植到嵌入式Linux开发板上运行测试"><a href="#2-5-移植到嵌入式Linux开发板上运行测试" class="headerlink" title="2.5. 移植到嵌入式Linux开发板上运行测试"></a>2.5. 移植到嵌入式Linux开发板上运行测试</h2><p>① 使用交叉编译工具重新编译程序：</p><pre class=" language-bash"><code class="language-bash">arm-none-linux-gnueabi-gcc 02-fork_test.c -o 02-fork_test_arm.o</code></pre><p><img src="https://img-blog.csdnimg.cn/20200313194131978.png" alt=""></p><p>② 基于NFS文件系统，将可执行文件传到开发板上</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cp</span> 02-fork_test_arm.o /nfs_root/</code></pre><p>③ 开发板上执行该程序测试，结果如下：<br><img src="https://img-blog.csdnimg.cn/20200313194957396.png" alt=""></p><p><font color="red"><strong>接收更多精彩文章及资源推送，欢迎订阅我的微信公众号：『mculover666』。</strong></font><br><img src="https://img-blog.csdnimg.cn/20200202092055136.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux应用开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中的文件读写详解及示例程序</title>
      <link href="/posts/917538546/"/>
      <url>/posts/917538546/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Linux中“一切皆文件”"><a href="#1-Linux中“一切皆文件”" class="headerlink" title="1. Linux中“一切皆文件”"></a>1. Linux中“一切皆文件”</h1><p>在Linux系统中，一切皆文件，文件类型根据其表示的意义，分为：</p><ul><li>普通文件</li><li>设备文件：代表一个具体的硬件设备</li><li>管道文件、FIFO文件：具有特殊意义的文件，用于进程间通信；</li><li>套接字文件：用于网络通信；</li></ul><p>所有这些文件都可以用一套API来操作，最基本的四个API是：</p><ul><li>打开：open</li><li>读文件：read</li><li>写文件：write</li><li>关闭：close</li></ul><p>在使用这些API操作文件的时候，需要传入文件标识符 fd（file descriptor），文件标识符的本质就是在进程中代码某一个具体文件的整数，在使用 open 函数打开一个文件时被唯一分配，一般情况下，fd的值如果从0开始分配，如果 fd 为负数，则表示文件打开失败或者操作失败。</p><p>需要注意，fd的值在使用open打开文件时被唯一分配，在使用close关闭文件时会被回收。举个例子，比如第一次打开文件时分配的值fd = 0，如果该文件被关闭，下次新打开一个文件时，fd依然为0，但如果之前打开的文件没有被close掉，则下次新打开一个文件时，fd递增为1，一直递增到系统设定的同时打开文件的最大值为止，这个最大值可以使用<code>ulimit -n</code>查看，一般为1024。</p><p>另外，文件描述符的值0、1、2被系统占用，在桌面Linux系统上表示：</p><ul><li>fd = 0：表示标准输入(stdin)，对应系统的键盘</li><li>fd = 1：表示标准输出(stdout)，对应系统的显示器</li><li>fd = 2：表示标准错误输出(stderr)，对应系统的显示器</li></ul><p>而在嵌入式Linux系统中，一般不存在显示器和键盘，都是用串口交互，所以这三个值对应的设备如下：</p><ul><li>fd = 0：表示标准输入(stdin)，对应系统的控制台串口</li><li>fd = 1：表示标准输出(stdout)，对应系统的控制台串口</li><li>fd = 2：表示标准错误输出(stderr)，对应系统的控制台串口</li></ul><h1 id="2-Linux-C库提供的文件操作API"><a href="#2-Linux-C库提供的文件操作API" class="headerlink" title="2. Linux C库提供的文件操作API"></a>2. Linux C库提供的文件操作API</h1><h2 id="2-1-头文件"><a href="#2-1-头文件" class="headerlink" title="2.1. 头文件"></a>2.1. 头文件</h2><p>在使用文件操作API时，必须首先包含以下头文件：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span>        </span><span class="token comment" spellcheck="true">//定义了一些常用数据类型，比如size_t</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span>            </span><span class="token comment" spellcheck="true">//定义了open、creat等函数，以及表示文件权限的宏定义</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span>            </span><span class="token comment" spellcheck="true">//定义了read、write、close、lseek等函数</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span>            </span><span class="token comment" spellcheck="true">//与全局变量errno相关的定义</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/ioctl.h></span>        </span><span class="token comment" spellcheck="true">//定义了ioctl函数 </span></code></pre><h2 id="2-2-open-—-打开文件"><a href="#2-2-open-—-打开文件" class="headerlink" title="2.2. open — 打开文件"></a>2.2. open — 打开文件</h2><p>操作文件之前必须要打开文件，获取文件描述符fd，该函数原型如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span>mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>① 参数含义如下：</p><ul><li>pathname：文件路径+文件名称</li><li>flags：文件打开方式</li><li>mode：打开文件的权限</li><li>返回值int：打开成功则返回文件描述符，打开失败则返回-1，同时设置全局变量errno的值来表示错误原因；</li></ul><p>② flags标志的值可以使用在<code>&lt;fcntl.h&gt;</code>的宏定义：</p><ul><li><code>O_RDONLY</code>：只读</li><li><code>O_WRONLY</code>：只写</li><li><code>O_RDWR</code>：可读可写（常用）</li><li><code>O_CREAT</code>：如果要打开的文件不存在，则创建新文件</li><li><code>O_EXCL</code>：如果使用O_CREAT时文件已经存在，则返回错误消息</li><li><code>O_TRUNC</code>：如果文件已经存在，且成功打开，则删除文件中原来的全部数据</li><li><code>O_APPEND</code>：以追加写入方式打开文件，打开之后文件指针指向文件末尾</li></ul><p>这些打开方式可以使用<code>|</code>操作符，一起使用，比如：</p><pre class=" language-c"><code class="language-c">O_RDWR <span class="token operator">|</span> O_CREAT</code></pre><p>③ mode的值表示创建新文件时设置的权限，用8进制数来表示，也可以使用&lt;fcntl.h&gt;中定义的宏定义来表示，但是八进制数比较方便。</p><p>3bit的八进制数分别对应linux中文件的三个权限：</p><pre><code>rwxrwxrwx</code></pre><p>第一个rwx是文件拥有者的权限，第二个rwx是文件拥有者所在用户组的权限，第三个rwx是其它用户组的权限；</p><p>每一个rwx都对应一个<strong>8进制数</strong>，比如0x7就表示rwx三项权限全有，0x0就表示rwx三个权限全没有，比如：</p><ul><li><code>0700</code>：所属用户有rwx权限，当前用户组和其他用户组的用户没有任何权限；</li><li><code>0664</code>（常用）：所属用户有rw-权限（-表示没有此项对应权限），当前用户组的其它用户拥有rw-权限，其它用户组的用户只有r–权限。</li></ul><h2 id="2-3-read-—-读取文件"><a href="#2-3-read-—-读取文件" class="headerlink" title="2.3. read — 读取文件"></a>2.3. read — 读取文件</h2><p>函数原型如下：</p><pre class=" language-c"><code class="language-c">ssize_t <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>函数参数含义如下：</p><ul><li>fd：文件描述符</li><li>buf：用来接收所读数据的缓冲区</li><li>count：请求读取的字节数</li><li>返回值：读取成功则返回读取的字节数，读取到文件尾则返回0，读取失败则返回-1，同时设置全局变量errno的值来表示错误原因；</li></ul><h2 id="2-4-write-—-写入文件"><a href="#2-4-write-—-写入文件" class="headerlink" title="2.4. write — 写入文件"></a>2.4. write — 写入文件</h2><p>函数原型如下：</p><pre class=" language-c"><code class="language-c">ssize_t <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>函数参数含义如下：</p><ul><li>fd：文件描述符</li><li>buf：存放待写入数据的缓冲区</li><li>count：请求写入的字节数</li><li>返回值：写入成功则返回实际写入的字节数，写入失败则返回-1，同时设置全局变量errno的值来表示错误原因；</li></ul><h2 id="2-5-close-—-关闭文件"><a href="#2-5-close-—-关闭文件" class="headerlink" title="2.5. close — 关闭文件"></a>2.5. close — 关闭文件</h2><p>API原型如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>函数参数fd表示要关闭文件的文件描述符。</p><p>如果关闭成功，返回0，否则返回-1，同时设置全局变量 errno 报告具体错误的原因。</p><h1 id="3-文件操作示例程序"><a href="#3-文件操作示例程序" class="headerlink" title="3. 文件操作示例程序"></a>3. 文件操作示例程序</h1><p>范例实现功能：</p><p>打开当前目录下的text.txt文件，如果不存在则创建，首先写入一个字符串，然后关闭文件，再重新打开读取该文件中的内容并打印。</p><p>范例代码：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief  文件读写API使用示例程序 * @author Mculover666 * @note   首先写入文件，接着读取文件*/</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span>        </span><span class="token comment" spellcheck="true">//定义了一些常用数据类型，比如size_t</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span>            </span><span class="token comment" spellcheck="true">//定义了open、creat等函数，以及表示文件权限的宏定义</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span>            </span><span class="token comment" spellcheck="true">//定义了read、write、close、lseek等函数</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span>            </span><span class="token comment" spellcheck="true">//与全局变量errno相关的定义</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/ioctl.h></span>        </span><span class="token comment" spellcheck="true">//定义了ioctl函数 </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> filename<span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token operator">=</span> <span class="token string">"test.txt"</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> write_dat<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> read_buf<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 写入文件操作示例 */</span>    <span class="token comment" spellcheck="true">//1. 打开文件</span>    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> O_RDWR <span class="token operator">|</span> O_CREAT<span class="token punctuation">,</span> <span class="token number">0664</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s file open fail,errno = %d.\r\n"</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> errno<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//2. 读取内容</span>    res <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> write_dat<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>write_dat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>res <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"write dat fail,errno = %d.\r\n"</span><span class="token punctuation">,</span> errno<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"write %d bytes:%s\r\n"</span><span class="token punctuation">,</span> res<span class="token punctuation">,</span> write_dat<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//3. 关闭文件</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 读取文件数据示例 */</span>    <span class="token comment" spellcheck="true">//1. 打开文件</span>    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s file open fail,errno = %d.\r\n"</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> errno<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//2. 写入内容</span>    res <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> read_buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>read_buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>res <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read dat fail,errno = %d.\r\n"</span><span class="token punctuation">,</span> errno<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read %d bytes:%s\r\n"</span><span class="token punctuation">,</span> res<span class="token punctuation">,</span> read_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//3. 关闭文件</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>编译：</p><pre class=" language-bash"><code class="language-bash">gcc 01-file_test.c -o 01-file_test.o</code></pre><p>运行：</p><p><img src="https://img-blog.csdnimg.cn/20200312193151469.png" alt=""></p><h1 id="4-移植到嵌入式Linux开发板上运行测试"><a href="#4-移植到嵌入式Linux开发板上运行测试" class="headerlink" title="4. 移植到嵌入式Linux开发板上运行测试"></a>4. 移植到嵌入式Linux开发板上运行测试</h1><h2 id="4-1-优化程序-——-fsync"><a href="#4-1-优化程序-——-fsync" class="headerlink" title="4.1. 优化程序 —— fsync"></a>4.1. 优化程序 —— fsync</h2><p>嵌入式Linux系统通常采用 Flash 存储器， write()有个问题 —— 将数据提交到系统内部缓存之后就返回，所以当它返回之后，嵌入式系统如果突然掉电，则文件数据也会写入失败。</p><p>所以，在嵌入式系统中使用这些API时，<strong>应该在write函数之后，用 fsync()函数把修改过的文件数据立马写入闪存中，避免数据丢失</strong>。</p><p>fsync()函数的功能原型在&lt;unistd.h&gt;中，原型如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fsync</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>fsync()调用后，会直到文件已修改过的数据全部写入磁盘后才返回，成功返回 0，失败返回-1， 同时设置全局变量 errno 报告具体错误的原因。</p><p>在示例程序的write操作之后添加代码：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//写入之后立马同步数据</span>res <span class="token operator">=</span> <span class="token function">fsync</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>res <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fsync fail,errno = %d.\r\n"</span><span class="token punctuation">,</span> errno<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="4-2-移植到开发板上运行处"><a href="#4-2-移植到开发板上运行处" class="headerlink" title="4.2. 移植到开发板上运行处"></a>4.2. 移植到开发板上运行处</h2><p>① 使用交叉编译工具重新编译程序：</p><pre class=" language-bash"><code class="language-bash">arm-none-linux-gnueabi-gcc 01-file_test.c -o 01-file_test_arm.o</code></pre><p><img src="https://img-blog.csdnimg.cn/20200312195247139.png" alt=""></p><p>② 基于NFS文件系统，将可执行文件传到开发板上</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cp</span> 01-file_test_arm.o /nfs_root/</code></pre><p>③ 开发板上执行该程序测试：</p><pre class=" language-bash"><code class="language-bash">./01-file_test_arm.o</code></pre><p>开发板上执行结果如下：</p><p><img src="https://img-blog.csdnimg.cn/20200312195622433.png" alt=""></p><p><font color="red"><strong>接收更多精彩文章及资源推送，欢迎订阅我的微信公众号：『mculover666』。</strong></font></p><p><img src="https://img-blog.csdnimg.cn/20200202092055136.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux应用开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Multisim13安装教程</title>
      <link href="/posts/433364979/"/>
      <url>/posts/433364979/</url>
      
        <content type="html"><![CDATA[<h1 id="安装-Multisim-13"><a href="#安装-Multisim-13" class="headerlink" title="安装 Multisim 13"></a>安装 Multisim 13</h1><ol><li>运行安装目录setup.exe</li></ol><p><img src="http://mculover666.cn/blog/20200310/AE1PiNxgKBOp.png?imageslim" alt=""></p><ol start="2"><li>选择Install this product for evaluation</li></ol><p><img src="http://mculover666.cn/blog/20200310/35Av4qhBJojG.png?imageslim" alt=""></p><ol start="3"><li>选择安装目录</li></ol><blockquote><p>路径不要有中文或者空格！</p></blockquote><p><img src="http://mculover666.cn/blog/20200310/ybM9hsqIPuIk.png?imageslim" alt=""></p><ol start="4"><li>选择安装产品（ 默认即可）</li></ol><p><img src="http://mculover666.cn/blog/20200310/6Cs3YXBrEnEB.png?imageslim" alt=""></p><ol start="5"><li>去掉发送用户信息</li></ol><p><img src="http://mculover666.cn/blog/20200310/Jajie6MP0XpV.png?imageslim" alt=""></p><ol start="6"><li>接受许可协议</li></ol><p><img src="http://mculover666.cn/blog/20200310/23RKNF8EaGvq.png?imageslim" alt=""></p><ol start="7"><li><p><img src="http://mculover666.cn/blog/20200310/fwaaoLQ08LiI.png?imageslim" alt=""></p></li><li><p>等待安装完成</p></li></ol><p><img src="http://mculover666.cn/blog/20200310/6c16etMCfMa2.png?imageslim" alt=""></p><ol start="9"><li>安装完成</li></ol><p><img src="http://mculover666.cn/blog/20200310/2ldnOu2kky7l.png?imageslim" alt=""></p><ol start="10"><li>重启电脑</li></ol><blockquote><p>注意：选择Restart之后会立马重启！</p></blockquote><p><img src="http://mculover666.cn/blog/20200310/NK9ivJTLJKd8.png?imageslim" alt=""></p><h1 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h1><p>运行安装包下NI License Activator 1.1文件夹内NI License Activator 1.1.exe程序，右键点击方框后面的字母，选择Active，五个框由灰变绿就可以，如图：</p><p><img src="http://mculover666.cn/blog/20200310/GO5LPV2yEJE1.png?imageslim" alt=""></p><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p><img src="http://mculover666.cn/blog/20200310/mLK3cN1GyiOT.png?imageslim" alt=""></p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> 安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桌面mini网络时钟教程</title>
      <link href="/posts/2151341594/"/>
      <url>/posts/2151341594/</url>
      
        <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=90635321&cid=154783725&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h1 id="1-RT-Thread-Studio"><a href="#1-RT-Thread-Studio" class="headerlink" title="1. RT-Thread Studio"></a>1. RT-Thread Studio</h1><p>RT-Thread Studio 是<strong>一站式的 RT-Thread 开发工具</strong>，通过简单易用的图形化配置系统以及丰富的软件包和组件资源，让物联网开发变得简单和高效。<br><img src="https://img-blog.csdnimg.cn/20200202170325301.png#pic_center" alt=""><br>RT-Thread主要包括工程创建和管理，代码编辑，SDK管理，RT-Thread配置，构建配置，调试配置，程序下载和调试等功能，结合图形化配置系统以及软件包和组件资源，减少重复工作，提高开发效率。</p><p><img src="https://img-blog.csdnimg.cn/20200202170406175.png" alt=""></p><p>RT-Thread STudio了可以从<a href="https://www.rt-thread.org/page/download.html#studio" target="_blank" rel="noopener">RT-Thread官网</a>下载，下载之后一路next安装即可，注意安装路径不要有中文或者空格。<br><img src="https://img-blog.csdnimg.cn/20200203110427759.png" alt=""></p><h1 id="2-桌面mini时钟项目"><a href="#2-桌面mini时钟项目" class="headerlink" title="2. 桌面mini时钟项目"></a>2. 桌面mini时钟项目</h1><p>迷你桌面时钟项目基于小熊派IoT开发板，使用RT-Thread物联网操作系统，使用RT-Thread Studio一站式开发工具，在极短的时间内开发完成一个桌面mini时钟。</p><p>整个项目的架构如下：<br><img src="https://img-blog.csdnimg.cn/2020020217203582.png" alt="在这里插入图片描述"><br>项目所用的芯片型号如下：</p><ul><li>主控芯片：STM32L431RCT6</li><li>温湿度传感器：    SHT30</li><li>通信模组：ESP8266（WIFI）</li><li>显示模组：0.96’OLED（SSD1306）</li></ul><p>其中，SHT30传感器挂载到STM32的I2C1引脚上，OLED挂载到STM32的I2C3引脚上，两个设备均使用模拟I2C总线通信，ESP8266与STM32之间采用串口发送AT指令通信。</p><p>项目开源地址：<a href="https://github.com/Mculover666/Mini-Clock-RT-thread" target="_blank" rel="noopener">https://github.com/Mculover666/Mini-Clock-RT-thread</a>。</p><h1 id="3-项目开发教程"><a href="#3-项目开发教程" class="headerlink" title="3. 项目开发教程"></a>3. 项目开发教程</h1><blockquote><ul><li><a href="https://blog.csdn.net/Mculover666/article/details/104146623" target="_blank" rel="noopener">使用RT-Thread Studio DIY 迷你桌面时钟（一）| 基于STM32芯片创建工程</a></li><li><a href="https://mculover666.blog.csdn.net/article/details/104153715" target="_blank" rel="noopener">使用RT-Thread Studio DIY 迷你桌面时钟（二）| 获取温湿度传感器数据（I2C设备驱动+SHT3x软件包）</a></li><li><a href="https://mculover666.blog.csdn.net/article/details/104418075" target="_blank" rel="noopener">使用RT-Thread Studio DIY 迷你桌面时钟（三）| 获取NTP时间（at_device软件包 + netutils软件包）</a></li><li><a href="https://mculover666.blog.csdn.net/article/details/104422501" target="_blank" rel="noopener">使用RT-Thread Studio DIY 迷你桌面时钟（四）| OLED显示时钟和温湿度（cpp组件 + u8g2软件包）</a></li><li><a href="https://mculover666.blog.csdn.net/article/details/104427445" target="_blank" rel="noopener">使用RT-Thread Studio DIY 迷你桌面时钟（五）| 使用内置 Git 插件管理项目</a></li></ul></blockquote><h1 id="4-基于RT-Thread-Studio的项目开发总结"><a href="#4-基于RT-Thread-Studio的项目开发总结" class="headerlink" title="4. 基于RT-Thread Studio的项目开发总结"></a>4. 基于RT-Thread Studio的项目开发总结</h1><p>这次使用 RT-Thread Studio开发这个小项目的过程，用两个字来概括就是：舒服！</p><ul><li><strong>舒服点① - 高度集成化的开发体验</strong></li></ul><p>RT-Thread Studio支持STM32全系列芯片，只需要建立工程时选择型号即可，创建之后直接编译、下载一条龙服务，RT-Thread就跑起来了，才不管用的什么板子呢~</p><p>它使用的<strong>编译器</strong>是arm-none-eabi-gcc系列编译器，和MDK所使用的ARMCC编译器相比，效率上不敢比，水平太菜，但是从编译时间上，快很多。</p><p>它使用的<strong>下载器</strong>是基于STM32CubeProg的，支持J-Link和ST-Link，下载速度就一个字：快！</p><p>它还内置了<strong>串口终端putty</strong>，不用再去新开串口终端软件，直接在一个窗口中就可以搞定，多爽：<br><img src="https://img-blog.csdnimg.cn/20200221152942463.png" alt=""></p><ul><li><strong>舒服点② - 编码体验</strong></li></ul><p>在编码过程中，首先是主题，可以切换为各种常用IDE的暗黑系风格，比如下面这种：<br><img src="https://img-blog.csdnimg.cn/20200221151647111.png" alt=""><br>其次就是自动提示功能，输入一个字母之后就会有提示，而且带有参数说明功能，在快速编码的时候也是很方便；</p><p>最后还有一个非常重要的功能——跳转到定义，在MDK中编译时不开这个功能（都懂得），导致跳转查看源码时非常不方便，而在RT-Thread Studio中，鼠标悬停就可以快速查看定义：<br><img src="https://img-blog.csdnimg.cn/20200221151958749.png" alt=""><br>如果想跳转过去，直接右键查看声明即可。</p><p><strong>- 舒服点③ 软件包中心的支持</strong></p><p>如果在功能开发的时候，有非常丰富的软件包可用，使得自己的编码量大幅降低，比如本项目中使用的SHT3x软件包、AT_Device软件包、U8G2软件包，项目开发过程中很顺手，经过很多项目验证的开源代码，为什么不用呢？</p><p><img src="https://img-blog.csdnimg.cn/20200221152329899.png" alt=""></p><ul><li><strong>舒服点④ - 图形化配置</strong></li></ul><p>讲真，这个界面好看不？点一下就能开启/关闭组件，非常方便：<br><img src="https://img-blog.csdnimg.cn/20200221152422241.png" alt=""><br>具体的配置项也是图形化的，一目了然：<br><img src="https://img-blog.csdnimg.cn/2020022115251326.png" alt=""></p><ul><li><strong>舒服点⑤ - 内置Git插件</strong></li></ul><p>对于项目开发来说，最必须的就是使用Git来管理本地库和远程库，可以进行项目版本管理，可以进行团队协作，但是比较头疼的是git需要使用命令行来操作，而RT-Thread Studio中内置了git插件，一切操作都可以可视化进行，点点鼠标即可，实为方便：</p><p><img src="https://img-blog.csdnimg.cn/20200221152819780.png" alt=""><br>项目中常用的这些功能都有了，非常齐全，但是还有一个需要特别说明的地方。</p><p>使用RT-Thread Studio开发项目，我觉得需要建立在对RT-Thread这个操作系统有一定的了解基础之上，会使用MDK+ENV的方式进行开发，了解内核、组件、软件包的基本使用，有了这些基础，使用该软件开发项目时才会觉得<strong>得心应手</strong>，否则，高度集成化会导致你觉得这一切来得太容易了，项目做的云里雾里，出问题了也没法定位，这样的行为是非常不可取的。</p><p>好啦！对于本次项目开发体验就总结到这里，其实按照整套教程做出来，花费不到半个小时的时间，听我在这儿吹爆，还不如下载动手试试！</p><p><font color="red"><strong>接收更多精彩文章及资源推送，欢迎订阅我的微信公众号：『mculover666』。</strong></font><br><img src="https://img-blog.csdnimg.cn/20200202092055136.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 制作过程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 制作过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桌面mini网络时钟教程 | 05-使用内置 Git 可视化插件管理项目</title>
      <link href="/posts/210720430/"/>
      <url>/posts/210720430/</url>
      
        <content type="html"><![CDATA[<h1 id="1-项目进度"><a href="#1-项目进度" class="headerlink" title="1. 项目进度"></a>1. 项目进度</h1><p>桌面Mini时钟项目用来演示如何使用RT-Thread Stduio开发项目，整个项目的架构如下：<br><img src="https://img-blog.csdnimg.cn/2020020311120887.png#pic_center" alt=""> </p><p>在前四篇博文中简单的介绍了RT-Thread Studio一站式工具，基于STM32L431RCT6这个芯片创建工程，并修改时钟为使用外部时钟，以及添加SHT3x软件包获取温湿度传感器数据，添加了ESP8266设备连接网络，使用NTP服务器进行网络对时，最后添加u8g2软件包，驱动OLED显示数字时钟效果和温湿度效果。</p><blockquote><ul><li><a href="https://blog.csdn.net/Mculover666/article/details/104146623" target="_blank" rel="noopener">使用RT-Thread Studio DIY 迷你桌面时钟（一）| 基于STM32芯片创建工程</a></li><li><a href="https://mculover666.blog.csdn.net/article/details/104153715" target="_blank" rel="noopener">使用RT-Thread Studio DIY 迷你桌面时钟（二）| 获取温湿度传感器数据（I2C设备驱动+SHT3x软件包）</a></li><li><a href="https://mculover666.blog.csdn.net/article/details/104418075" target="_blank" rel="noopener">使用RT-Thread Studio DIY 迷你桌面时钟（三）| 获取NTP时间（at_device软件包 + netutils软件包）</a></li><li><a href="https://mculover666.blog.csdn.net/article/details/104422501" target="_blank" rel="noopener">使用RT-Thread Studio DIY 迷你桌面时钟（四）| OLED显示时钟和温湿度（cpp组件 + u8g2软件包）</a></li></ul></blockquote><p>本文中默认你已经了解Git的基本使用以及命令行操作，接下来讲述如何使用RT-Thread Studio内置的Git插件来管理整个项目。</p><h1 id="2-Git插件配置"><a href="#2-Git插件配置" class="headerlink" title="2. Git插件配置"></a>2. Git插件配置</h1><p>进入窗口-&gt;首选项，选择小组-&gt;Git-&gt;配置，可以看到当前Git工具的配置：<br><img src="https://img-blog.csdnimg.cn/20200221143355548.png" alt="在这里插入图片描述"></p><p>如果没有，说明Git安装或者配置不成功，可以参考我的教程：</p><ul><li><a href="https://mculover666.blog.csdn.net/article/details/90034512" target="_blank" rel="noopener">【Git &amp; Github】（二）Git简介及其安装（Git是什么、Git的诞生、Git的优势、Git的安装、初次运行Git前的配置）</a>。</li></ul><h1 id="3-建立并管理本地仓库"><a href="#3-建立并管理本地仓库" class="headerlink" title="3. 建立并管理本地仓库"></a>3. 建立并管理本地仓库</h1><h2 id="3-1-建立仓库"><a href="#3-1-建立仓库" class="headerlink" title="3.1. 建立仓库"></a>3.1. 建立仓库</h2><p>在项目名称右键单击，按照图中所示点击共享项目：<br><img src="https://img-blog.csdnimg.cn/20200221143735579.png" alt=""></p><p>选中第一个红框中的内容，点击Create Repository：<br><img src="https://img-blog.csdnimg.cn/20200221143824708.png" alt=""><br>创建仓库之后，点击完成：<br><img src="https://img-blog.csdnimg.cn/20200221143911199.png" alt=""><br>再次右键单击项目名称选择小组，可以看到当前所有可以进行的Git操作：<br><img src="https://img-blog.csdnimg.cn/20200221144052288.png" alt=""></p><p>选择<code>Show in Repositories View</code>可进入仓库视图查看：<br><img src="https://img-blog.csdnimg.cn/20200221144251504.png" alt=""><br>选择<code>Show in History</code>可进入历史提交信息视图查看：<br><img src="https://img-blog.csdnimg.cn/20200221144332569.png" alt=""></p><h2 id="3-2-提交当前内容-修改"><a href="#3-2-提交当前内容-修改" class="headerlink" title="3.2. 提交当前内容/修改"></a>3.2. 提交当前内容/修改</h2><p>直接点击提交即可：<br><img src="https://img-blog.csdnimg.cn/20200221144540501.png" alt=""><br>提交成功之后可以在之前的历史视图中查看到历史：<br><img src="https://img-blog.csdnimg.cn/20200221144747839.png" alt=""></p><h1 id="4-配置并推送到远程库"><a href="#4-配置并推送到远程库" class="headerlink" title="4. 配置并推送到远程库"></a>4. 配置并推送到远程库</h1><h2 id="4-1-建立远程仓库"><a href="#4-1-建立远程仓库" class="headerlink" title="4.1. 建立远程仓库"></a>4.1. 建立远程仓库</h2><p>在Github建立一个新的空仓库过程此处不作赘述，如果不熟悉，请参考教程：</p><ul><li><a href="https://mculover666.blog.csdn.net/article/details/90258680" target="_blank" rel="noopener">【Git &amp; Github】（六）Git命令行操作 —— Github远程库操作（创建远程库、给远程库地址取别名、推送远程库、拉取远程库、克隆远程库）</a></li></ul><p>建立好之后的空仓库如图：<br><img src="https://img-blog.csdnimg.cn/2020022114513740.png" alt=""></p><h2 id="4-2-配置远程库"><a href="#4-2-配置远程库" class="headerlink" title="4.2. 配置远程库"></a>4.2. 配置远程库</h2><p>在仓库视图中右击远程对象，选择新建远程对象：<br><img src="https://img-blog.csdnimg.cn/20200221145252298.png" alt=""><br>这里我以建立推送对象为例：<br><img src="https://img-blog.csdnimg.cn/20200221145402127.png" alt=""><br>填写远程库信息：<br><img src="https://img-blog.csdnimg.cn/20200221145551723.png" alt=""><br><img src="https://img-blog.csdnimg.cn/20200221145619376.png" alt=""><br>创建完成之后在仓库视图可以看到信息：<br><img src="https://img-blog.csdnimg.cn/2020022114573123.png" alt=""></p><h2 id="4-3-推送提交信息到远程库"><a href="#4-3-推送提交信息到远程库" class="headerlink" title="4.3. 推送提交信息到远程库"></a>4.3. 推送提交信息到远程库</h2><p>在小组中点击push到master分支：<br><img src="https://img-blog.csdnimg.cn/20200221145825892.png" alt=""><br>按照如下步骤推送：<br><img src="https://img-blog.csdnimg.cn/20200221145916553.png" alt=""><br>推送之后可以在Github仓库上看到：<br><img src="https://img-blog.csdnimg.cn/20200221150006385.png" alt=""></p><p>还有一些另外的拉取远程库操作，分支操作内容不常用，暂不讲述，有兴趣可以自行研究。</p><p><font color="red"><strong>接收更多精彩文章及资源推送，欢迎订阅我的微信公众号：『mculover666』。</strong></font><br><img src="https://img-blog.csdnimg.cn/20200202092055136.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 制作过程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 制作过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桌面mini网络时钟教程 | 04-OLED显示时钟和温湿度</title>
      <link href="/posts/3603126757/"/>
      <url>/posts/3603126757/</url>
      
        <content type="html"><![CDATA[<h1 id="1-项目进度"><a href="#1-项目进度" class="headerlink" title="1. 项目进度"></a>1. 项目进度</h1><p>桌面Mini时钟项目用来演示如何使用RT-Thread Stduio开发项目，整个项目的架构如下：<br><img src="https://img-blog.csdnimg.cn/2020020311120887.png#pic_center" alt=""> </p><p>在前三篇博文中简单的介绍了RT-Thread Studio一站式工具，基于STM32L431RCT6这个芯片创建工程，并修改时钟为使用外部时钟，以及添加SHT3x软件包获取温湿度传感器数据，最后添加了ESP8266设备连接网络，使用NTP服务器进行网络对时。</p><blockquote><ul><li><a href="https://blog.csdn.net/Mculover666/article/details/104146623" target="_blank" rel="noopener">使用RT-Thread Studio DIY 迷你桌面时钟（一）| 基于STM32芯片创建工程</a></li><li><a href="https://mculover666.blog.csdn.net/article/details/104153715" target="_blank" rel="noopener">使用RT-Thread Studio DIY 迷你桌面时钟（二）| 获取温湿度传感器数据（I2C设备驱动+SHT3x软件包）</a></li><li><a href="https://mculover666.blog.csdn.net/article/details/104418075" target="_blank" rel="noopener">使用RT-Thread Studio DIY 迷你桌面时钟（三）| 获取NTP时间（at_device软件包 + netutils软件包）</a></li></ul></blockquote><p>接下来添加u8g2软件包，驱动OLED显示数字时钟效果和温湿度效果。</p><h1 id="2-开启C-组件支持"><a href="#2-开启C-组件支持" class="headerlink" title="2. 开启C++组件支持"></a>2. 开启C++组件支持</h1><p>使用U8G2软件包需要C++组件支持，在RT-Thread项目设置中开启C++组件，如图：<br><img src="https://img-blog.csdnimg.cn/20200221091817570.png" alt=""><br>开启之后保存设置，软件会自动添加C++组件到工程中，编译没有问题：<br><img src="https://img-blog.csdnimg.cn/20200221094621580.png" alt=""></p><h1 id="3-添加u8g2软件包并测试"><a href="#3-添加u8g2软件包并测试" class="headerlink" title="3. 添加u8g2软件包并测试"></a>3. 添加u8g2软件包并测试</h1><p>c++组件测试编译没有问题之后，打开工程设置，搜索u8g2，添加软件包：<br><img src="https://img-blog.csdnimg.cn/20200221094721981.png" alt=""><br>添加之后打开u8g2软件包配置，使能基本示例：<br><img src="https://img-blog.csdnimg.cn/20200221094848273.png" alt=""><br>保存配置，软件会自动构建工程，打开示例文件，文件位置如图：<br><img src="https://img-blog.csdnimg.cn/20200221095017406.png" alt=""><br>在示例文件最开始根据实际情况配置引脚编号：<br><img src="https://img-blog.csdnimg.cn/20200221095216644.png" alt=""><br>配置之后，编译，下载，在串口控制台中运行该线程，如图：<br><img src="https://img-blog.csdnimg.cn/20200221095426701.png" alt=""><br>线程运行起来之后OLED显示正常，测试完毕，如图：</p><h1 id="4-编写OLED显示线程"><a href="#4-编写OLED显示线程" class="headerlink" title="4. 编写OLED显示线程"></a>4. 编写OLED显示线程</h1><p>测试完毕后，在RT-Thread项目设置中关闭该示例文件，保存设置，等待软件自动构建工程完毕后，在application分组下创建一个用户文件<code>oled_display.cpp</code>文件，存放本项目中的OLED显示代码。</p><p>完整的代码如下：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;rthw.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;rtthread.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;rtdevice.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;U8g2lib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;drv_soft_i2c.h></span></span><span class="token keyword">extern</span> <span class="token string">"C"</span><span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sht3x.h></span></span><span class="token punctuation">}</span><span class="token keyword">extern</span> <span class="token string">"C"</span><span class="token punctuation">{</span>sht3x_device_t <span class="token function">sht3x_init</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>i2c_bus_name<span class="token punctuation">,</span> rt_uint8_t sht3x_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>rt_err_t <span class="token function">sht3x_read_singleshot</span><span class="token punctuation">(</span>sht3x_device_t dev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">define</span> OLED_I2C_PIN_SCL                    7   </span><span class="token comment" spellcheck="true">// PA7</span><span class="token macro property">#<span class="token directive keyword">define</span> OLED_I2C_PIN_SDA                    20  </span><span class="token comment" spellcheck="true">// PB4</span><span class="token keyword">static</span> U8G2_SSD1306_128X64_NONAME_F_SW_I2C <span class="token function">u8g2</span><span class="token punctuation">(</span>U8G2_R0<span class="token punctuation">,</span>\                                         <span class="token comment" spellcheck="true">/* clock=*/</span> OLED_I2C_PIN_SCL<span class="token punctuation">,</span>\                                         <span class="token comment" spellcheck="true">/* data=*/</span> OLED_I2C_PIN_SDA<span class="token punctuation">,</span>\                                         <span class="token comment" spellcheck="true">/* reset=*/</span> U8X8_PIN_NONE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> SUN 0</span><span class="token macro property">#<span class="token directive keyword">define</span> SUN_CLOUD  1</span><span class="token macro property">#<span class="token directive keyword">define</span> CLOUD 2</span><span class="token macro property">#<span class="token directive keyword">define</span> RAIN 3</span><span class="token macro property">#<span class="token directive keyword">define</span> THUNDER 4</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">drawWeatherSymbol</span><span class="token punctuation">(</span>u8g2_uint_t x<span class="token punctuation">,</span> u8g2_uint_t y<span class="token punctuation">,</span> uint8_t symbol<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// fonts used:</span>  <span class="token comment" spellcheck="true">// u8g2_font_open_iconic_embedded_6x_t</span>  <span class="token comment" spellcheck="true">// u8g2_font_open_iconic_weather_6x_t</span>  <span class="token comment" spellcheck="true">// encoding values, see: https://github.com/olikraus/u8g2/wiki/fntgrpiconic</span>  <span class="token keyword">switch</span><span class="token punctuation">(</span>symbol<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">case</span> SUN<span class="token punctuation">:</span>      u8g2<span class="token punctuation">.</span><span class="token function">setFont</span><span class="token punctuation">(</span>u8g2_font_open_iconic_weather_6x_t<span class="token punctuation">)</span><span class="token punctuation">;</span>      u8g2<span class="token punctuation">.</span><span class="token function">drawGlyph</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token number">69</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> SUN_CLOUD<span class="token punctuation">:</span>      u8g2<span class="token punctuation">.</span><span class="token function">setFont</span><span class="token punctuation">(</span>u8g2_font_open_iconic_weather_6x_t<span class="token punctuation">)</span><span class="token punctuation">;</span>      u8g2<span class="token punctuation">.</span><span class="token function">drawGlyph</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> CLOUD<span class="token punctuation">:</span>      u8g2<span class="token punctuation">.</span><span class="token function">setFont</span><span class="token punctuation">(</span>u8g2_font_open_iconic_weather_6x_t<span class="token punctuation">)</span><span class="token punctuation">;</span>      u8g2<span class="token punctuation">.</span><span class="token function">drawGlyph</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> RAIN<span class="token punctuation">:</span>      u8g2<span class="token punctuation">.</span><span class="token function">setFont</span><span class="token punctuation">(</span>u8g2_font_open_iconic_weather_6x_t<span class="token punctuation">)</span><span class="token punctuation">;</span>      u8g2<span class="token punctuation">.</span><span class="token function">drawGlyph</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token number">67</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> THUNDER<span class="token punctuation">:</span>      u8g2<span class="token punctuation">.</span><span class="token function">setFont</span><span class="token punctuation">(</span>u8g2_font_open_iconic_embedded_6x_t<span class="token punctuation">)</span><span class="token punctuation">;</span>      u8g2<span class="token punctuation">.</span><span class="token function">drawGlyph</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token number">67</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">drawWeather</span><span class="token punctuation">(</span>uint8_t symbol<span class="token punctuation">,</span> <span class="token keyword">int</span> degree<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">drawWeatherSymbol</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">,</span> symbol<span class="token punctuation">)</span><span class="token punctuation">;</span>  u8g2<span class="token punctuation">.</span><span class="token function">setFont</span><span class="token punctuation">(</span>u8g2_font_logisoso32_tf<span class="token punctuation">)</span><span class="token punctuation">;</span>  u8g2<span class="token punctuation">.</span><span class="token function">setCursor</span><span class="token punctuation">(</span><span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  u8g2<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>degree<span class="token punctuation">)</span><span class="token punctuation">;</span>  u8g2<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">drawHumidity</span><span class="token punctuation">(</span>uint8_t symbol<span class="token punctuation">,</span> <span class="token keyword">int</span> humidity<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">drawWeatherSymbol</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">,</span> symbol<span class="token punctuation">)</span><span class="token punctuation">;</span>  u8g2<span class="token punctuation">.</span><span class="token function">setFont</span><span class="token punctuation">(</span>u8g2_font_logisoso32_tf<span class="token punctuation">)</span><span class="token punctuation">;</span>  u8g2<span class="token punctuation">.</span><span class="token function">setCursor</span><span class="token punctuation">(</span><span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  u8g2<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>humidity<span class="token punctuation">)</span><span class="token punctuation">;</span>  u8g2<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"%"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">oled_display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    u8g2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    u8g2<span class="token punctuation">.</span><span class="token function">clearBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    u8g2<span class="token punctuation">.</span><span class="token function">setFont</span><span class="token punctuation">(</span>u8g2_font_logisoso32_tf<span class="token punctuation">)</span><span class="token punctuation">;</span>    u8g2<span class="token punctuation">.</span><span class="token function">setCursor</span><span class="token punctuation">(</span><span class="token number">48</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    u8g2<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hi~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// requires enableUTF8Print()</span>    u8g2<span class="token punctuation">.</span><span class="token function">setFont</span><span class="token punctuation">(</span>u8g2_font_6x13_tr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// choose a suitable font</span>    u8g2<span class="token punctuation">.</span><span class="token function">drawStr</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token string">"By Mculover666"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// write something to the internal memory</span>    u8g2<span class="token punctuation">.</span><span class="token function">sendBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sht3x_device_t  sht3x_device<span class="token punctuation">;</span>    sht3x_device <span class="token operator">=</span> <span class="token function">sht3x_init</span><span class="token punctuation">(</span><span class="token string">"i2c1"</span><span class="token punctuation">,</span> <span class="token number">0x44</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">rt_thread_mdelay</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> mstr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> hstr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    time_t now<span class="token punctuation">;</span>    <span class="token keyword">struct</span> tm <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> hour <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> temperature <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>humidity <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">switch</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span>                now <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span>RT_NULL<span class="token punctuation">)</span><span class="token punctuation">;</span>                p<span class="token operator">=</span><span class="token function">gmtime</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> time_t<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>                hour <span class="token operator">=</span> p<span class="token operator">-></span>tm_hour<span class="token punctuation">;</span>                min <span class="token operator">=</span> p<span class="token operator">-></span>tm_min<span class="token punctuation">;</span>                <span class="token function">sprintf</span><span class="token punctuation">(</span>mstr<span class="token punctuation">,</span> <span class="token string">"%02d"</span><span class="token punctuation">,</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">sprintf</span><span class="token punctuation">(</span>hstr<span class="token punctuation">,</span> <span class="token string">"%02d"</span><span class="token punctuation">,</span> hour<span class="token punctuation">)</span><span class="token punctuation">;</span>                u8g2<span class="token punctuation">.</span><span class="token function">firstPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">do</span> <span class="token punctuation">{</span>                     u8g2<span class="token punctuation">.</span><span class="token function">setFont</span><span class="token punctuation">(</span>u8g2_font_logisoso42_tn<span class="token punctuation">)</span><span class="token punctuation">;</span>                     u8g2<span class="token punctuation">.</span><span class="token function">drawStr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">63</span><span class="token punctuation">,</span>hstr<span class="token punctuation">)</span><span class="token punctuation">;</span>                     u8g2<span class="token punctuation">.</span><span class="token function">drawStr</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">63</span><span class="token punctuation">,</span><span class="token string">":"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     u8g2<span class="token punctuation">.</span><span class="token function">drawStr</span><span class="token punctuation">(</span><span class="token number">67</span><span class="token punctuation">,</span><span class="token number">63</span><span class="token punctuation">,</span>mstr<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span> u8g2<span class="token punctuation">.</span><span class="token function">nextPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">rt_thread_mdelay</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                status <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>           <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>               <span class="token keyword">if</span><span class="token punctuation">(</span>RT_EOK <span class="token operator">==</span> <span class="token function">sht3x_read_singleshot</span><span class="token punctuation">(</span>sht3x_device<span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token punctuation">{</span>                   temperature <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>sht3x_device<span class="token operator">-></span>temperature<span class="token punctuation">;</span>               <span class="token punctuation">}</span>               <span class="token keyword">else</span>               <span class="token punctuation">{</span>                   temperature <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>               u8g2<span class="token punctuation">.</span><span class="token function">clearBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token function">drawWeather</span><span class="token punctuation">(</span>SUN<span class="token punctuation">,</span> temperature<span class="token punctuation">)</span><span class="token punctuation">;</span>               u8g2<span class="token punctuation">.</span><span class="token function">sendBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token function">rt_thread_mdelay</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               status <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>               <span class="token keyword">break</span><span class="token punctuation">;</span>           <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>               <span class="token keyword">if</span><span class="token punctuation">(</span>RT_EOK <span class="token operator">==</span> <span class="token function">sht3x_read_singleshot</span><span class="token punctuation">(</span>sht3x_device<span class="token punctuation">)</span><span class="token punctuation">)</span>              <span class="token punctuation">{</span>                   humidity <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>sht3x_device<span class="token operator">-></span>humidity<span class="token punctuation">;</span>              <span class="token punctuation">}</span>              <span class="token keyword">else</span>              <span class="token punctuation">{</span>                  humidity <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>              u8g2<span class="token punctuation">.</span><span class="token function">clearBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token function">drawHumidity</span><span class="token punctuation">(</span>RAIN<span class="token punctuation">,</span> humidity<span class="token punctuation">)</span><span class="token punctuation">;</span>              u8g2<span class="token punctuation">.</span><span class="token function">sendBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token function">rt_thread_mdelay</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">MSH_CMD_EXPORT</span><span class="token punctuation">(</span>oled_display<span class="token punctuation">,</span> oled start<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>最后的效果视频太大，放不上来，暂且用图片代替：</p><p><img src="https://img-blog.csdnimg.cn/20200221142507452.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/20200221142521218.png" alt=""><br><img src="https://img-blog.csdnimg.cn/20200221142539777.png" alt=""><br><img src="https://img-blog.csdnimg.cn/20200221142557580.png" alt=""></p><p><font color="red"><strong>接收更多精彩文章及资源推送，欢迎订阅我的微信公众号：『mculover666』。</strong></font><br><img src="https://img-blog.csdnimg.cn/20200202092055136.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 制作过程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 制作过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桌面mini网络时钟教程 | 03-获取NTP时间</title>
      <link href="/posts/2731501981/"/>
      <url>/posts/2731501981/</url>
      
        <content type="html"><![CDATA[<h1 id="1-项目进度"><a href="#1-项目进度" class="headerlink" title="1. 项目进度"></a>1. 项目进度</h1><p>桌面Mini时钟项目用来演示如何使用RT-Thread Stduio开发项目，整个项目的架构如下：<br><img src="https://img-blog.csdnimg.cn/2020020311120887.png#pic_center" alt=""> </p><p>在前两篇博文中简单的介绍了RT-Thread Studio一站式工具，基于STM32L431RCT6这个芯片创建工程，并修改时钟为使用外部时钟，以及添加SHT3x软件包获取温湿度传感器数据。</p><blockquote><ul><li><a href="https://blog.csdn.net/Mculover666/article/details/104146623" target="_blank" rel="noopener">使用RT-Thread Studio DIY 迷你桌面时钟（一）| 基于STM32芯片创建工程</a></li><li><a href="https://mculover666.blog.csdn.net/article/details/104153715" target="_blank" rel="noopener">使用RT-Thread Studio DIY 迷你桌面时钟（二）| 获取温湿度传感器数据（I2C设备驱动+SHT3x软件包）</a></li></ul></blockquote><p>接下来添加at_device设备ESP8266用于连接网络，添加netutils软件包用于获取NTP时间。</p><h1 id="2-添加ESP8266设备驱动"><a href="#2-添加ESP8266设备驱动" class="headerlink" title="2. 添加ESP8266设备驱动"></a>2. 添加ESP8266设备驱动</h1><h2 id="2-1-使能libc组件"><a href="#2-1-使能libc组件" class="headerlink" title="2.1. 使能libc组件"></a>2.1. 使能libc组件</h2><p>使用at_device软件包之前，需要先开启libc组件：<br><img src="https://img-blog.csdnimg.cn/20200220210608546.png" alt=""></p><h2 id="2-2-添加at-device软件包"><a href="#2-2-添加at-device软件包" class="headerlink" title="2.2. 添加at_device软件包"></a>2.2. 添加at_device软件包</h2><p>本项目中使用的是ESP8266设备，其基于AT框架的驱动示例代码在at_device软件包中提供。</p><p>点击添加软件包按钮，搜索at_device，添加该软件包：<br><img src="https://img-blog.csdnimg.cn/20200220210714491.png" alt=""><br>添加到工程设置之后，右键单击进入该软件包配置页面：<br><img src="https://img-blog.csdnimg.cn/20200220210851880.png" alt=""><br>配置实际信息：<br><img src="https://img-blog.csdnimg.cn/20200220211138925.png" alt=""><br>保存设置，软件会自动添加at_device软件包到工程中。</p><h2 id="2-3-开启lpuart1串口设备"><a href="#2-3-开启lpuart1串口设备" class="headerlink" title="2.3. 开启lpuart1串口设备"></a>2.3. 开启lpuart1串口设备</h2><p>在上一小节配置软件包的时候，设置的串口设备为lpuart1，但是目前系统中并没有设备lpuart1，需要手动在<code>board.h</code>文件中开启，开启方法在该文件的注释中已经说明，如图：</p><p><img src="https://img-blog.csdnimg.cn/20200220211611684.png" alt=""></p><p>按照图中注释的说明，首先添加使用lpuart1的宏定义，开启串口：<br><img src="https://img-blog.csdnimg.cn/20200220211805851.png" alt=""><br>接下来修改具体lpuart1串口的引脚配置：<br><img src="https://img-blog.csdnimg.cn/20200220212424417.png" alt=""><br>接下来为了后续方便操作控制台，将sht3x的测试线程先注释掉：<br><img src="https://img-blog.csdnimg.cn/20200220212746461.png" alt=""><br>然后编译整个项目，下载，查看串口输出：<br><img src="https://img-blog.csdnimg.cn/20200220212928877.png" alt=""></p><p>可以看到有一个警告，提示 RT_SERIAL_RB_BUFSZ 的值不够用了，解决方案就是在设置中加大该缓冲区的值：<br><img src="https://img-blog.csdnimg.cn/20200220213149595.png" alt=""></p><p>重新编译，下载，在串口控制台中查看网络是否成功配置：<br><img src="https://img-blog.csdnimg.cn/20200220213443837.png" alt=""></p><blockquote><p>两条红色的日志打印暂且没有影响，是因为使用lpuart的原因，如果换为使用普通uart，在完全相同的配置下，没有这两条信息。</p></blockquote><h2 id="2-4-测试网络"><a href="#2-4-测试网络" class="headerlink" title="2.4. 测试网络"></a>2.4. 测试网络</h2><p>再使用下面的命令进行进一步的测试，确保网络正常能访问外网：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ifconfig</span>        //使用该命令查看当前网卡配置<span class="token function">ping</span> www.baidu.com    //使用该命令测试外网是否可以ping通</code></pre><p>测试结果如下：<br><img src="https://img-blog.csdnimg.cn/20200220213716935.png" alt=""></p><h1 id="3-添加NTP对时功能"><a href="#3-添加NTP对时功能" class="headerlink" title="3. 添加NTP对时功能"></a>3. 添加NTP对时功能</h1><h2 id="3-1-添加netutils工具软件包"><a href="#3-1-添加netutils工具软件包" class="headerlink" title="3.1. 添加netutils工具软件包"></a>3.1. 添加netutils工具软件包</h2><p>netutils软件包中汇集了 RT-Thread 可用的全部网络小工具集合，包括NTP工具。</p><p>NTP 是网络时间协议(Network Time Protocol)，它是用来同步网络中各个计算机时间的协议，RT-Thread 上的 NTP 客户端连接上网络后，可以获取当前 UTC 时间，并更新至 RTC 中。</p><p>打开配置文件，添加软件包，搜索NTP之后添加：<br><img src="https://img-blog.csdnimg.cn/20200220214338407.png" alt=""><br>右击软件包，修改该软件包的配置：<br><img src="https://img-blog.csdnimg.cn/20200220214452604.png" alt=""><br>开启NTP服务器配置即可：<br><img src="https://img-blog.csdnimg.cn/20200220214703716.png" alt=""></p><h2 id="3-2-开启软件模拟RTC"><a href="#3-2-开启软件模拟RTC" class="headerlink" title="3.2. 开启软件模拟RTC"></a>3.2. 开启软件模拟RTC</h2><p>因为NTP工具在获取到网络时间后，需要同步到本地RTC，所以需要开启本地模拟RTC功能：<br><img src="https://img-blog.csdnimg.cn/20200220214952595.png" alt=""><br>开启之后保存配置，重新编译工程，下载，在串口控制台查看是否可以正常工作。</p><h2 id="3-3-测试NTP工作是否正常"><a href="#3-3-测试NTP工作是否正常" class="headerlink" title="3.3. 测试NTP工作是否正常"></a>3.3. 测试NTP工作是否正常</h2><p>使用NTP工具包自带的命令进行测试：</p><pre class=" language-bash"><code class="language-bash">ntp_sync    //获取NTP时间并同步到本地</code></pre><p><img src="https://img-blog.csdnimg.cn/20200220215539556.png" alt=""></p><h1 id="3-4-编写上电自动同步时间代码"><a href="#3-4-编写上电自动同步时间代码" class="headerlink" title="3.4. 编写上电自动同步时间代码"></a>3.4. 编写上电自动同步时间代码</h1><p>在本项目中，需要上电连接网络之后，自动获取NTP时间同步到本地，供后续显示使用，这段代码放在main函数中执行。</p><ul><li>① 检测当前网络是否正常</li></ul><p>netdev（network interface device），即网络接口设备，又称网卡。每一个用于网络连接的设备都可以注册成网卡，为了适配更多的种类的网卡，避免系统中对单一网卡的依赖，RT-Thread 系统提供了 netdev 组件用于网卡管理和控制。</p><p>使用 netdev 网卡功能相关操作函数，需要包含如下头文件：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h></span>         </span><span class="token comment" spellcheck="true">/* 包含 ip_addr_t 等地址相关的头文件 */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;netdev.h></span>            </span><span class="token comment" spellcheck="true">/* 包含全部的 netdev 相关操作接口函数 */</span></code></pre><p>首先获取要操作的网卡对象，每个网卡中有唯一的网卡名称，可以通过网卡名称获取网卡对象：：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> netdev <span class="token operator">*</span><span class="token function">netdev_get_by_name</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>netdev 网卡提供了一个宏定义用于判断网卡是否为 internet_up 状态，如下：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> netdev_is_internet_up(netdev)</span></code></pre><p>通过这个宏定义即可判断当前网络状态是否正常，在main函数中添加如下代码：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//获取网卡对象</span><span class="token keyword">struct</span> netdev<span class="token operator">*</span> net <span class="token operator">=</span> <span class="token function">netdev_get_by_name</span><span class="token punctuation">(</span><span class="token string">"esp0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//阻塞判断当前网络是否正常连接</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">netdev_is_internet_up</span><span class="token punctuation">(</span>net<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token function">rt_thread_mdelay</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//提示当前网络已就绪</span><span class="token function">rt_kprintf</span><span class="token punctuation">(</span><span class="token string">"network is ok!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>编译，下载，效果如下：<br><img src="https://img-blog.csdnimg.cn/20200221090336676.png" alt=""></p><ul><li>② 网络正常后，获取NTP时间并同步到本地RTC</li></ul><p>要使用NTP工具提供的API，首先包含头文件：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;ntp.h></span></span></code></pre><p>接着调用获取时间并同步的API，原型如下：</p><pre class=" language-c"><code class="language-c">time_t <span class="token function">ntp_sync_to_rtc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在上面的代码之后继续添加NTP对时的代码：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//NTP自动对时</span>time_t cur_time<span class="token punctuation">;</span>cur_time <span class="token operator">=</span> <span class="token function">ntp_sync_to_rtc</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cur_time<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">rt_kprintf</span><span class="token punctuation">(</span><span class="token string">"Cur Time: %s"</span><span class="token punctuation">,</span> <span class="token function">ctime</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> time_t<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>cur_time<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token function">rt_kprintf</span><span class="token punctuation">(</span><span class="token string">"NTP sync fail.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>编译，下载，效果如下：<br><img src="https://img-blog.csdnimg.cn/20200221091157972.png" alt=""></p><p><font color="red"><strong>接收更多精彩文章及资源推送，欢迎订阅我的微信公众号：『mculover666』。</strong></font><br><img src="https://img-blog.csdnimg.cn/20200202092055136.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 制作过程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 制作过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桌面mini网络时钟教程 | 02-获取温湿度传感器数据</title>
      <link href="/posts/2192950495/"/>
      <url>/posts/2192950495/</url>
      
        <content type="html"><![CDATA[<h1 id="1-项目进度"><a href="#1-项目进度" class="headerlink" title="1. 项目进度"></a>1. 项目进度</h1><p>桌面Mini时钟项目用来演示如何使用RT-Thread Stduio开发项目，整个项目的架构如下：</p><p><img src="https://img-blog.csdnimg.cn/2020020311120887.png#pic_center" alt=""> </p><p>在上一篇博文中简单的介绍了RT-Thread Studio一站式工具，基于STM32L431RCT6这个芯片创建工程，并修改时钟为使用外部时钟。</p><blockquote><p><a href="https://blog.csdn.net/Mculover666/article/details/104146623" target="_blank" rel="noopener">使用RT-Thread Studio DIY 迷你桌面时钟（一）| 基于STM32芯片创建工程</a></p></blockquote><p>接下里我们开始添加I2C设备，添加SHT3x软件包，获取SHT3x温湿度传感器数据。</p><h1 id="2-添加I2C设备"><a href="#2-添加I2C设备" class="headerlink" title="2. 添加I2C设备"></a>2. 添加I2C设备</h1><h2 id="2-1-打开I2C设备驱动框架"><a href="#2-1-打开I2C设备驱动框架" class="headerlink" title="2.1. 打开I2C设备驱动框架"></a>2.1. 打开I2C设备驱动框架</h2><p>双击左侧 <code>RT-Thread Setting</code> 文件，即可打开RT-Thread图形化配置工具，软件模拟I2C这一项是灰色的，表示没有打开，单击一下即可打开软件 I2C 的驱动框架，图标变为彩色表示打开：<br><img src="https://img-blog.csdnimg.cn/20200203113745577.png" alt=""><br>右击该选项可以打开更多配置，比如查看该驱动设备的依赖、查看该驱动设备的详细配置，查看该驱动设备的API文档，查看在线文档等操作：<br><img src="https://img-blog.csdnimg.cn/20200203113918385.png" alt=""><br>按<code>Ctrl+S</code>保存，配置生效，软件会自动添加I2C设备驱动框架到工程中：<br><img src="https://img-blog.csdnimg.cn/20200203114145426.png" alt=""></p><h2 id="2-2-添加软件-I2C-源码"><a href="#2-2-添加软件-I2C-源码" class="headerlink" title="2.2. 添加软件 I2C 源码"></a>2.2. 添加软件 I2C 源码</h2><p>打开了软件 I2C 的驱动框架之后，还要添加软件I2C的驱动底层实现，具体芯片的软件 I2C 驱动源码不同，本例中下载添加 STM32 系列的软件 I2C 驱动：<a href="https://gitee.com/tyustli/tyustli/tree/master/stm32/soft-i2c" target="_blank" rel="noopener">Gitee 下载地址</a>。</p><pre><code>git clone https://gitee.com/tyustli/tyustli.git</code></pre><p>下载之后源码只有两个文件：<br><img src="https://img-blog.csdnimg.cn/20200203114518477.png" alt=""><br>将这两个文件添加到项目中的<code>drivers</code>文件夹中：<br><img src="https://img-blog.csdnimg.cn/2020020311463736.png" alt=""><br>回到RT-Thread Studio IDE，在项目名称上右击，选择刷新，即可在目录中看到添加的文件：<br><img src="https://img-blog.csdnimg.cn/20200203114732443.png" alt=""></p><h2 id="2-3-注册-I2C-设备"><a href="#2-3-注册-I2C-设备" class="headerlink" title="2.3. 注册 I2C 设备"></a>2.3. 注册 I2C 设备</h2><p>软件 I2C 添加到工程中之后就可以调用软件 I2C 注册函数 <code>rt_hw_i2c_init</code> 来注册软件 I2C 设备了，该函数的原型如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">rt_hw_i2c_init</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> rt_uint8_t scl<span class="token punctuation">,</span> rt_uint8_t sda<span class="token punctuation">)</span></code></pre><ul><li>name：设备名称</li><li>scl：软件模拟I2C的SCL引脚</li><li>sda：软件模拟I2C的SDA引脚</li></ul><p>在小熊派IoT开发板上，温湿度传感器SHT30连接在PB6（SCL）和PB7（SDA） ，所以在<code>main.c</code>文件中先添加头文件：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;drv_soft_i2c.h></span></span></code></pre><p>然后在文件<strong>最后</strong>添加如下注册软件 I2C到系统中的代码：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">register_i2c</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">rt_hw_i2c_init</span><span class="token punctuation">(</span><span class="token string">"i2c1"</span><span class="token punctuation">,</span> <span class="token function">GET_PIN</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">GET_PIN</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> RT_EOK<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//注册到系统中，自动初始化设备</span><span class="token function">INIT_BOARD_EXPORT</span><span class="token punctuation">(</span>register_i2c<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>添加完成之后点击编译，下载到开发板中运行，即可在串口终端中看到日志信息（绿色），提示I2C总线设备已注册成功：<br><img src="https://img-blog.csdnimg.cn/20200220205525306.png" alt=""></p><p>因为main线程中循环打印对使用控制台有影响，所以将打印函数注释：<br><img src="https://img-blog.csdnimg.cn/20200203115933671.png" alt=""></p><p>重新编译下载，在串口终端中输入命令<code>list_device</code>查看系统中注册的设备吗，再次确认I2C总线设备注册成功：<br><img src="https://img-blog.csdnimg.cn/20200220205625815.png" alt=""></p><h1 id="3-添加SHT3x软件包"><a href="#3-添加SHT3x软件包" class="headerlink" title="3. 添加SHT3x软件包"></a>3. 添加SHT3x软件包</h1><h2 id="3-1-搜索添加软件包"><a href="#3-1-搜索添加软件包" class="headerlink" title="3.1. 搜索添加软件包"></a>3.1. 搜索添加软件包</h2><p>RT-Thread Studio有在线软件包中心，里面有非常丰富的软件包供用户使用，点击立即添加进入：<br><img src="https://img-blog.csdnimg.cn/20200203125004277.png" alt=""></p><p>搜索<code>SHT</code>，使用的传感器型号为SHT30，所以添加SHT3x软件包：<br><img src="https://img-blog.csdnimg.cn/20200203125057439.png" alt=""><br>添加之后，在项目设置中即可看到该软件包，右击可以查看软件包在线文档：<br><img src="https://img-blog.csdnimg.cn/2020020312523714.png" alt=""></p><p>软件会自动打开该软件包的在线说明文档，在使用软件包之前，该文档必须要看：<br><img src="https://img-blog.csdnimg.cn/20200203125300994.png" alt=""><br>接下来按<code>Ctrl+S</code>保存项目，软件会自动添加软件包代码到工程中，其中<code>README.md</code>是软件包详细使用文档，使用前必须要看：<br><img src="https://img-blog.csdnimg.cn/20200203125559261.png" alt=""></p><p>接下来编译、下载项目到开发板中，查看串口终端输出。</p><h2 id="3-2-使用命令测试软件包"><a href="#3-2-使用命令测试软件包" class="headerlink" title="3.2. 使用命令测试软件包"></a>3.2. 使用命令测试软件包</h2><p>大部分软件包都提供测试命令，SHT3x软件包也是一样，提供了如下命令供测试：</p><pre class=" language-c"><code class="language-c"><span class="token operator">-</span> sht3x probe <span class="token operator">&lt;</span>i2c_dev_name<span class="token operator">></span> <span class="token operator">&lt;</span>pu<span class="token operator">/</span>pd<span class="token operator">></span>  <span class="token operator">--</span>挂载SHT3x设备，需要指定i2c设备名称和上下拉方式，默认下拉<span class="token operator">-</span> sht3x read <span class="token operator">--</span>阅读SHT3x温湿度<span class="token operator">-</span> sht3x status <span class="token operator">--</span>读取查看状态寄存器值<span class="token operator">-</span> sht3x reset <span class="token operator">--</span>软件复位SHT3x<span class="token operator">-</span> sht3x heater <span class="token operator">&lt;</span>on<span class="token operator">/</span>off<span class="token operator">></span> <span class="token operator">--</span>开<span class="token operator">/</span>关heater</code></pre><p>首先挂载SHT30温湿度传感器到之前注册的I2C总线设备上：<br><img src="https://img-blog.csdnimg.cn/20200220205752729.png" alt=""></p><p>挂载之后可以进行查看寄存器，读取温湿度，复位，开/关heater操作，比如读取一次温度和湿度：<br><img src="https://img-blog.csdnimg.cn/20200220205821175.png" alt=""></p><h1 id="4-获取温湿度传感器数据"><a href="#4-获取温湿度传感器数据" class="headerlink" title="4. 获取温湿度传感器数据"></a>4. 获取温湿度传感器数据</h1><p>在使用软件包提供的命令测试设备成功之后，创建一个线程，使用SHT3x软件包提供的API获取SHT3x数据。</p><p>在Applicaition分组之下，新建一个文件<code>sht30_ccollect.c</code>用于存放SHT3x获取数据的相关代码，编辑以下内容：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* * Copyright (c) 2006-2019, RT-Thread Development Team * * SPDX-License-Identifier: Apache-2.0 * * Change Logs: * Date           Author       Notes * 2020-02-20     Mculover666  the first version */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;rtthread.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;board.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sht3x.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> THREAD_PRIORITY         25</span><span class="token macro property">#<span class="token directive keyword">define</span> THREAD_STACK_SIZE       512</span><span class="token macro property">#<span class="token directive keyword">define</span> THREAD_TIMESLICE        5</span><span class="token keyword">static</span> rt_thread_t tid1 <span class="token operator">=</span> RT_NULL<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 入口函数 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sht30_collect_thread_entry</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>parameter<span class="token punctuation">)</span><span class="token punctuation">{</span>    sht3x_device_t  sht3x_device<span class="token punctuation">;</span>    sht3x_device <span class="token operator">=</span> <span class="token function">sht3x_init</span><span class="token punctuation">(</span><span class="token string">"i2c1"</span><span class="token punctuation">,</span> <span class="token number">0x44</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>RT_EOK <span class="token operator">==</span> <span class="token function">sht3x_read_singleshot</span><span class="token punctuation">(</span>sht3x_device<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">rt_kprintf</span><span class="token punctuation">(</span><span class="token string">"sht30 humidity   : %d.%d  "</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>sht3x_device<span class="token operator">-></span>humidity<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>sht3x_device<span class="token operator">-></span>humidity <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rt_kprintf</span><span class="token punctuation">(</span><span class="token string">"temperature: %d.%d\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>sht3x_device<span class="token operator">-></span>temperature<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>sht3x_device<span class="token operator">-></span>temperature <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token function">rt_kprintf</span><span class="token punctuation">(</span><span class="token string">"read sht3x fail.\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">rt_thread_mdelay</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 创建线程 */</span><span class="token keyword">int</span> <span class="token function">sht30_collect</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 创建线程*/</span>    tid1 <span class="token operator">=</span> <span class="token function">rt_thread_create</span><span class="token punctuation">(</span><span class="token string">"sht30_collect_thread"</span><span class="token punctuation">,</span>            sht30_collect_thread_entry<span class="token punctuation">,</span> RT_NULL<span class="token punctuation">,</span>                            THREAD_STACK_SIZE<span class="token punctuation">,</span>                            THREAD_PRIORITY<span class="token punctuation">,</span> THREAD_TIMESLICE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 如果获得线程控制块，启动这个线程 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tid1 <span class="token operator">!=</span> RT_NULL<span class="token punctuation">)</span>        <span class="token function">rt_thread_startup</span><span class="token punctuation">(</span>tid1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在main.c中测试该程序：<br><img src="https://img-blog.csdnimg.cn/20200203131526137.png" alt=""><br>编译下载程序，在串口终端查看结果：</p><p><img src="https://img-blog.csdnimg.cn/20200220205943216.png" alt=""></p><p><font color="red"><strong>接收更多精彩文章及资源推送，欢迎订阅我的微信公众号：『mculover666』。</strong></font><br><img src="https://img-blog.csdnimg.cn/20200202092055136.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 制作过程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 制作过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桌面mini网络时钟教程 | 01-基于STM32芯片创建HelloWorld工程</title>
      <link href="/posts/2303339885/"/>
      <url>/posts/2303339885/</url>
      
        <content type="html"><![CDATA[<h1 id="1-RT-Thread-Studio"><a href="#1-RT-Thread-Studio" class="headerlink" title="1. RT-Thread Studio"></a>1. RT-Thread Studio</h1><p>RT-Thread Studio 是<strong>一站式的 RT-Thread 开发工具</strong>，通过简单易用的图形化配置系统以及丰富的软件包和组件资源，让物联网开发变得简单和高效。<br><img src="https://img-blog.csdnimg.cn/20200202170325301.png#pic_center" alt=""><br>RT-Thread主要包括工程创建和管理，代码编辑，SDK管理，RT-Thread配置，构建配置，调试配置，程序下载和调试等功能，结合图形化配置系统以及软件包和组件资源，减少重复工作，提高开发效率。</p><p><img src="https://img-blog.csdnimg.cn/20200202170406175.png" alt=""></p><p>RT-Thread STudio了可以从<a href="https://www.rt-thread.org/page/download.html#studio" target="_blank" rel="noopener">RT-Thread官网</a>下载，下载之后一路next安装即可，注意安装路径不要有中文或者空格。<br><img src="https://img-blog.csdnimg.cn/20200203110427759.png" alt=""></p><h1 id="2-桌面mini时钟项目"><a href="#2-桌面mini时钟项目" class="headerlink" title="2. 桌面mini时钟项目"></a>2. 桌面mini时钟项目</h1><p>迷你桌面时钟项目基于小熊派IoT开发板，使用RT-Thread物联网操作系统，使用RT-Thread Studio一站式开发工具，在极短的时间内开发完成一个桌面mini时钟。</p><p>整个项目的架构如下：<br><img src="https://img-blog.csdnimg.cn/2020020217203582.png" alt=""><br>项目所用的芯片型号如下：</p><ul><li>主控芯片：STM32L431RCT6</li><li>温湿度传感器：    SHT30</li><li>通信模组：ESP8266（WIFI）</li><li>显示模组：0.96’OLED（SSD1306）</li></ul><p>其中，SHT30传感器挂载到STM32的I2C1引脚上，OLED挂载到STM32的I2C3引脚上，两个设备均使用模拟I2C总线通信，ESP8266与STM32之间采用串口发送AT指令通信。</p><h1 id="3-基于芯片创建项目"><a href="#3-基于芯片创建项目" class="headerlink" title="3. 基于芯片创建项目"></a>3. 基于芯片创建项目</h1><p>① 打开RT-Thread Studio，点击左上角新建项目，新建一个RT-Thread项目：<br><img src="https://img-blog.csdnimg.cn/20200202172950506.png" alt=""></p><p>② 填写项目信息，基于芯片创建项目：</p><blockquote><p><strong>RT-Thead支持全系列STM32芯片，所以可以使用任何STM32开发板！</strong></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200202173448981.png" alt=""><br>③ 点击“小锤子”编译整个工程：<br><img src="https://img-blog.csdnimg.cn/20200202173803445.png" alt=""><br>所有编译信息都会在控制台输出：<br><img src="https://img-blog.csdnimg.cn/20200202173912355.png" alt=""></p><p>④ 点击按钮，在Putty创建一个串口终端：<br><img src="https://img-blog.csdnimg.cn/20200202174335624.png" alt=""><br>填写串口信息，打开串口：<br><img src="https://img-blog.csdnimg.cn/20200220204939424.png" alt=""><br>打开之后的串口终端如图所示：<br><img src="https://img-blog.csdnimg.cn/20200220205025561.png" alt=""></p><p>⑤ 点击按钮下载工程：<br><img src="https://img-blog.csdnimg.cn/20200202174444835.png" alt=""><br>所有下载信息都在控制台输出：<br><img src="https://img-blog.csdnimg.cn/20200202174525706.png" alt=""><br>⑥ 下载完毕自动复位运行，在串口终端查看输出：<br><img src="https://img-blog.csdnimg.cn/20200220205213254.png" alt=""></p><p><font color="red"><strong>一行代码都不用写，RT-Thread就在板子上跑起来了，爽不爽！</strong></font></p><h1 id="4-让LED闪烁起来"><a href="#4-让LED闪烁起来" class="headerlink" title="4. 让LED闪烁起来"></a>4. 让LED闪烁起来</h1><p>RT-Thread Studio默认生成的main./c中已经包含了LED闪烁的程序，我们只需要修改引脚即可。</p><p>小熊派IoT开发板板载一个LED，默认连接在PC13引脚上，修改这行代码设置引脚：<br><img src="https://img-blog.csdnimg.cn/20200202190419592.png" alt=""><br>再次编译，下载，可以看到板载蓝色LED开始闪烁。</p><h1 id="5-使用外部晶振时钟"><a href="#5-使用外部晶振时钟" class="headerlink" title="5. 使用外部晶振时钟"></a>5. 使用外部晶振时钟</h1><p>使用RT-Thread Studio<strong>基于芯片创建的工程全部使用内部时钟HSI</strong>，要使用外部晶振时钟HSE，在<code>board.c</code>中修改<code>SystemClock_Config</code>函数，这里我修改如下：<br><img src="https://img-blog.csdnimg.cn/20200202201426822.png" alt=""></p><p>再次编译下载，可以看到现象和之前使用HSI时候的现象一致。</p><p><font color="red"><strong>接收更多精彩文章及资源推送，欢迎订阅我的微信公众号：『mculover666』。</strong></font><br><img src="https://img-blog.csdnimg.cn/20200202092055136.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 制作过程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 制作过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab2018安装教程</title>
      <link href="/posts/2806899914/"/>
      <url>/posts/2806899914/</url>
      
        <content type="html"><![CDATA[<h1 id="1-安装前的注意事项"><a href="#1-安装前的注意事项" class="headerlink" title="1. 安装前的注意事项"></a>1. 安装前的注意事项</h1><p><strong>电脑必须断开网络连接！</strong></p><p><strong>电脑必须断开网络连接！</strong></p><p><strong>电脑必须断开网络连接！</strong></p><blockquote><p>本文档是静态页面，加载出来之后就可以断网了，不影响在浏览器中阅读！</p></blockquote><h1 id="2-启动安装"><a href="#2-启动安装" class="headerlink" title="2. 启动安装"></a>2. 启动安装</h1><p>双击运行setup.exe，启动安装程序：</p><p><img src="http://mculover666.cn/blog/20200220/ufzXb37KFV4w.png?imageslim" alt="setup.exe"></p><p>选择使用文件安装秘钥：</p><p><img src="http://mculover666.cn/blog/20200220/v5OLWe1ye7ij.png?imageslim" alt="选择安装方法"></p><p>接受许可协议：</p><p><img src="http://mculover666.cn/blog/20200220/gObKPS0sy4qF.png?imageslim" alt="接受许可协议"></p><p>填写秘钥：</p><blockquote><p>秘钥在安装包中的秘钥.txt文件中中！</p></blockquote><p><img src="http://mculover666.cn/blog/20200220/KlYQlpxhHYRX.png?imageslim" alt="填写秘钥"></p><p>接下来选择安装位置，注意目录不要有空格或者中文：</p><p><img src="http://mculover666.cn/blog/20200220/4t8xEWhoTxX9.png?imageslim" alt="安装路径"></p><h1 id="3-选择安装产品"><a href="#3-选择安装产品" class="headerlink" title="3. 选择安装产品"></a>3. 选择安装产品</h1><p>Matlab中包含matlab全系列产品，可以根据自己的需要选择安装，没必要全部安装，而且<strong>以后有需要时，可以重新启动这个安装程序，选择对应的产品再次进行安装</strong>：</p><ul><li>Matlab核心产品（必选）</li><li>Simulink相关</li><li>各种工具包</li></ul><p>在本教程中只演示如何安装Mtalab核心产品，如下面的两张图：</p><p><img src="http://mculover666.cn/blog/20200220/1g60JKqL9p2v.png?imageslim" alt="选择安装产品"></p><p><img src="http://mculover666.cn/blog/20200220/7w2nbuSV78qA.png?imageslim" alt="选择matlab核心"></p><p>在输出的安装信息中可以看到本次安装的产品列表和占用空间的大小：</p><p><img src="http://mculover666.cn/blog/20200220/ou6pYWzPqjFK.png?imageslim" alt="本次安装信息"></p><p>等待安装完成：</p><p><img src="http://mculover666.cn/blog/20200220/YbbkHrEdW9Me.png?imageslim" alt="安装过程"></p><p><img src="http://mculover666.cn/blog/20200220/t04oXrqUtWqn.png?imageslim" alt="mark"></p><h1 id="4-创建桌面图标"><a href="#4-创建桌面图标" class="headerlink" title="4. 创建桌面图标"></a>4. 创建桌面图标</h1><blockquote><p><strong>请勿启动Matlab！</strong></p></blockquote><p>安装完成后，Matlab不会自动创建桌面快捷方式，需要手动创建。</p><p>首先在Matlab安装目录找到主程序Matlab.exe：</p><p><img src="http://mculover666.cn/blog/20200220/zKwegeLG770a.png?imageslim" alt="Matlab主程序"></p><p>然后将其右键-&gt;发送到-&gt;桌面快捷方式，即可。</p><h1 id="5-激活"><a href="#5-激活" class="headerlink" title="5. 激活"></a>5. 激活</h1><blockquote><p><strong>仍然需要处于断网状态！</strong></p></blockquote><p>附件：<a href="https://c-t.work/s/a255047009394b" target="_blank" rel="noopener">Matlab激活文件下载链接</a>。</p><p>将 MATLAB R2018a Win64 Crack 文件夹内的 <code>license_standalone.lic</code> 文件复制到安装目录 license 目录里面，默认在<code>\MATLAB\R2018a\licenses</code>中：</p><p><img src="http://mculover666.cn/blog/20200220/7yYvvrL4nvsX.png?imageslim" alt="复制license文件"></p><p>将 MATLAB R2018a Win64 Crack内<code>R2018a\bin\win64</code>目录下的文件<code>netapi32.dll</code>，复制到安装目录下的<code>R2018a\bin\win64</code>目录中，会自动弹出是否覆盖，选择替换覆盖即可：</p><p><img src="http://mculover666.cn/blog/20200220/Vf4fD6W8UKz3.png?imageslim" alt="替换文件"></p><p>激活完成，接下里启动Matlab，愉快的玩耍吧~</p><p><img src="http://mculover666.cn/blog/20200220/BeUhUB4SBLkI.png?imageslim" alt="Matlab主界面"></p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> 安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX-26 | 使用硬件I2C读取温湿度传感器数据（HTS221）</title>
      <link href="/posts/4097081462/"/>
      <url>/posts/4097081462/</url>
      
        <content type="html"><![CDATA[<p>本篇详细的记录了如何使用STM32CubeMX配置STM32L431RCT6的硬件I2C外设，读取HTS221温湿度传感器的数据并通过串口发送。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L0的开发板（ST Nucleo-64），主控芯片是STM32L073RZ：</li></ul><p><img src="http://mculover666.cn/blog/20191223/PutQl2dff5JU.png?imageslim" alt="ST Nucleo开发板"></p><ul><li>HTS221温湿度传感器<br>HTS221温湿度传感器是ST公司生产的一款超小型温湿度传感器，提供 16-bit 的温度和湿度输出数据，并且数据输出提供了IIC 和 SPI两种通信接口，具有 2 x 2 x 0.9 mm 的极小封装：</li></ul><p><img src="http://mculover666.cn/blog/20191229/pYva2s2VnULB.png?imageslim" alt="HTS221实物图"></p><p>HTS221的原理图如下：</p><p><img src="http://mculover666.cn/blog/20191229/XwYSdGHnBS3i.png?imageslim" alt="HTS221原理图"></p><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li><li>准备一个串口调试助手，这里我使用的是<code>Serial Port Utility</code>；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt="mark"></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：</p><p><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt="芯片选择器"></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:</p><p><img src="http://mculover666.cn/blog/20191229/kEmUz7AmX6fA.png?imageslim" alt="选中实验芯片"></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><p>该开发板上没有板载外部晶振，所以<strong>使用内部时钟（HSI）</strong>，RCC 设置保持默认：</p><p><img src="http://mculover666.cn/blog/20191223/zlFwDhdqz1ba.png?imageslim" alt="时钟源配置"></p><h2 id="配置串口"><a href="#配置串口" class="headerlink" title="配置串口"></a>配置串口</h2><p>ST-Nucleo 开发板板载ST-Link并且虚拟了一个串口，该串口与STM32芯片的USART2相连。</p><p>接下来开始配置<code>USART2</code>：</p><p><img src="http://mculover666.cn/blog/20191223/dV2ABytb6s9U.png?imageslim" alt="串口配置"></p><h2 id="配置I2C接口"><a href="#配置I2C接口" class="headerlink" title="配置I2C接口"></a>配置I2C接口</h2><p>查看ST-Nucleo扩展接口的原理图：</p><p><img src="http://mculover666.cn/blog/20191223/GLqiXFliNfTS.png?imageslim" alt="扩展接口原理图"></p><p>接下来开始配置<code>I2C1</code>接口：</p><p><img src="http://mculover666.cn/blog/20191223/2VcRVDu4kGOW.png?imageslim" alt="配置I2C1接口"></p><p>注意，I2C1接口默认的引脚是<code>PA9</code>和<code>PA10</code>，与实际板子连接<strong>不相符</strong>，所以手动切换到<code>PA8</code>和<code>PB9</code>:</p><p><img src="http://mculover666.cn/blog/20191223/tXoBIVULFMlX.png?imageslim" alt="切换I2C1引脚"></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L0的最高主频到32M，所以配置PLL，最后使<code>HCLK = 32Mhz</code>即可：</p><p><img src="http://mculover666.cn/blog/20191223/03l2rjMcWkIA.png?imageslim" alt="时钟树配置"></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/blog/20191223/Ga0a2tExr0H7.png?imageslim" alt="生成工程设置"></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：</p><p><img src="http://mculover666.cn/blog/20191223/TlGTUVYMQvSs.png?imageslim" alt="代码生成设置"></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：</p><p><img src="http://mculover666.cn/blog/20191223/G0F33OQfLgWc.png?imageslim" alt="生成代码"></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="3-1-Printf重定向"><a href="#3-1-Printf重定向" class="headerlink" title="3.1. Printf重定向"></a>3.1. Printf重定向</h2><p>在本实验中，温湿度传感器数据需要通过串口打印，所以需要配置printf重定向：</p><ul><li>参考教程：<a href="http://www.mculover666.cn/posts/2251182441/">STM32CubeMX_09 | 重定向printf函数到串口输出的多种方法</a>。</li></ul><blockquote><p>注意：教程里将printf重定向到USAR1，本实验中ST-Link的虚拟串口与USART2相连，所以需要重定向到USART2！</p></blockquote><p><img src="http://mculover666.cn/blog/20191223/piIQj0ufW0NB.png?imageslim" alt="重定向到USART2"></p><h2 id="3-2-编写HTS221驱动"><a href="#3-2-编写HTS221驱动" class="headerlink" title="3.2. 编写HTS221驱动"></a>3.2. 编写HTS221驱动</h2><p>参考<a href="">HTS221数据手册.pdf</a>进行编程。</p><p>HTS221的驱动我已上传到<a href="https://github.com/Mculover666/HAL_Driver_Lib/tree/master/HTS221" target="_blank" rel="noopener">Github</a>，包含两个文件：</p><ul><li><code>HTS221.h</code>：器件地址宏定义、寄存器地址宏定义；</li><li><code>HTS221.c</code>：获取温度函数实现，获取湿度函数实现；</li></ul><h1 id="4-测试驱动程序"><a href="#4-测试驱动程序" class="headerlink" title="4. 测试驱动程序"></a>4. 测试驱动程序</h1><p>将驱动程序添加到你的工程中后，在main.c中测试驱动程序是否正常：</p><p>首先在main.c 开头包含头文件：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* USER CODE BEGIN Includes */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"HTS221.h"</span></span><span class="token comment" spellcheck="true">/* USER CODE END Includes */</span></code></pre><p>然后在main函数中编写测试程序：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* USER CODE BEGIN 1 */</span>    int16_t temperature<span class="token punctuation">;</span>    int16_t humidity<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* USER CODE END 1 */</span>    <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Initialize all configured peripherals */</span>    <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_USART2_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_I2C1_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"HTS221 Test...\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">HTS221_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* USER CODE END 2 */</span>    <span class="token comment" spellcheck="true">/* Infinite loop */</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN WHILE */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* USER CODE END WHILE */</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 3 */</span>        <span class="token function">HTS221_Get_Temperature</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>temperature<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"temperature:%2.1f"</span><span class="token punctuation">,</span> temperature <span class="token operator">/</span> <span class="token number">10.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">HTS221_Get_Humidity</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>humidity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  humidity:%2.1f\n"</span><span class="token punctuation">,</span> humidity <span class="token operator">/</span> <span class="token number">10.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* USER CODE END 3 */</span><span class="token punctuation">}</span></code></pre><p>编译下载运行，测试结果如下：</p><p><img src="http://mculover666.cn/blog/20191229/BQixPqWigw6r.png?imageslim" alt="测试结果"></p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX 温湿度传感器 HTS221 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX系列教程</title>
      <link href="/posts/578764034/"/>
      <url>/posts/578764034/</url>
      
        <content type="html"><![CDATA[<p>秒变 STM32 大神，STM32CubeMX你值得拥有！</p><p><img src="http://mculover666.cn/image/20190906/ieVVbmjhuNm8.jpg?imageslim" alt="STM32CubeMX"></p><a id="more"></a><p><strong>本教程共包含 20 篇文章，手把手带你学会用 STM32CubeMX 配置工程并生成底层初始化代码工程，将有限的精力专注于应用代码编写。</strong></p><h1 id="阅读平台"><a href="#阅读平台" class="headerlink" title="阅读平台"></a>阅读平台</h1><p>本系列教程的阅读平台推荐：</p><ul><li><a href="https://www.mculover666.cn/posts/578764034/">PC端： Mculover666的个人博客</a></li><li><a href="">移动端： 微信公众号『Mculover666』</a></li></ul><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt=""></p><h1 id="STM32CubeMX介绍篇"><a href="#STM32CubeMX介绍篇" class="headerlink" title="STM32CubeMX介绍篇"></a>STM32CubeMX介绍篇</h1><ul><li><a href="http://www.mculover666.cn/posts/1350058916/">STM32CubeMX_01 | 初识 STM32Cube 生态系统</a></li><li><a href="http://www.mculover666.cn/posts/2106737533/">STM32CubeMX_02 | 获取并安装STM32CubeMX</a></li></ul><h1 id="STM32CubeMX实战篇"><a href="#STM32CubeMX实战篇" class="headerlink" title="STM32CubeMX实战篇"></a>STM32CubeMX实战篇</h1><blockquote><p>实战篇中使用的开发板是小熊派开发板</p></blockquote><ul><li><a href="http://www.mculover666.cn/posts/2046075734/">STM32CubeMX_03 | 使用GPIO点亮一个LED</a></li><li><a href="http://www.mculover666.cn/posts/1763774108/">STM32CubeMX_04 | 使用GPIO进行按键检测</a></li><li><a href="http://www.mculover666.cn/posts/2504113390/">STM32CubeMX_05 | 使用EXIT中断检测按键</a></li><li><a href="http://www.mculover666.cn/posts/2064921339/">STM32CubeMX_06 | 使用USART发送和接收数据（查询模式）</a></li><li><a href="http://www.mculover666.cn/posts/1803605667/">STM32CubeMX_07 | 使用USART发送和接收数据（中断模式）</a></li><li><a href="http://www.mculover666.cn/posts/1606619423/">STM32CubeMX-08 | 使用USART发送和接收数据(DMA模式)</a></li><li><a href="http://www.mculover666.cn/posts/2251182441/">STM32CubeMX-09 | 重定向printf函数到串口输出的多种方法</a></li><li><a href="http://www.mculover666.cn/posts/1249993360/">STM32CubeMX-10 | 使用ADC读取气体传感器数据（MQ-2）</a></li><li><a href="http://www.mculover666.cn/posts/1598873035/">STM32CubeMX-11 | 使用通用定时器闪烁LED</a></li><li><a href="http://www.mculover666.cn/posts/650884631/">STM32CubeMX-12 | 使用通用定时器产生PWM驱动蜂鸣器</a></li><li><a href="http://www.mculover666.cn/posts/3523891062/">STM32CubeMX-13 | 使用硬件I2C读写EEPROM（AT24C02）</a></li><li><a href="http://www.mculover666.cn/posts/1561092257/">STM32CubeMX-14 | 使用硬件I2C读取环境光强度传感器数据（BH1750）</a></li><li><a href="http://www.mculover666.cn/posts/2508748577/">STM32CubeMX-15 | 使用硬件I2C读取温湿度传感器数据（SHT30）</a></li><li><a href="http://www.mculover666.cn/posts/842429667/">STM32CubeMX-16 | 使用硬件CRC校验数据（以SHT30为例）</a></li><li><a href="http://www.mculover666.cn/posts/1935373145/">如何通俗的理解CRC校验并用C语言实现</a></li><li><a href="http://www.mculover666.cn/posts/4251315252/">STM32CubeMX-17 | 使用硬件SPI驱动TFT-LCD（ST7789）</a></li><li><a href="http://www.mculover666.cn/posts/1294047065/">STM32CubeMX-18 | 使用硬件QSPI读写SPI%20Flash（W25Q64）</a></li><li><a href="http://www.mculover666.cn/posts/3022954032/">STM32CubeMX-19 | 使用SDMMC接口读写SD卡数据</a></li><li><a href="http://www.mculover666.cn/posts/2707806886/">STM32CubeMX_20 | 使用DAC输出任意指定电压值</a></li><li><a href="http://www.mculover666.cn/posts/862377868/">STM32CubeMX-21 | 使用ADC读取电压值</a></li><li><a href="http://www.mculover666.cn/posts/2214138023/">STM32CubeMX-22 | 在SD卡上移植FATFS文件系统</a></li><li><a href="http://www.mculover666.cn/posts/3463670498/">STM32CubeMX-23 | 使用 USART 接收GPS数据并解析</a></li><li><a href="http://www.mculover666.cn/posts/933841213/">STM32CubeMX-24 | 使用通用定时器产生PWM驱动舵机</a></li><li><a href="http://www.mculover666.cn/posts/390108705/">STM32CubeMX-25 | 使用硬件I2C驱动OLED(SSD1306)</a></li><li><a href="http://www.mculover666.cn/posts/4097081462/">STM32CubeMX-26 | 使用硬件I2C读取温湿度传感器数据（HTS221）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_25 | 使用硬件I2C驱动OLED(SSD1306)</title>
      <link href="/posts/390108705/"/>
      <url>/posts/390108705/</url>
      
        <content type="html"><![CDATA[<p>本篇详细的记录了如何使用STM32CubeMX配置STM32L431RCT6的硬件I2C外设驱动0.96’OLED屏幕。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：</li></ul><p><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt=""></p><ul><li>OLED屏幕<br>这里我使用的是0.96’的OLED屏幕，使用IIC接口通信，驱动芯片为SD1306：</li></ul><p><img src="http://mculover666.cn/blog/20191209/PULv8RRTRqlt.png?imageslim" alt="OLED屏幕"></p><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt=""></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：<br><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt=""></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:<br><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt=""></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：<br><img src="http://mculover666.cn/image/20190806/k593lGGb5tlW.png?imageslim" alt=""></p><h2 id="配置串口"><a href="#配置串口" class="headerlink" title="配置串口"></a>配置串口</h2><p>小熊派开发板板载ST-Link并且虚拟了一个串口，原理图如下：</p><p><img src="http://mculover666.cn/image/20190814/IwyXONVefPx9.png?imageslim" alt=""></p><p>这里我将开关拨到<code>AT-MCU</code>模式，使PC的串口与USART1之间连接。</p><p>接下来开始配置<code>USART1</code>：</p><p><img src="http://mculover666.cn/image/20190814/nLMRMYtmzghl.png?imageslim" alt=""></p><h2 id="配置硬件I2C"><a href="#配置硬件I2C" class="headerlink" title="配置硬件I2C"></a>配置硬件I2C</h2><p>在本实验中，我们将OLED接在小熊派开发板左边的E53扩展板接口上，与 I2C1 接口相连。</p><p>接下来开始配置I2C接口1：</p><p><img src="http://mculover666.cn/image/20190826/obFsy5wJHDXz.png?imageslim" alt=""></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：</p><p><img src="http://mculover666.cn/image/20190806/1TQg7frjRpVr.png?imageslim" alt=""></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/blog/20191209/J7Atsprks4Qt.png?imageslim" alt=""></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：</p><p><img src="http://mculover666.cn/image/20190806/T6WvSK6Dfpts.png?imageslim" alt=""></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：</p><p><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt=""></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="重定向printf-函数"><a href="#重定向printf-函数" class="headerlink" title="重定向printf()函数"></a>重定向printf()函数</h2><p>参考：<a href="http://www.mculover666.cn/posts/2251182441/">STM32CubeMX-09 | 重定向printf函数到串口输出的多种方法</a></p><h2 id="OLED屏幕驱动程序"><a href="#OLED屏幕驱动程序" class="headerlink" title="OLED屏幕驱动程序"></a>OLED屏幕驱动程序</h2><p>OLED屏幕驱动我已移植好，包含的文件较多，代码就不放在文中了，我已上传到<a href="https://github.com/Mculover666/HAL_Driver_Lib" target="_blank" rel="noopener">Github</a>：</p><ul><li>oledfont.h：OLED ASCII英文字符字库文件和中文字库文件</li><li>bmp.h：图片库文件</li><li>oled.h：OELD功能函数声明</li><li>oled.c：OLED功能函数实现</li></ul><h1 id="4-测试驱动程序"><a href="#4-测试驱动程序" class="headerlink" title="4. 测试驱动程序"></a>4. 测试驱动程序</h1><p>将驱动程序添加到你的工程中后，在main.c中测试驱动程序是否正常：</p><p>首先在main.c 开头包含头文件：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* USER CODE BEGIN Includes */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"oled.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"bmp.h"</span></span><span class="token comment" spellcheck="true">/* USER CODE END Includes */</span></code></pre><p>然后在main函数中编写测试程序：</p><pre class=" language-c"><code class="language-c">nt <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_I2C1_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"OLED 0.96' TEST...\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">OLED_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* USER CODE END 2 */</span>    <span class="token comment" spellcheck="true">/* Infinite loop */</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN WHILE */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* USER CODE END WHILE */</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 3 */</span>    <span class="token function">OLED_Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">OLED_ShowChar</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">OLED_ShowChar</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">OLED_ShowChar</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">OLED_ShowChar</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">OLED_ShowChar</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">OLED_ShowChar</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">OLED_ShowChar</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">OLED_ShowChar</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">OLED_ShowChar</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">OLED_ShowChar</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'F'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">OLED_ShowChar</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'G'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">OLED_ShowChar</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'H'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">OLED_ShowString</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"mculover666"</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">OLED_ShowCHinese</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">OLED_ShowCHinese</span><span class="token punctuation">(</span><span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">OLED_ShowCHinese</span><span class="token punctuation">(</span><span class="token number">95</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">OLED_ShowString</span><span class="token punctuation">(</span><span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">"IoT Board"</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">OLED_DrawBMP</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span>BMP1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* USER CODE END 3 */</span><span class="token punctuation">}</span></code></pre><p>编译下载运行，测试结果如下：</p><p><img src="http://mculover666.cn/blog/20191209/GenHBrWdhjWW.png?imageslim" alt="OLED字符显示测试"></p><p><img src="http://mculover666.cn/blog/20191209/Ft0SI7xEEHuw.png?imageslim" alt="OLED图片显示测试"></p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_24 | 使用通用定时器产生PWM驱动舵机</title>
      <link href="/posts/933841213/"/>
      <url>/posts/933841213/</url>
      
        <content type="html"><![CDATA[<p>本篇详细的记录了如何使用STM32CubeMX配置STM32L431RCT6的通用定时器外设，产生PWM驱动舵机。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：</li></ul><p><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt="小熊派IoT开发套件"></p><ul><li>舵机</li></ul><p>这里我使用常见的 SG90 舵机：</p><p><img src="http://mculover666.cn/blog/20191205/FHWF7Azy542U.png?imageslim" alt="9g舵机"></p><blockquote><p>知识小卡片 —— 舵机</p></blockquote><p>舵机是电机的一种，又叫伺服电机，舵机的优势是<strong>可以设定转到指定的位置</strong>，本文中使用的SG90型号的舵机可以在0°-180°的范围内转动到指定角度，在实际项目中使用非常广泛。</p><p>在硬件上，SG90 舵机有三根线，红色的为电源线（5V），棕色的为 GND ，橙色的为控制线，用来传输 PWM 信号。</p><p>那么，应该产生怎样的PMW波形来控制舵机的转动角度呢？</p><p>SG90的舵机要求<strong>控制舵机的 PWM 信号频率在50Hz左右</strong>，即周期为 20ms 的 PWM 信号，<strong>当该信号的高电平部分在0.5ms - 2.5ms之间时，对应舵机转动的角度</strong>，具体对应情况如下表：</p><table><thead><tr><th align="center">高电平脉宽</th><th align="center">舵机转动角度</th></tr></thead><tbody><tr><td align="center">0.5ms</td><td align="center">0°</td></tr><tr><td align="center">1.0ms</td><td align="center">45°</td></tr><tr><td align="center">1.5ms</td><td align="center">90°</td></tr><tr><td align="center">2.0ms</td><td align="center">135°</td></tr><tr><td align="center">2.5ms</td><td align="center">180°</td></tr></tbody></table><p>下面结合一个动图来理解：</p><p><img src="http://mculover666.cn/blog/20191205/iKyLJIGWewhP.gif" alt="图片来源八色木"></p><blockquote><p>知识小卡片结束啦！对舵机有了解了吗？</p></blockquote><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt=""></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：<br><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt="打开MCU选择器"></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:<br><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt="选择芯片"></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：</p><p><img src="http://mculover666.cn/blog/20191205/krcW6G9qAj0A.png?imageslim" alt="打开外部时钟"></p><h2 id="配置通用定时器TIM16"><a href="#配置通用定时器TIM16" class="headerlink" title="配置通用定时器TIM16"></a>配置通用定时器TIM16</h2><blockquote><p>知识小卡片——STM32L431的定时器</p></blockquote><p>STM32L431xx 系列有 1 个高级定时器（TIM1）, 3 个通用定时器（TIM2、TIM15、TIM16），两个基本定时器（TIM6、TIM7），还有两个低功耗定时器（LPTIM1、LPTIM2）。</p><p>STM32L431 的通用 TIMx (TIM2、TIM15、TIM16)定时器功能包括：</p><ul><li><p>16 位(TIM15,TIM16)/32 位(TIM2)向上、向下、向上/向下自动装载计数器，注意：<br>TIM15、TIM16 只支持向上（递增）计数方式；</p></li><li><p>16 位可编程(可以实时修改)预分频器，计数器时钟频率的分频系数为 1～65535 之间的任<br>意数值。</p></li><li><p>4 个独立通道（TIMx_CH1~4， 其中 TIM15 最多 2 个通道， TIM16 最多 1 个<br>通道），这些通道可以用来作为：</p><ul><li>输入捕获</li><li>输出比较</li><li>PWM 生成(边缘或中间对齐模式)</li><li>单脉冲模式输出</li></ul></li><li><p>可使用外部信号控制定时器和定时器互连的同步电路。</p></li><li><p>如下事件发生时产生中断/DMA：</p><ul><li>更新：计数器向上溢出/向下溢出，计数器初始化(通过软件或者内部/外部触发)</li><li>触发事件(计数器启动、停止、初始化或者由内部/外部触发计数)</li><li>输入捕获</li><li>输出比较</li></ul></li></ul><blockquote><p>知识小卡片结束啦~</p></blockquote><p>接下来开始配置TIM16定时器的PWM功能：</p><p>首先选择<code>TIM</code>，选择通道1的功能，默认的CH1是<code>PA6</code>引脚，但是开发板上是与 PB8 连接的，所以在右边将PB8配置为<code>TIM16_CH1</code>：</p><p><img src="http://mculover666.cn/image/20190807/3Ru6wXY95H7s.png?imageslim" alt="打开TIM16并选择PWM输出引脚"></p><p>接下来是对TIM16的参数设置，参照数据手册中的RCC时钟树，TIM16内部时钟来源是<code>PCLK2 = 80Mhz</code>，我们的目的是产生<code>20Hz</code>的PWM，所以预分频系数设置为<code>80-1</code>，自动重载值为<code>20000-1</code>，得到的计时器更新中断频率即为<code>80000000/80/20000 = 50 Hz</code>：</p><p><img src="http://mculover666.cn/blog/20191205/bukWGxaWdSG6.png?imageslim" alt="设置PWM输出频率"></p><p>其余的一些设置保持默认即可，最后配置PWM占空比：</p><p><img src="http://mculover666.cn/blog/20191205/JMXATy2qaXlx.png?imageslim" alt="设置PWM占空比"></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：</p><p><img src="http://mculover666.cn/image/20190806/1TQg7frjRpVr.png?imageslim" alt="设置时钟树"></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/blog/20191205/VsuAG8EIkAog.png?imageslim" alt="工程设置"></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：</p><p><img src="http://mculover666.cn/image/20190806/T6WvSK6Dfpts.png?imageslim" alt="代码生成设置"></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：</p><p><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt="生成代码"></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="启动定时器并产生PWM"><a href="#启动定时器并产生PWM" class="headerlink" title="启动定时器并产生PWM"></a>启动定时器并产生PWM</h2><p>最后在<code>main</code>函数中开启TIM2并使能其中断（TIM2初始化代码之后）：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* USER CODE BEGIN 1 */</span>  <span class="token comment" spellcheck="true">/* USER CODE END 1 */</span>  <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">MX_TIM16_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span>  <span class="token function">HAL_TIM_PWM_Start</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>htim16<span class="token punctuation">,</span>TIM_CHANNEL_1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* USER CODE END 2 */</span>  <span class="token comment" spellcheck="true">/* Infinite loop */</span>  <span class="token comment" spellcheck="true">/* USER CODE BEGIN WHILE */</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* USER CODE END WHILE */</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 3 */</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* USER CODE END 3 */</span><span class="token punctuation">}</span></code></pre><p>编译下载之后，可以看到舵机旋转到45°：</p><p><img src="http://mculover666.cn/blog/20191205/96mLb22EUSrL.png?imageslim" alt="舵机转动45°现象"></p><h2 id="动态改变舵机角度"><a href="#动态改变舵机角度" class="headerlink" title="动态改变舵机角度"></a>动态改变舵机角度</h2><p>上一个实验中，我们配置了PWM波的高电平时长计数个数为1000，即时长为1ms，对应旋转角度为45°，在本实验中，我们来动态改变 PWM 占空比，使舵机在0°到180之间来回旋转。</p><p>编写如下代码：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* USER CODE BEGIN 1 */</span>    uint16_t pluse <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* USER CODE END 1 */</span>  <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">MX_TIM16_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span>  <span class="token comment" spellcheck="true">/* USER CODE END 2 */</span>  <span class="token comment" spellcheck="true">/* Infinite loop */</span>  <span class="token comment" spellcheck="true">/* USER CODE BEGIN WHILE */</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* USER CODE END WHILE */</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 3 */</span>    <span class="token comment" spellcheck="true">//产生PWM，舵机转动</span>    <span class="token function">HAL_TIM_PWM_Start</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>htim16<span class="token punctuation">,</span>TIM_CHANNEL_1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//1s后改变舵机角度，增加45°</span>    <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pluse <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pluse <span class="token operator">==</span> <span class="token number">3000</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//如果舵机角度大于180°，回零</span>      pluse <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//设置PWM占空比</span>    <span class="token function">__HAL_TIM_SetCompare</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>htim16<span class="token punctuation">,</span> TIM_CHANNEL_1<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint16_t<span class="token punctuation">)</span>pluse<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* USER CODE END 3 */</span><span class="token punctuation">}</span></code></pre><blockquote><p>注意：STM32F1系列会报错找不到__HAL_TIM_SetCompare函数，解决方案啊：<a href="https://blog.csdn.net/Mculover666/article/details/104801386" target="_blank" rel="noopener">STM32CubeMX生成F1的工程中提示找不到 __HAL_TIM_SetCompare 问题的解决方案</a>。</p></blockquote><p>编译下载后可以看到舵机在0°-180°之间来回旋转：</p><p><img src="http://mculover666.cn/blog/20191205/ImBhKMzpWqKa.gif" alt="舵机角度动态调整效果"></p><p>至此，我们已经学会<strong>如何使用通用定时器产生PWM驱动舵机</strong>。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="公众号Mculover666"></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10沙盒开启方法</title>
      <link href="/posts/2291178417/"/>
      <url>/posts/2291178417/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows-SandBox"><a href="#Windows-SandBox" class="headerlink" title="Windows SandBox"></a>Windows SandBox</h1><p>Windows SandBox 是一个沙盒系统，可以在Windows系统下快速启动一个全新的Windows虚拟机。</p><p>Windows SandBox 有以下优势：</p><ul><li>Windows自带（专业版/企业版）</li><li>系统干净：每次启动时，系统都是全新的</li><li>启动速度快</li><li>一次性：关闭沙盒后，沙盒中的所有东西全部丢失</li><li>安全：沙盒提供了一个隔离环境，与主机分离</li></ul><p><img src="http://mculover666.cn/blog/20191126/nwG3SX5ciHhJ.png?imageslim" alt="Windows SandBox 界面"></p><h1 id="开启条件"><a href="#开启条件" class="headerlink" title="开启条件"></a>开启条件</h1><ul><li><code>Windows系统专业版/企业版</code></li></ul><p>Windows系统专业版或者企业版中自带了Windows SandBox，无需下载直接开启，家庭版也可以安装，但是需要先下载安装文件，如有需要可自行搜索。</p><p>如何查看自己系统的版本呢？右击“此电脑”，选择“属性”即可查看：</p><p><img src="http://mculover666.cn/blog/20191126/1iI9ayf0NuvK.png?imageslim" alt="查看系统版本"></p><ul><li><code>OS版本号：18301或之后</code></li></ul><p>如何查看自己系统的版本号呢？使用 <code>win+R</code>打开命令行，输入winver查看：</p><p><img src="http://mculover666.cn/blog/20191126/2mc2YdmG389Q.png?imageslim" alt="输入winver命令"></p><p><img src="http://mculover666.cn/blog/20191126/h6yKz3PN3hd4.png?imageslim" alt="查看OS版本号"></p><p>如果满足这两个条件，快来跟我一起开启沙盒体验一下吧~</p><h1 id="开启Windows-SandBox功能"><a href="#开启Windows-SandBox功能" class="headerlink" title="开启Windows SandBox功能"></a>开启Windows SandBox功能</h1><p>在搜索框搜索“启用和关闭windows功能”：</p><p><img src="http://mculover666.cn/blog/20191126/sJaC92emywWl.png?imageslim" alt="打开windows功能开启或关闭页面"></p><p>找到 “windows 沙盒”，勾选确定：</p><p><img src="http://mculover666.cn/blog/20191126/iqLwxhSeCT6p.png?imageslim" alt="开启Windows沙盒"></p><p>系统会提示重启电脑：</p><h1 id="使用-Windows-SandBox"><a href="#使用-Windows-SandBox" class="headerlink" title="使用 Windows SandBox"></a>使用 Windows SandBox</h1><p>在菜单栏选择<code>Windows SandBox</code>或者直接搜索<code>sandbox</code>，即可打开 Windows SandBox：</p><p><img src="http://mculover666.cn/blog/20191126/PnvLVugksspq.png?imageslim" alt="Windows SandBox"></p><p>启动后的界面如下：</p><p><img src="http://mculover666.cn/blog/20191126/nwG3SX5ciHhJ.png?imageslim" alt="Windows SandBox 界面"></p><p>进入Windows Sandbox，和进入主机的 Windows 系统中一样，进行软件的安装、浏览网页等等的操作。</p><h1 id="主机与SandBox之间传输文件"><a href="#主机与SandBox之间传输文件" class="headerlink" title="主机与SandBox之间传输文件"></a>主机与SandBox之间传输文件</h1><p>Windows Sandbox和真实系统<strong>共享剪贴板</strong>，用户可以通过在主机系统中复制文件，然后在Windows Sandbox中直接粘贴即可。</p><h1 id="Windows-SandBox使用注意事项"><a href="#Windows-SandBox使用注意事项" class="headerlink" title="Windows SandBox使用注意事项"></a>Windows SandBox使用注意事项</h1><ol><li>Windows SandBox比较迟内存，启动后占用内存情况如下，仅供参考：</li></ol><p><img src="http://mculover666.cn/blog/20191126/Bk6NVgJ05c6J.png?imageslim" alt="Win10 SandBox内存占用情况"></p><ol start="2"><li>Windows SandBox是一次性的，关闭之后沙盒中所有东西都会消失，注意保存！</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX-23 | 使用USART接收GPS数据并解析(L80-R)</title>
      <link href="/posts/3463670498/"/>
      <url>/posts/3463670498/</url>
      
        <content type="html"><![CDATA[<p>本篇详细的记录了如何使用STM32CubeMX配置STM32L431RCT6的 USART 外设，接收 GPS 模块的数据并解析。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：</li></ul><p><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt=""></p><ul><li>GPS模块（L80-R）<br>Quectel L80-R 是一款集成了贴片天线的紧凑型GPS模块，非常适合在物联网设备中使用，尤其适合在车载、个人跟踪、工业PDA及各种手持式设备中使用：</li></ul><p><img src="http://mculover666.cn/blog/20191031/STXCYEk4YMpO.png?imageslim" alt=""></p><p>GPS模块的原理图如下：</p><p><img src="http://mculover666.cn/blog/20191031/XiH6ImpbeBCA.png?imageslim" alt=""></p><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li><li>准备一个串口调试助手，这里我使用的是<code>Serial Port Utility</code>；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt=""></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：<br><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt=""></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:<br><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt=""></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：<br><img src="http://mculover666.cn/image/20190806/k593lGGb5tlW.png?imageslim" alt=""></p><h2 id="配置GPS使能引脚"><a href="#配置GPS使能引脚" class="headerlink" title="配置GPS使能引脚"></a>配置GPS使能引脚</h2><p>小熊派开发板设置了一个使能引脚，用于控制GPS模块的电源：</p><p><img src="http://mculover666.cn/blog/20191031/Lsu2Fdp80u0U.png?imageslim" alt=""></p><p>所以要配置这个使能引脚（PC9）：</p><p><img src="http://mculover666.cn/blog/20191031/HOdzkKcfGbgs.png?imageslim" alt=""></p><h2 id="配置调试串口"><a href="#配置调试串口" class="headerlink" title="配置调试串口"></a>配置调试串口</h2><p>小熊派开发板板载ST-Link并且虚拟了一个串口，原理图如下：</p><p><img src="http://mculover666.cn/image/20190814/IwyXONVefPx9.png?imageslim" alt=""></p><p>这里我将开关拨到<code>AT-MCU</code>模式，使PC的串口与USART1之间连接。</p><p>接下来开始配置<code>USART1</code>：</p><p><img src="http://mculover666.cn/image/20190814/nLMRMYtmzghl.png?imageslim" alt=""></p><h2 id="配置GPS模块通信串口"><a href="#配置GPS模块通信串口" class="headerlink" title="配置GPS模块通信串口"></a>配置GPS模块通信串口</h2><p>GPS模块与USART3串口相连接，接下来开始配置USART3，波特率9600：</p><p><img src="http://mculover666.cn/blog/20191031/1b5EMIvH7vLK.png?imageslim" alt=""></p><h2 id="NVIC配置"><a href="#NVIC配置" class="headerlink" title="NVIC配置"></a>NVIC配置</h2><p>配置 USART3 的中断优先级，首先选择一个中断优先级分组：</p><p><img src="http://mculover666.cn/blog/20191031/8x88G2Sa6bLo.png?imageslim" alt=""></p><p>然后设置优先级：</p><p><img src="http://mculover666.cn/blog/20191031/M8cHst9XdVHJ.png?imageslim" alt=""></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：<br><img src="http://mculover666.cn/image/20190806/1TQg7frjRpVr.png?imageslim" alt=""></p><p><img src="http://mculover666.cn/image/20190808/EVKCwrQNEWcl.png?imageslim" alt=""></p><p><img src="http://mculover666.cn/image/20190806/Dje8nuTMdpQY.png?imageslim" alt=""></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/blog/20191031/f6F3UpBjP0kM.png?imageslim" alt=""></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：</p><p><img src="http://mculover666.cn/image/20190806/T6WvSK6Dfpts.png?imageslim" alt=""></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：</p><p><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt=""></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="重定向printf-函数"><a href="#重定向printf-函数" class="headerlink" title="重定向printf( )函数"></a>重定向printf( )函数</h2><p>参考：<a href="http://www.mculover666.cn/posts/2251182441/">【STM32Cube_09】重定向printf函数到串口输出的多种方法</a>。</p><h2 id="转发GPS模块的数据"><a href="#转发GPS模块的数据" class="headerlink" title="转发GPS模块的数据"></a>转发GPS模块的数据</h2><p>GPS 使能后不断的接收信号定位，并输出数据，但是 GPS 模块与 USART3 连接，无法直接查看输出的数据，何谈解析，所以先将 USART3 接收到的数据使用 USART1 发送，在电脑上使用串口助手查看，如果对于USART的中断接收方式还不明白，可以查看这篇文章：<a href="http://www.mculover666.cn/posts/1803605667/">【STM32Cube_07】使用USART发送和接收数据（中断模式）</a>。</p><p>首先在 <code>main.c</code> 中实现 USART3 接收中断的回调函数：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* USER CODE BEGIN 4 */</span><span class="token comment" spellcheck="true">/* 中断回调函数 */</span><span class="token keyword">void</span> <span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> uint8_t ch<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 判断是哪个串口触发的中断 */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>huart <span class="token operator">-></span>Instance <span class="token operator">==</span> USART3<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//将接收到的数据发送</span>        <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ch<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0Xffff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//重新使能串口接收中断</span>        <span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ch<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* USER CODE END 4 */</span></code></pre><p>然后修改<code>main</code>函数如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Initialize all configured peripherals */</span>    <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_USART3_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span>    <span class="token comment" spellcheck="true">/* 使能USART3接收中断 */</span>    <span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart3<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint8_t<span class="token operator">*</span><span class="token punctuation">)</span>gps_uart<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 使能GPS模块 */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"L80-R GPS Module test...\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">HAL_GPIO_WritePin</span><span class="token punctuation">(</span>GPS_EN_GPIO_Port<span class="token punctuation">,</span>GPS_EN_Pin<span class="token punctuation">,</span> GPIO_PIN_RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"GPE Enable ok.\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* USER CODE END 2 */</span>  <span class="token comment" spellcheck="true">/* Infinite loop */</span>  <span class="token comment" spellcheck="true">/* USER CODE BEGIN WHILE */</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* USER CODE END WHILE */</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 3 */</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* USER CODE END 3 */</span><span class="token punctuation">}</span></code></pre><p>编译下载，可以在串口助手上看到输出的数据：</p><p>刚上电时蓝色的LED灯保持常亮状态，表示未定位成功，数据如下：</p><p><img src="http://mculover666.cn/blog/20191031/4amfHyTh318C.png?imageslim" alt=""></p><p>定位成功后蓝色的LED开始闪烁，数据如下：</p><p><img src="http://mculover666.cn/blog/20191031/1TkQ75Is66J0.png?imageslim" alt=""></p><h2 id="解析GPS的数据"><a href="#解析GPS的数据" class="headerlink" title="解析GPS的数据"></a>解析GPS的数据</h2><p>将GPS数据转发取消，删除USART3添加的中断函数：</p><p><img src="http://mculover666.cn/blog/20191101/vh0Dfo3ks0il.png?imageslim" alt=""></p><p>接下来开辟一块缓冲区，来存放接收的GPS数据，并且定义GPS数据结构体，用来存放解析GPS数据得到的经纬度信息：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Private variables ---------------------------------------------------------*/</span><span class="token comment" spellcheck="true">/* USER CODE BEGIN PV */</span><span class="token comment" spellcheck="true">/***************************************************\*GPS NMEA-0183协议重要参数结构体定义*卫星信息\***************************************************/</span>__packed <span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    uint32_t latitude_bd<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//纬度   分扩大100000倍，实际要除以100000</span>    uint8_t nshemi_bd<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//北纬/南纬,N:北纬;S:南纬    </span>    uint32_t longitude_bd<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//经度 分扩大100000倍,实际要除以100000</span>    uint8_t ewhemi_bd<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//东经/西经,E:东经;W:西经</span><span class="token punctuation">}</span>gps_msg<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* E53_ST1传感器数据类型定义 ------------------------------------------------------------*/</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>        <span class="token keyword">float</span>    Longitude<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//经度</span>        <span class="token keyword">float</span>    Latitude<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//纬度</span><span class="token punctuation">}</span> E53_ST1_Data_TypeDef<span class="token punctuation">;</span>gps_msg              gpsmsg<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> gps_uart<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>E53_ST1_Data_TypeDef E53_ST1_Data<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* USER CODE END PV */</span></code></pre><p>然后编写解析GPS数据的函数，先要在开头加上头文件支持：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Private includes ----------------------------------------------------------*/</span><span class="token comment" spellcheck="true">/* USER CODE BEGIN Includes */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token comment" spellcheck="true">/* USER CODE END Includes */</span></code></pre><p>开始编写解析GPS数据所使用的函数：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* USER CODE BEGIN 4 */</span><span class="token comment" spellcheck="true">/***************************************************\* 函数名称: NMEA_Comma_Pos*    函数功能：从buf里面得到第cx个逗号所在的位置*    输入值：*    返回值：0~0xFE，代表逗号所在位置的便宜*                     0xFF，代表不存在第cx个逗号\***************************************************/</span>uint8_t <span class="token function">NMEA_Comma_Pos</span><span class="token punctuation">(</span>uint8_t <span class="token operator">*</span>buf<span class="token punctuation">,</span>uint8_t cx<span class="token punctuation">)</span><span class="token punctuation">{</span>    uint8_t <span class="token operator">*</span>p <span class="token operator">=</span> buf<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token operator">==</span><span class="token string">'*'</span><span class="token operator">||</span><span class="token operator">*</span>buf<span class="token operator">&lt;</span><span class="token string">' '</span><span class="token operator">||</span><span class="token operator">*</span>buf<span class="token operator">></span><span class="token string">'z'</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0xFF</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token operator">==</span><span class="token string">','</span><span class="token punctuation">)</span>cx<span class="token operator">--</span><span class="token punctuation">;</span>        buf<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> buf<span class="token operator">-</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/***************************************************\* 函数名称: NMEA_Pow*    函数功能：返回m的n次方值*    输入值：底数m和指数n*    返回值：m^n\***************************************************/</span>uint32_t <span class="token function">NMEA_Pow</span><span class="token punctuation">(</span>uint8_t m<span class="token punctuation">,</span>uint8_t n<span class="token punctuation">)</span><span class="token punctuation">{</span>    uint32_t result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span>result <span class="token operator">*</span><span class="token operator">=</span> m<span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/***************************************************\* 函数名称: NMEA_Str2num*    函数功能：str数字转换为（int）数字，以','或者'*'结束*    输入值：buf，数字存储区*                     dx，小数点位数，返回给调用函数*    返回值：转换后的数值\***************************************************/</span><span class="token keyword">int</span> <span class="token function">NMEA_Str2num</span><span class="token punctuation">(</span>uint8_t <span class="token operator">*</span>buf<span class="token punctuation">,</span>uint8_t<span class="token operator">*</span>dx<span class="token punctuation">)</span><span class="token punctuation">{</span>    uint8_t <span class="token operator">*</span>p <span class="token operator">=</span> buf<span class="token punctuation">;</span>    uint32_t ires <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>fres <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    uint8_t ilen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>flen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>i<span class="token punctuation">;</span>    uint8_t mask <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> res<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token operator">==</span><span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>mask <span class="token operator">|</span><span class="token operator">=</span> <span class="token number">0x02</span><span class="token punctuation">;</span>p<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//说明有负数</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token operator">==</span><span class="token string">','</span><span class="token operator">||</span><span class="token operator">*</span>p<span class="token operator">==</span><span class="token string">'*'</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//遇到结束符</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token operator">==</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>mask <span class="token operator">|</span><span class="token operator">=</span> <span class="token number">0x01</span><span class="token punctuation">;</span>p<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//遇到小数点</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token operator">></span><span class="token string">'9'</span><span class="token operator">||</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token operator">&lt;</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//数字不在0和9之内，说明有非法字符</span>        <span class="token punctuation">{</span>            ilen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            flen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>mask<span class="token operator">&amp;</span><span class="token number">0x01</span><span class="token punctuation">)</span>flen<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//小数点的位数</span>        <span class="token keyword">else</span> ilen<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//str长度加一</span>        p<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下一个字符</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>mask<span class="token operator">&amp;</span><span class="token number">0x02</span><span class="token punctuation">)</span>buf<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//移到下一位，除去负号</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ilen<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//得到整数部分数据</span>    <span class="token punctuation">{</span>        ires <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">NMEA_Pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>ilen<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>flen<span class="token operator">></span><span class="token number">5</span><span class="token punctuation">)</span>flen<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最多取五位小数</span>    <span class="token operator">*</span>dx <span class="token operator">=</span> flen<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>flen<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//得到小数部分数据</span>    <span class="token punctuation">{</span>        fres <span class="token operator">+</span><span class="token operator">=</span><span class="token function">NMEA_Pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>flen<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span>ilen<span class="token operator">+</span><span class="token number">1</span><span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    res <span class="token operator">=</span> ires<span class="token operator">*</span><span class="token function">NMEA_Pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>flen<span class="token punctuation">)</span><span class="token operator">+</span>fres<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>mask<span class="token operator">&amp;</span><span class="token number">0x02</span><span class="token punctuation">)</span>res <span class="token operator">=</span> <span class="token operator">-</span>res<span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/***************************************************\* 函数名称: NMEA_BDS_GPRMC_Analysis*    函数功能：解析GPRMC信息*    输入值：gpsx,NMEA信息结构体*                 buf：接收到的GPS数据缓冲区首地址\***************************************************/</span><span class="token keyword">void</span> <span class="token function">NMEA_BDS_GPRMC_Analysis</span><span class="token punctuation">(</span>gps_msg <span class="token operator">*</span>gpsmsg<span class="token punctuation">,</span>uint8_t <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">{</span>    uint8_t <span class="token operator">*</span>p4<span class="token punctuation">,</span>dx<span class="token punctuation">;</span>                 uint8_t posx<span class="token punctuation">;</span>         uint32_t temp<span class="token punctuation">;</span>           <span class="token keyword">float</span> rs<span class="token punctuation">;</span>      p4<span class="token operator">=</span><span class="token punctuation">(</span>uint8_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">strstr</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>buf<span class="token punctuation">,</span><span class="token string">"$GPRMC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//"$GPRMC",经常有&amp;和GPRMC分开的情况,故只判断GPRMC.</span>    posx<span class="token operator">=</span><span class="token function">NMEA_Comma_Pos</span><span class="token punctuation">(</span>p4<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">//得到纬度</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>posx<span class="token operator">!=</span><span class="token number">0XFF</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        temp<span class="token operator">=</span><span class="token function">NMEA_Str2num</span><span class="token punctuation">(</span>p4<span class="token operator">+</span>posx<span class="token punctuation">,</span><span class="token operator">&amp;</span>dx<span class="token punctuation">)</span><span class="token punctuation">;</span>                      gpsmsg<span class="token operator">-></span>latitude_bd<span class="token operator">=</span>temp<span class="token operator">/</span><span class="token function">NMEA_Pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>dx<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//得到°</span>        rs<span class="token operator">=</span>temp<span class="token operator">%</span><span class="token function">NMEA_Pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>dx<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//得到'         </span>        gpsmsg<span class="token operator">-></span>latitude_bd<span class="token operator">=</span>gpsmsg<span class="token operator">-></span>latitude_bd<span class="token operator">*</span><span class="token function">NMEA_Pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>rs<span class="token operator">*</span><span class="token function">NMEA_Pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token operator">-</span>dx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">60</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//转换为° </span>    <span class="token punctuation">}</span>    posx<span class="token operator">=</span><span class="token function">NMEA_Comma_Pos</span><span class="token punctuation">(</span>p4<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">//南纬还是北纬 </span>    <span class="token keyword">if</span><span class="token punctuation">(</span>posx<span class="token operator">!=</span><span class="token number">0XFF</span><span class="token punctuation">)</span>gpsmsg<span class="token operator">-></span>nshemi_bd<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span>p4<span class="token operator">+</span>posx<span class="token punctuation">)</span><span class="token punctuation">;</span>                          posx<span class="token operator">=</span><span class="token function">NMEA_Comma_Pos</span><span class="token punctuation">(</span>p4<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">//得到经度</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>posx<span class="token operator">!=</span><span class="token number">0XFF</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>                                                          temp<span class="token operator">=</span><span class="token function">NMEA_Str2num</span><span class="token punctuation">(</span>p4<span class="token operator">+</span>posx<span class="token punctuation">,</span><span class="token operator">&amp;</span>dx<span class="token punctuation">)</span><span class="token punctuation">;</span>                      gpsmsg<span class="token operator">-></span>longitude_bd<span class="token operator">=</span>temp<span class="token operator">/</span><span class="token function">NMEA_Pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>dx<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//得到°</span>        rs<span class="token operator">=</span>temp<span class="token operator">%</span><span class="token function">NMEA_Pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>dx<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//得到'         </span>        gpsmsg<span class="token operator">-></span>longitude_bd<span class="token operator">=</span>gpsmsg<span class="token operator">-></span>longitude_bd<span class="token operator">*</span><span class="token function">NMEA_Pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>rs<span class="token operator">*</span><span class="token function">NMEA_Pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token operator">-</span>dx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">60</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//转换为° </span>    <span class="token punctuation">}</span>    posx<span class="token operator">=</span><span class="token function">NMEA_Comma_Pos</span><span class="token punctuation">(</span>p4<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">//东经还是西经</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>posx<span class="token operator">!=</span><span class="token number">0XFF</span><span class="token punctuation">)</span>gpsmsg<span class="token operator">-></span>ewhemi_bd<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span>p4<span class="token operator">+</span>posx<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* USER CODE END 4 */</span></code></pre><p>最后编写使用中断方式接收数据到缓冲区，然后调用GPS数据解析函数的函数：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">E53_ST1_Read_Data</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/* 使用中断方式接收一次数据 */</span>    <span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart3<span class="token punctuation">,</span>gps_uart<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 分析缓冲区的字符串，解析GPS数据 */</span>    <span class="token function">NMEA_BDS_GPRMC_Analysis</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gpsmsg<span class="token punctuation">,</span><span class="token punctuation">(</span>uint8_t<span class="token operator">*</span><span class="token punctuation">)</span>gps_uart<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 将解析到的经纬度数据存放到结构体中，便于其他函数使用 */</span>        E53_ST1_Data<span class="token punctuation">.</span>Longitude<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>gpsmsg<span class="token punctuation">.</span>longitude_bd<span class="token operator">/</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        E53_ST1_Data<span class="token punctuation">.</span>Latitude<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>gpsmsg<span class="token punctuation">.</span>latitude_bd<span class="token operator">/</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>当然，别忘了在 <code>main</code> 函数之前声明这些函数：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Private user code ---------------------------------------------------------*/</span><span class="token comment" spellcheck="true">/* USER CODE BEGIN 0 */</span>uint8_t <span class="token function">NMEA_Comma_Pos</span><span class="token punctuation">(</span>uint8_t <span class="token operator">*</span>buf<span class="token punctuation">,</span>uint8_t cx<span class="token punctuation">)</span><span class="token punctuation">;</span>uint32_t <span class="token function">NMEA_Pow</span><span class="token punctuation">(</span>uint8_t m<span class="token punctuation">,</span>uint8_t n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">NMEA_Str2num</span><span class="token punctuation">(</span>uint8_t <span class="token operator">*</span>buf<span class="token punctuation">,</span>uint8_t<span class="token operator">*</span>dx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">NMEA_BDS_GPRMC_Analysis</span><span class="token punctuation">(</span>gps_msg <span class="token operator">*</span>gpsmsg<span class="token punctuation">,</span>uint8_t <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">E53_ST1_Read_Data</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* USER CODE END 0 */</span></code></pre><p>大功告成，在main函数中调用：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* Initialize all configured peripherals */</span>  <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">MX_USART3_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span>  <span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart3<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint8_t<span class="token operator">*</span><span class="token punctuation">)</span>gps_uart<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"L80-R GPS Module test...\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 使能GPS模块 */</span>  <span class="token function">HAL_GPIO_WritePin</span><span class="token punctuation">(</span>GPS_EN_GPIO_Port<span class="token punctuation">,</span>GPS_EN_Pin<span class="token punctuation">,</span> GPIO_PIN_RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"GPE Enable ok.\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* USER CODE END 2 */</span>  <span class="token comment" spellcheck="true">/* Infinite loop */</span>  <span class="token comment" spellcheck="true">/* USER CODE BEGIN WHILE */</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* USER CODE END WHILE */</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 3 */</span>    <span class="token function">E53_ST1_Read_Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Longitude: %f, Latitude: %f.\r\n"</span><span class="token punctuation">,</span> E53_ST1_Data<span class="token punctuation">.</span>Longitude<span class="token punctuation">,</span> E53_ST1_Data<span class="token punctuation">.</span>Latitude<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* USER CODE END 3 */</span><span class="token punctuation">}</span></code></pre><h2 id="实验现象"><a href="#实验现象" class="headerlink" title="实验现象"></a>实验现象</h2><p>编译下载后，<strong>尽量将小熊派开发板放在窗户边</strong>，等待定位成功，串口输出数据如下：</p><p><img src="http://mculover666.cn/blog/20191101/ere3mnVix0io.png?imageslim" alt=""></p><p>定位成功后，定位数据如下：</p><p><img src="http://mculover666.cn/blog/20191101/PdwjPdmndKB8.png?imageslim" alt=""></p><h2 id="查看定位"><a href="#查看定位" class="headerlink" title="查看定位"></a>查看定位</h2><p>有了GPS定位数据之后，可以在地图上查看具体的位置，也可以上传到华为云IoT平台查看，这里我使用 GPS经纬度查询工具进行查看：</p><blockquote><p>工具链接：<a href="http://www.gpsspg.com/maps.htm" target="_blank" rel="noopener">http://www.gpsspg.com/maps.htm</a></p></blockquote><p><img src="http://mculover666.cn/blog/20191101/ut7W41Mz90sV.png?imageslim" alt=""></p><p>至此，我们已经学会<strong>如何接收GPS数据并解析出经纬度</strong>。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX-22 | 在SD卡上移植FATFS文件系统</title>
      <link href="/posts/2214138023/"/>
      <url>/posts/2214138023/</url>
      
        <content type="html"><![CDATA[<p>本篇详细的记录了如何使用STM32CubeMX移植FATFS文件系统到SD卡上。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：</li></ul><p><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt=""></p><ul><li>Micro SD卡<br>小熊派开发板板载 Micro SD 卡槽，需要提前自行准备一张 Micro SD卡，如图：</li></ul><p><img src="http://mculover666.cn/image/20190903/CgHfN2loFYyx.png?imageslim" alt=""></p><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li><li>准备一个串口调试助手，这里我使用的是<code>Serial Port Utility</code>；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt=""></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：<br><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt=""></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:<br><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt=""></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：</p><p><img src="http://mculover666.cn/image/20190829/dBG4s5JFoXGM.png?imageslim" alt=""></p><h2 id="配置串口"><a href="#配置串口" class="headerlink" title="配置串口"></a>配置串口</h2><p>小熊派开发板板载ST-Link并且虚拟了一个串口，原理图如下：</p><p><img src="http://mculover666.cn/image/20190814/IwyXONVefPx9.png?imageslim" alt=""></p><p>这里我将开关拨到<code>AT-MCU</code>模式，使PC的串口与USART1之间连接。</p><p>接下来开始配置<code>USART1</code>：</p><p><img src="http://mculover666.cn/image/20190814/nLMRMYtmzghl.png?imageslim" alt=""></p><h2 id="配置-SDMMC-接口"><a href="#配置-SDMMC-接口" class="headerlink" title="配置 SDMMC 接口"></a>配置 SDMMC 接口</h2><blockquote><p>知识小卡片 —— SDMMC接口</p></blockquote><p>SDMMC接口的全称叫<code>SD/SDIO MMC card host interface</code>，SD/SDIO MMC 卡 主机接口，通俗的来说，就是这个接口支持SD卡，支持SDIO设备，支持MMC卡。</p><blockquote><p>知识小卡片结束啦~</p></blockquote><p>首先查看小熊派开发板的原理图：</p><p><img src="http://mculover666.cn/image/20190903/5p7dMFxj3rSE.png?imageslim" alt=""></p><p>然后根据原理图配置 SDMMC 接口：</p><p><img src="http://mculover666.cn/image/20190902/uMcmVYpIsIcy.png?imageslim" alt=""></p><h2 id="配置FATFS文件系统"><a href="#配置FATFS文件系统" class="headerlink" title="配置FATFS文件系统"></a>配置FATFS文件系统</h2><p>使用STM32CubeMX配置FATFS文件系统非常方便，只需要在软件中开启即可，软件会自动帮我们移植好。</p><p>这里需要修改两个配置：</p><ul><li>开启文件名支持简体中文；</li><li>开启长文件名支持，并将长文件名动态缓存在栈中（普通文件名最多8个字节，开启长文件名支持后可达255个字节）</li></ul><p><img src="http://mculover666.cn/blog/20191022/P5AzTDIfJnIS.png?imageslim" alt=""></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：</p><p><img src="http://mculover666.cn/image/20190902/Bp7T9w424Prq.png?imageslim" alt=""></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p>因为之前开启FATFS选择了长文件名动态缓存在栈中，所以我们要将栈空间修改大一点：</p><p><img src="http://mculover666.cn/blog/20191022/IqNwGwcesMXv.png?imageslim" alt=""></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：</p><p><img src="http://mculover666.cn/image/20190806/T6WvSK6Dfpts.png?imageslim" alt=""></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：</p><p><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt=""></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="重定向printf-函数"><a href="#重定向printf-函数" class="headerlink" title="重定向printf( )函数"></a>重定向printf( )函数</h2><p>参考：<a href="https://www.mculover666.cn/2019/07/30/STM32Cube/【STM32Cube-09】重定向printf函数到串口输出的多种方法/">【STM32Cube_09】重定向printf函数到串口输出的多种方法</a>。</p><h2 id="SD卡分区并格式化为FAT文件系统"><a href="#SD卡分区并格式化为FAT文件系统" class="headerlink" title="SD卡分区并格式化为FAT文件系统"></a>SD卡分区并格式化为FAT文件系统</h2><blockquote><p>正常SD卡不需要该步骤！</p></blockquote><p>如果已经使用SD卡进行了裸机读写SD卡的实验（<a href="https://www.mculover666.cn/posts/3022954032/">【STM32Cube-19】使用SDMMC接口读写SD卡数据</a>），那么需要注意：该实验中读写的是0扇区，实验之后<strong>已经破坏了SD卡的分区表和FAT文件系统信息</strong>！</p><p>重新建立SD卡的分区表和FAT文件系统有两种方法：</p><ul><li>使用FATFS提供的API</li><li>在PC上直接格式化</li><li>在PC上使用<code>DiskGenius</code>软件重新分区和格式化</li></ul><p>这里我使用第二种方法，比较简单方便，如果对FATFS提供的API感兴趣，请前去FATFS官网查看：</p><p>首先使用读卡器将SD卡插到电脑上，会显示如下：</p><p><img src="http://mculover666.cn/blog/20191022/M3apb1xdgjSJ.png?imageslim" alt=""></p><p>然后直接右键选择格式化：</p><p><img src="http://mculover666.cn/blog/20191022/tMwv1QRhKWkN.png?imageslim" alt=""></p><p>如果第二种方法没用的话，可以使用第三种方法，来打开 <code>DiskGenius</code> 软件查看SD卡：</p><p><img src="http://mculover666.cn/blog/20191022/10vaq858v4oe.png?imageslim" alt=""></p><p>重新建立分区表并格式化：</p><p><img src="http://mculover666.cn/blog/20191022/adQLdhB2DX44.png?imageslim" alt=""></p><p><img src="http://mculover666.cn/blog/20191022/KmTfhw3FGdUT.png?imageslim" alt=""></p><p><img src="http://mculover666.cn/blog/20191022/zsb1s4h0dtE8.png?imageslim" alt=""></p><p>之后可以看到SD卡恢复正常，可以进行FATFS实验啦：</p><p><img src="http://mculover666.cn/blog/20191022/4h4Nhsweutwt.png?imageslim" alt=""></p><h2 id="使用FATFS挂载SD卡"><a href="#使用FATFS挂载SD卡" class="headerlink" title="使用FATFS挂载SD卡"></a>使用FATFS挂载SD卡</h2><blockquote><p>注意：在挂载之前必须要保证SD卡正常拥有FAT文件系统。</p></blockquote><p>挂载文件系统使用<code>f_mount</code> API，该API将文件系统对象注册/注销到FatFs模块，API原型如下：</p><pre class=" language-c"><code class="language-c">FRESULT <span class="token function">f_mount</span> <span class="token punctuation">(</span>  FATFS<span class="token operator">*</span>       fs<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* [IN] Filesystem object */</span>  <span class="token keyword">const</span> TCHAR<span class="token operator">*</span> path<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">/* [IN] Logical drive number */</span>  BYTE         opt    <span class="token comment" spellcheck="true">/* [IN] Initialization option */</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在main.c文件中添加如下代码，先定义FATFS所使用的一些全局变量：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Private variables ---------------------------------------------------------*/</span><span class="token comment" spellcheck="true">/* USER CODE BEGIN PV */</span>FATFS   fs<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* FATFS 文件系统对象 */</span>FRESULT fr<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* FATFS API 返回值 */</span><span class="token comment" spellcheck="true">/* USER CODE END PV */</span></code></pre><p>然后在 main 函数中,while(1)之前添加如下代码：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"FATFS test...\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 挂载SD卡 */</span>fr <span class="token operator">=</span> <span class="token function">f_mount</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fs<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>fr <span class="token operator">==</span> FR_OK<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"SD card mount ok!\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"SD card mount error, error code:%d.\r\n"</span><span class="token punctuation">,</span>fr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* USER CODE END 2 */</span></code></pre><p>编译下载，运行结果如下：</p><p><img src="http://mculover666.cn/blog/20191022/sVUKbrsxp6Hc.png?imageslim" alt=""></p><h2 id="创建文件并向文件中写入内容"><a href="#创建文件并向文件中写入内容" class="headerlink" title="创建文件并向文件中写入内容"></a>创建文件并向文件中写入内容</h2><p>要想操作文件，需要先创建文件对象：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* USER CODE BEGIN PV */</span>FATFS   fs<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* FATFS 文件系统对象 */</span>FRESULT fr<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* FATFS API 返回值 */</span>FIL     fd<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* FATFS 文件对象    */</span><span class="token comment" spellcheck="true">/* USER CODE END 2 */</span></code></pre><p>在main函数中的开始定义要写入文件的内容：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* USER CODE BEGIN 1 */</span><span class="token comment" spellcheck="true">//要操作的文件名</span><span class="token keyword">char</span> filename<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"test.txt"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//文件写入内容</span>uint8_t write_dat<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello,FATFS!\n"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用于接收API返回写入成功的字节数</span>uint16_t write_num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* USER CODE END 1 */</span></code></pre><p>然后<strong>在挂载操作成功之后</strong>进行<code>打开-&gt;写入-&gt;关闭</code>一个完整的操作：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 打开文件（若文件不存在则创建） */</span>fr <span class="token operator">=</span> <span class="token function">f_open</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fd<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> FA_CREATE_ALWAYS <span class="token operator">|</span> FA_WRITE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>fr <span class="token operator">==</span> FR_OK<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"open file \"%s\" ok! \r\n"</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"open file \"%s\" error : %d\r\n"</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> fr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 向打开的文件中写入内容 */</span>fr <span class="token operator">=</span> <span class="token function">f_write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fd<span class="token punctuation">,</span> write_dat<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>write_dat<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>write_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>fr <span class="token operator">==</span> FR_OK<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"write %d dat to file \"%s\" ok,dat is \"%s\".\r\n"</span><span class="token punctuation">,</span> write_num<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> write_dat<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"write dat to file \"%s\" error,error code is:%d\r\n"</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> fr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 操作完成，关闭文件 */</span>fr <span class="token operator">=</span> <span class="token function">f_close</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>fr <span class="token operator">==</span> FR_OK<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"close file \"%s\" ok!\r\n"</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"close file \"%s\" error, error code is:%d.\r\n"</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> fr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>实验结果如下：</p><p><img src="http://mculover666.cn/blog/20191022/4fevYJlQoYwc.png?imageslim" alt=""></p><p>再将SD卡插到电脑，可以看到文件及其内容：</p><p><img src="http://mculover666.cn/blog/20191022/peWQKMqHHJv8.png?imageslim" alt=""></p><h2 id="读取SD卡中的文件内容"><a href="#读取SD卡中的文件内容" class="headerlink" title="读取SD卡中的文件内容"></a>读取SD卡中的文件内容</h2><p>同样的，先在main函数开始开辟一块缓冲区，用于存放读取的数据：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* USER CODE BEGIN 1 */</span><span class="token comment" spellcheck="true">//要操作的文件名</span><span class="token keyword">char</span> filename<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"test.txt"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//文件写入内容</span>uint8_t write_dat<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello,FATFS!"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用于接收API返回写入成功的字节数</span>uint16_t write_num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用于存放从文件中读取出的内容</span>uint8_t read_dat<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用于接收API返回成功读取的字节数</span>uint16_t read_num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* USER CODE END 1 */</span></code></pre><p>然后进行<code>打开-&gt;读取-&gt;关闭</code>一个完整的操作：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 打开文件用于读取 */</span>fr <span class="token operator">=</span> <span class="token function">f_open</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fd<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> FA_READ<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>fr <span class="token operator">==</span> FR_OK<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"open file \"%s\" ok! \r\n"</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"open file \"%s\" error : %d\r\n"</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> fr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 从打开的文件中读取内容 */</span>fr <span class="token operator">=</span> <span class="token function">f_read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fd<span class="token punctuation">,</span> read_dat<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>read_dat<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>read_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>fr <span class="token operator">==</span> FR_OK<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read %d dat to file \"%s\" ok,dat is \"%s\".\r\n"</span><span class="token punctuation">,</span> read_num<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> read_dat<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read dat to file \"%s\" error,error code is:%d\r\n"</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> fr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 操作完成，关闭文件 */</span>fr <span class="token operator">=</span> <span class="token function">f_close</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>fr <span class="token operator">==</span> FR_OK<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"close file \"%s\" ok!\r\n"</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"close file \"%s\" error, error code is:%d.\r\n"</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> fr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>实验现象如下：</p><p><img src="http://mculover666.cn/blog/20191022/AJ4liJi5FLkW.png?imageslim" alt=""></p><h2 id="FATFS-API-错误码的使用"><a href="#FATFS-API-错误码的使用" class="headerlink" title="FATFS API 错误码的使用"></a>FATFS API 错误码的使用</h2><p>不知道大家有没有注意到，在本文中所有使用FATFS API的时候，都是如下的格式：</p><ul><li>使用<code>FRESULT</code>类型的变量fr接收API返回值</li><li>API执行之后进行判断，错误的话输出错误码</li></ul><p>那么，API 所返回的错误码，有什么用呢？下面用一个实例来给大家演示一下~</p><p>假如本文中的实验现象如下：</p><p><img src="http://mculover666.cn/blog/20191022/myqAnyjE4EFG.png?imageslim" alt=""></p><p>可以看到，FATFS创建文件时，返回的错误码是13，那么如何定位该问题呢？<code>13</code>代表什么？</p><p>打开FATFS的<code>ff.h</code>文件即可看到所有错误码所表示的含义：</p><p><img src="http://mculover666.cn/blog/20191022/ii3BbPouSbzf.png?imageslim" alt=""></p><p>这样问题就定位到了，<strong>我们使用的SD卡是之前用于裸机实验的卡，SD卡分区被破坏，SD卡文件系统被破坏，所以FATFS创建文件时才会提示<code>FR_NO_FILESYSTEM</code>问题</strong>。</p><p>至此，我们已经学会如何在SD卡上移植​FATFS文件系统。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX-21 | 使用ADC读取电压值</title>
      <link href="/posts/862377868/"/>
      <url>/posts/862377868/</url>
      
        <content type="html"><![CDATA[<p>本篇详细的记录了如何使用STM32CubeMX配置STM32L431RCT6的ADC外设，读取DAC输出引脚的电压值。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：<br><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt=""></li></ul><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li><li>准备一个串口调试助手，这里我使用的是<code>Serial Port Utility</code>；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt=""></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：<br><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt=""></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:<br><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt=""></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：<br><img src="http://mculover666.cn/image/20190806/k593lGGb5tlW.png?imageslim" alt=""></p><h2 id="配置串口"><a href="#配置串口" class="headerlink" title="配置串口"></a>配置串口</h2><p>小熊派开发板板载ST-Link并且虚拟了一个串口，原理图如下：</p><p><img src="http://mculover666.cn/image/20190814/IwyXONVefPx9.png?imageslim" alt=""></p><p>这里我将开关拨到<code>AT-MCU</code>模式，使PC的串口与USART1之间连接。</p><p>接下来开始配置<code>USART1</code>：</p><p><img src="http://mculover666.cn/image/20190814/nLMRMYtmzghl.png?imageslim" alt=""></p><h2 id="配置DAC"><a href="#配置DAC" class="headerlink" title="配置DAC"></a>配置DAC</h2><h3 id="确定DAC输出通道"><a href="#确定DAC输出通道" class="headerlink" title="确定DAC输出通道"></a>确定DAC输出通道</h3><p>查看小熊派E53接口的原理图：</p><p><img src="http://mculover666.cn/blog/20191016/QlodtDUnaD4B.png?imageslim" alt=""></p><h3 id="配置DAC-1"><a href="#配置DAC-1" class="headerlink" title="配置DAC"></a>配置DAC</h3><p>选择<code>DAC1</code>，开启输出通道2，配置保持默认即可：</p><p><img src="http://mculover666.cn/blog/20191016/hSKFOGJtERVf.png?imageslim" alt=""></p><h2 id="配置ADC"><a href="#配置ADC" class="headerlink" title="配置ADC"></a>配置ADC</h2><blockquote><p>知识小卡片 —— ADC</p></blockquote><p>ADC全称 Analog-to-Digital Converter，即模拟-数字转换器，可以将连续变化的模拟信号转换为离散的数字信号，进而使用数字电路进行处理，称之为数字信号处理。</p><p>STM32L431xx 系列有 1 个 ADC，ADC 分辨率高达 12 位，每个 ADC 具有多达 20 个的采集<br>通道，这些通道的 A/D 转换可以单次、连续、扫描或间断模式执行。 ADC 的结果可以左对齐<br>或右对齐方式存储在 16 位数据寄存器中。</p><p>STM32L431 的 ADC 最大的转换速率为 5.33Mhz，也就是转换时间为 0.188us（12 位分辨率<br>时），ADC 的转换时间与 AHB 总线时钟频率无关。</p><blockquote><p>知识小卡片结束啦~对ADC有没有了解呢？</p></blockquote><h3 id="确定ADC通道"><a href="#确定ADC通道" class="headerlink" title="确定ADC通道"></a>确定ADC通道</h3><p>查看小熊派E53接口的原理图：<br><img src="http://mculover666.cn/image/20190806/whMjICDhBLkz.png?imageslim" alt=""></p><h3 id="配置ADC（单次转换模式）"><a href="#配置ADC（单次转换模式）" class="headerlink" title="配置ADC（单次转换模式）"></a>配置ADC（单次转换模式）</h3><p>首先选择<code>ADC1</code>，开启通道3：<br><img src="http://mculover666.cn/image/20190806/4W3UD4FP2vfB.png?imageslim" alt=""></p><p>接下来是对ADC的设置，这里我们保持默认即可：<br><img src="http://mculover666.cn/image/20190806/y1bnlxAf4IOd.png?imageslim" alt=""></p><p>最后设置ADC的转换规则：<br><img src="http://mculover666.cn/image/20190806/TnzK4JjLXoeD.png?imageslim" alt=""></p><p>其余的一些设置保持默认即可。</p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：<br><img src="http://mculover666.cn/image/20190806/1TQg7frjRpVr.png?imageslim" alt=""></p><p><img src="http://mculover666.cn/image/20190808/EVKCwrQNEWcl.png?imageslim" alt=""></p><p><img src="http://mculover666.cn/image/20190806/Dje8nuTMdpQY.png?imageslim" alt=""></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/blog/20191017/x3mIUssnNwpC.png?imageslim" alt=""></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：<br><img src="http://mculover666.cn/image/20190806/T6WvSK6Dfpts.png?imageslim" alt=""></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：<br><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt=""></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="重定向printf-函数"><a href="#重定向printf-函数" class="headerlink" title="重定向printf( )函数"></a>重定向printf( )函数</h2><p>参考：<a href="https://blog.csdn.net/Mculover666/article/details/95975461" target="_blank" rel="noopener">【STM32Cube】（八）基于串口发送函数实现printf()</a>。</p><h2 id="编写读取数据的测试代码"><a href="#编写读取数据的测试代码" class="headerlink" title="编写读取数据的测试代码"></a>编写读取数据的测试代码</h2><p>修改<code>main</code>函数如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 1 */</span>    uint16_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    uint16_t adc_value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> vol <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* USER CODE END 1 */</span>    <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_DAC1_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_ADC1_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"DAC Test...\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">HAL_DAC_Start</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hdac1<span class="token punctuation">,</span> DAC_CHANNEL_2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* USER CODE END 2 */</span>    <span class="token comment" spellcheck="true">/* Infinite loop */</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN WHILE */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* USER CODE END WHILE */</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 3 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4096</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">HAL_DAC_SetValue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hdac1<span class="token punctuation">,</span> DAC_CHANNEL_2<span class="token punctuation">,</span> DAC_ALIGN_12B_R<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">1024</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 使用ADC采样 */</span>            <span class="token function">HAL_ADC_Start</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hadc1<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//启动ADC单次转换</span>            <span class="token function">HAL_ADC_PollForConversion</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hadc1<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//等待ADC转换完成</span>            adc_value <span class="token operator">=</span> <span class="token function">HAL_ADC_GetValue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hadc1<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//读取ADC转换数据</span>            vol <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>adc_value<span class="token operator">/</span><span class="token number">4096</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3.3</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"adc_value = %d, vol = %.2fV.\n"</span><span class="token punctuation">,</span> adc_value<span class="token punctuation">,</span> vol<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"DAC test finish, test again!\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* USER CODE END 3 */</span>    <span class="token punctuation">}</span></code></pre><p><img src="http://mculover666.cn/blog/20191017/MEU1HS8DGg0S.png?imageslim" alt=""></p><p>至此，我们已经学会<strong>如何使用ADC读取DAC输出引脚的电压值</strong>。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_20 | 使用DAC输出任意指定电压值</title>
      <link href="/posts/2707806886/"/>
      <url>/posts/2707806886/</url>
      
        <content type="html"><![CDATA[<p>本篇详细的记录了如何使用STM32CubeMX配置STM32L431RCT6的DAC外设，输出任意指定电压值。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：<br><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt=""></li><li>万用表</li></ul><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li><li>准备一个串口调试助手，这里我使用的是<code>Serial Port Utility</code>；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt=""></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：<br><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt=""></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:<br><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt=""></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：<br><img src="http://mculover666.cn/image/20190806/k593lGGb5tlW.png?imageslim" alt=""></p><h2 id="配置串口"><a href="#配置串口" class="headerlink" title="配置串口"></a>配置串口</h2><p>小熊派开发板板载ST-Link并且虚拟了一个串口，原理图如下：</p><p><img src="http://mculover666.cn/image/20190814/IwyXONVefPx9.png?imageslim" alt=""></p><p>这里我将开关拨到<code>AT-MCU</code>模式，使PC的串口与USART1之间连接。</p><p>接下来开始配置<code>USART1</code>：</p><p><img src="http://mculover666.cn/image/20190814/nLMRMYtmzghl.png?imageslim" alt=""></p><h2 id="配置DAC"><a href="#配置DAC" class="headerlink" title="配置DAC"></a>配置DAC</h2><h3 id="确定DAC输出通道"><a href="#确定DAC输出通道" class="headerlink" title="确定DAC输出通道"></a>确定DAC输出通道</h3><p>查看小熊派E53接口的原理图：</p><p><img src="http://mculover666.cn/blog/20191016/QlodtDUnaD4B.png?imageslim" alt=""></p><h3 id="配置DAC-1"><a href="#配置DAC-1" class="headerlink" title="配置DAC"></a>配置DAC</h3><p>选择<code>DAC1</code>，开启输出通道2，配置保持默认即可：</p><p><img src="http://mculover666.cn/blog/20191016/hSKFOGJtERVf.png?imageslim" alt=""></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：<br><img src="http://mculover666.cn/image/20190806/1TQg7frjRpVr.png?imageslim" alt=""></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/blog/20191016/G55e7qyHVG6Y.png?imageslim" alt=""></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：<br><img src="http://mculover666.cn/image/20190806/T6WvSK6Dfpts.png?imageslim" alt=""></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：<br><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt=""></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="重定向printf-函数"><a href="#重定向printf-函数" class="headerlink" title="重定向printf( )函数"></a>重定向printf( )函数</h2><p>参考：<a href="https://blog.csdn.net/Mculover666/article/details/95975461" target="_blank" rel="noopener">【STM32Cube】（八）基于串口发送函数实现printf()</a>。</p><h2 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h2><p>首先设置DAC输出的数据为<strong>12位右对齐</strong>，然后指定输出的值0-4096，实际输出的电压为<br><code>value/4096x3.3V</code>，最后使能DAC转换，代码如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 1 */</span>    uint16_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* USER CODE END 1 */</span>    <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_DAC1_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"DAC Test...\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">HAL_DAC_Start</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hdac1<span class="token punctuation">,</span> DAC_CHANNEL_2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* USER CODE END 2 */</span>    <span class="token comment" spellcheck="true">/* Infinite loop */</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN WHILE */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* USER CODE END WHILE */</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4096</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">HAL_DAC_SetValue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hdac1<span class="token punctuation">,</span> DAC_CHANNEL_2<span class="token punctuation">,</span> DAC_ALIGN_12B_R<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"DAC test finish, test again!\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 3 */</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* USER CODE END 3 */</span><span class="token punctuation">}</span></code></pre><p><img src="http://mculover666.cn/blog/20191016/xMwqiE5p5Dxt.png?imageslim" alt=""></p><p>至此，我们已经学会<strong>如何使用DAC输出任意指定电压值</strong>。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX DAC DAC输出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX-19 | 使用SDMMC接口读写SD卡数据</title>
      <link href="/posts/3022954032/"/>
      <url>/posts/3022954032/</url>
      
        <content type="html"><![CDATA[<p>本篇详细的记录了如何使用STM32CubeMX配置STM32L431RCT6的硬件SDMMC外设读取SD卡数据。</p><p><img src="http://mculover666.cn/image/20190905/vyYEcOIniSlS.jpg?imageslim" alt="mark"></p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：</li></ul><p><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt="mark"></p><ul><li>Micro SD卡<br>小熊派开发板板载 Micro SD 卡槽，最大支持 32 GB，需要提前自行准备一张 Micro SD卡，如图：</li></ul><p><img src="http://mculover666.cn/image/20190903/CgHfN2loFYyx.png?imageslim" alt="mark"></p><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li><li>准备一个串口调试助手，这里我使用的是<code>Serial Port Utility</code>；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt="mark"></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：<br><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt="mark"></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:<br><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt="mark"></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：</p><p><img src="http://mculover666.cn/image/20190829/dBG4s5JFoXGM.png?imageslim" alt="mark"></p><h2 id="配置串口"><a href="#配置串口" class="headerlink" title="配置串口"></a>配置串口</h2><p>小熊派开发板板载ST-Link并且虚拟了一个串口，原理图如下：</p><p><img src="http://mculover666.cn/image/20190814/IwyXONVefPx9.png?imageslim" alt="mark"></p><p>这里我将开关拨到<code>AT-MCU</code>模式，使PC的串口与USART1之间连接。</p><p>接下来开始配置<code>USART1</code>：</p><p><img src="http://mculover666.cn/image/20190814/nLMRMYtmzghl.png?imageslim" alt="mark"></p><h2 id="配置-SDMMC-接口"><a href="#配置-SDMMC-接口" class="headerlink" title="配置 SDMMC 接口"></a>配置 SDMMC 接口</h2><blockquote><p>知识小卡片 —— SDMMC接口</p></blockquote><p>SDMMC接口的全称叫<code>SD/SDIO MMC card host interface</code>，SD/SDIO MMC 卡 主机接口，通俗的来说，就是这个接口支持SD卡，支持SDIO设备，支持MMC卡。</p><blockquote><p>知识小卡片结束啦~</p></blockquote><p>首先查看小熊派开发板的原理图：</p><p><img src="http://mculover666.cn/image/20190903/5p7dMFxj3rSE.png?imageslim" alt="mark"></p><p>然后根据原理图配置 SDMMC 接口：</p><p><img src="http://mculover666.cn/image/20190902/uMcmVYpIsIcy.png?imageslim" alt="mark"></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：</p><p><img src="http://mculover666.cn/image/20190902/Bp7T9w424Prq.png?imageslim" alt="mark"></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/image/20190902/9kbez0U85pn0.png?imageslim" alt="mark"></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：</p><p><img src="http://mculover666.cn/image/20190806/T6WvSK6Dfpts.png?imageslim" alt="mark"></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：</p><p><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt="mark"></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="重定向printf-函数"><a href="#重定向printf-函数" class="headerlink" title="重定向printf( )函数"></a>重定向printf( )函数</h2><p>参考：<a href="https://www.mculover666.cn/2019/07/30/STM32Cube/【STM32Cube-09】重定向printf函数到串口输出的多种方法/">【STM32Cube_09】重定向printf函数到串口输出的多种方法</a>。</p><h2 id="读取SD卡信息并打印"><a href="#读取SD卡信息并打印" class="headerlink" title="读取SD卡信息并打印"></a>读取SD卡信息并打印</h2><p>SD 卡系统(包括主机和 SD 卡)定义了两种操作模式：</p><ul><li>卡识别模式</li><li>数据传输模式</li></ul><p>在<strong>系统复位后，主机处于卡识别模式</strong>，寻找总线上可用的 SD卡设备；同时，SD 卡也处于卡<br>识别模式，直到被主机识别到。</p><p>使用STM32CubeMX初始化的工程中会自动生成 SDMMC 初始化函数，向 SD 卡发送命令，<strong>当 SD 卡接收到命令后， SD 卡就会进入数据传输模式，而主机在总线上所有卡被识别后也进入数据传输模式</strong>。</p><p>所以在操作之前，需要先检查 SD 卡是否处于数据传输模式并且处于数据传输状态：</p><p>在<code>main</code>函数中首先定义一个变量用于存储 SD 卡状态：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> sdcard_status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>HAL_SD_CardCIDTypeDef sdcard_cid<span class="token punctuation">;</span></code></pre><p>然后在<code>while(1)</code>之前编写如下读取信息代码：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Micro SD Card Test...\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 检测SD卡是否正常（处于数据传输模式的传输状态） */</span>sdcard_status <span class="token operator">=</span> <span class="token function">HAL_SD_GetCardState</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hsd1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>sdcard_status <span class="token operator">==</span> HAL_SD_CARD_TRANSFER<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"SD card init ok!\r\n\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//打印SD卡基本信息</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"SD card information!\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"CardCapacity: %llu\r\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>hsd1<span class="token punctuation">.</span>SdCard<span class="token punctuation">.</span>BlockSize<span class="token operator">*</span>hsd1<span class="token punctuation">.</span>SdCard<span class="token punctuation">.</span>BlockNbr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"CardBlockSize: %d \r\n"</span><span class="token punctuation">,</span>hsd1<span class="token punctuation">.</span>SdCard<span class="token punctuation">.</span>BlockSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"RCA: %d \r\n"</span><span class="token punctuation">,</span>hsd1<span class="token punctuation">.</span>SdCard<span class="token punctuation">.</span>RelCardAdd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"CardType: %d \r\n"</span><span class="token punctuation">,</span>hsd1<span class="token punctuation">.</span>SdCard<span class="token punctuation">.</span>CardType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//读取并打印SD卡的CID信息</span>    <span class="token function">HAL_SD_GetCardCID</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hsd1<span class="token punctuation">,</span><span class="token operator">&amp;</span>sdcard_cid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ManufacturerID: %d \r\n"</span><span class="token punctuation">,</span>sdcard_cid<span class="token punctuation">.</span>ManufacturerID<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"SD card init fail!\r\n"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* USER CODE END 2 */</span></code></pre><p>编译下载后串口助手输出结果如下：</p><p><img src="http://mculover666.cn/image/20190903/Dyuawd1r1QmG.png?imageslim" alt="mark"></p><h2 id="擦除SD卡块数据"><a href="#擦除SD卡块数据" class="headerlink" title="擦除SD卡块数据"></a>擦除SD卡块数据</h2><p>为了验证实验的正确性或，先擦除数据：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 擦除SD卡块 */</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"------------------- Block Erase -------------------------------\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sdcard_status <span class="token operator">=</span> <span class="token function">HAL_SD_Erase</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hsd1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sdcard_status <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Erase block ok\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Erase block fail\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="读取SD卡块数据"><a href="#读取SD卡块数据" class="headerlink" title="读取SD卡块数据"></a>读取SD卡块数据</h2><p>首先开辟一个<strong>全局</strong>缓冲区，用于存放从SD卡读出的数据：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Private user code ---------------------------------------------------------*/</span><span class="token comment" spellcheck="true">/* USER CODE BEGIN 0 */</span>uint8_t read_buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* USER CODE END 0 */</span></code></pre><p>然后在之前读取信息的代码之后添加读取数据的代码：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 读取未操作之前的数据 */</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"------------------- Read SD card block data Test ------------------\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sdcard_status <span class="token operator">=</span> <span class="token function">HAL_SD_ReadBlocks</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hsd1<span class="token punctuation">,</span><span class="token punctuation">(</span>uint8_t <span class="token operator">*</span><span class="token punctuation">)</span>read_buf<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0xffff</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>sdcard_status <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Read block data ok \r\n"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">512</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0x%02x "</span><span class="token punctuation">,</span> read_buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">16</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Read block data fail!\r\n "</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="向SD卡块写入数据"><a href="#向SD卡块写入数据" class="headerlink" title="向SD卡块写入数据"></a>向SD卡块写入数据</h2><p>同样的，开辟一个<strong>全局</strong>缓冲区，用于存放即将要写入SD卡的数据：</p><pre class=" language-c"><code class="language-c">uint8_t write_buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>然后在之前读取数据的代码之后添加的代码，将缓冲区的数据赋初值：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 填充缓冲区数据 */</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">512</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    write_buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">%</span> <span class="token number">256</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后继续添加代码，将该缓冲区数据写入SD卡：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 向SD卡块写入数据 */</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"------------------- Write SD card block data Test ------------------\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sdcard_status <span class="token operator">=</span> <span class="token function">HAL_SD_WriteBlocks</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hsd1<span class="token punctuation">,</span><span class="token punctuation">(</span>uint8_t <span class="token operator">*</span><span class="token punctuation">)</span>write_buf<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0xffff</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>sdcard_status <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Write block data ok \r\n"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Write block data fail!\r\n "</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>添加完之后，为了检查数据是否正常写入，再将数据读出：</p><pre><code>/* 读取操作之后的数据 */printf(&quot;------------------- Read SD card block data after Write ------------------\r\n&quot;);sdcard_status = HAL_SD_ReadBlocks(&amp;hsd1,(uint8_t *)read_buf,0,1,0xffff);if(sdcard_status == 0){     printf(&quot;Read block data ok \r\n&quot; );    for(i = 0; i &lt; 512; i++)    {        printf(&quot;0x%02x &quot;, read_buf[i]);        if((i+1)%16 == 0)        {            printf(&quot;\r\n&quot;);        }    }}</code></pre><p>将程序编译下载，最终的实验结果如下：</p><p><img src="http://mculover666.cn/image/20190903/tzrRr67CIRLk.png?imageslim" alt="mark"></p><p><img src="http://mculover666.cn/image/20190903/5XIe3u2Mh4mh.png?imageslim" alt="mark"></p><p><img src="http://mculover666.cn/image/20190903/hvGkRtezU8OC.png?imageslim" alt="mark"></p><p><img src="http://mculover666.cn/image/20190903/jVzz5QivHgBy.png?imageslim" alt="mark"></p><p><img src="http://mculover666.cn/image/20190903/4raBihOAOhvb.png?imageslim" alt="mark"></p><p>至此，我们已经学会<strong>如何使用硬件SDMMC接口读取SD数据</strong>，STM32CubeMX系列教程完结。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX SD Card SDMMC接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX-18 | 使用硬件QSPI读写SPI Flash（W25Q64）</title>
      <link href="/posts/1294047065/"/>
      <url>/posts/1294047065/</url>
      
        <content type="html"><![CDATA[<p>本篇详细的记录了如何使用STM32CubeMX配置STM32L431RCT6的硬件QSPI外设与 SPI Flash 通信（W25Q64）。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：</li></ul><p><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt="mark"></p><ul><li>SPI Flash<br>小熊派开发板板载一片SPI Flash，型号为 <code>W25Q64</code>，大小为 8 MB，最大支持 80 Mhz的操作频率。</li></ul><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li><li>准备一个串口调试助手，这里我使用的是<code>Serial Port Utility</code>；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt="mark"></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：<br><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt="mark"></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:<br><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt="mark"></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：</p><p><img src="http://mculover666.cn/image/20190829/dBG4s5JFoXGM.png?imageslim" alt="mark"></p><h2 id="配置串口"><a href="#配置串口" class="headerlink" title="配置串口"></a>配置串口</h2><p>小熊派开发板板载ST-Link并且虚拟了一个串口，原理图如下：</p><p><img src="http://mculover666.cn/image/20190814/IwyXONVefPx9.png?imageslim" alt="mark"></p><p>这里我将开关拨到<code>AT-MCU</code>模式，使PC的串口与USART1之间连接。</p><p>接下来开始配置<code>USART1</code>：</p><p><img src="http://mculover666.cn/image/20190814/nLMRMYtmzghl.png?imageslim" alt="mark"></p><h2 id="配置QSPI接口"><a href="#配置QSPI接口" class="headerlink" title="配置QSPI接口"></a>配置QSPI接口</h2><p>首先查看小熊派开发板上 SPI Flash 的原理图：</p><p><img src="http://mculover666.cn/image/20190903/IBQ1uUzXevoT.png?imageslim" alt="mark"></p><p>其引脚连接情况如下：</p><table><thead><tr><th align="center">SPI Flash连接引脚</th><th align="center">对应引脚</th></tr></thead><tbody><tr><td align="center">QUADSPI_BK1_NCS</td><td align="center">PB11</td></tr><tr><td align="center">QUADSPI_BK1_CLK</td><td align="center">PB10</td></tr><tr><td align="center">QUADSPI_BK1_IO0</td><td align="center">PB1</td></tr><tr><td align="center">QUADSPI_BK1_IO1</td><td align="center">PB0</td></tr></tbody></table><p>接下来配置 QSPI 接口：</p><p><img src="http://mculover666.cn/image/20190903/0VBw2fFuGswz.png?imageslim" alt="mark"></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：<br><img src="http://mculover666.cn/image/20190806/1TQg7frjRpVr.png?imageslim" alt="mark"></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/image/20190903/38BkgTe2YX03.png?imageslim" alt="mark"></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：</p><p><img src="http://mculover666.cn/image/20190806/T6WvSK6Dfpts.png?imageslim" alt="mark"></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：</p><p><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt="mark"></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="重定向printf-函数"><a href="#重定向printf-函数" class="headerlink" title="重定向printf( )函数"></a>重定向printf( )函数</h2><p>参考：<a href="https://www.mculover666.cn/2019/07/30/STM32Cube/【STM32Cube-09】重定向printf函数到串口输出的多种方法/">【STM32Cube_09】重定向printf函数到串口输出的多种方法</a>。</p><h1 id="4-封装-SPI-Flash（W25Q64）的命令和底层函数"><a href="#4-封装-SPI-Flash（W25Q64）的命令和底层函数" class="headerlink" title="4. 封装 SPI Flash（W25Q64）的命令和底层函数"></a>4. 封装 SPI Flash（W25Q64）的命令和底层函数</h1><p>MCU 通过向 SPI Flash <strong>发送各种命令</strong> 来读写 SPI Flash内部的寄存器，所以这种裸机驱动，首先要先宏定义出需要使用的命令，然后利用 HAL 库提供的库函数，封装出三个底层函数，<strong>便于移植</strong>：</p><ul><li>向 SPI Flash 发送命令的函数</li><li>向 SPI Flash 发送数据的函数</li><li>从 SPI Flash 接收数据的函数</li></ul><p>接下来开始编写代码~</p><h2 id="宏定义操作命令"><a href="#宏定义操作命令" class="headerlink" title="宏定义操作命令"></a>宏定义操作命令</h2><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> ManufactDeviceID_CMD    0x90</span><span class="token macro property">#<span class="token directive keyword">define</span> READ_STATU_REGISTER_1   0x05</span><span class="token macro property">#<span class="token directive keyword">define</span> READ_STATU_REGISTER_2   0x35</span><span class="token macro property">#<span class="token directive keyword">define</span> READ_DATA_CMD            0x03</span><span class="token macro property">#<span class="token directive keyword">define</span> WRITE_ENABLE_CMD        0x06</span><span class="token macro property">#<span class="token directive keyword">define</span> WRITE_DISABLE_CMD        0x04</span><span class="token macro property">#<span class="token directive keyword">define</span> SECTOR_ERASE_CMD        0x20</span><span class="token macro property">#<span class="token directive keyword">define</span> CHIP_ERASE_CMD            0xc7</span><span class="token macro property">#<span class="token directive keyword">define</span> PAGE_PROGRAM_CMD        0x02</span></code></pre><h2 id="封装发送命令的函数（重点）"><a href="#封装发送命令的函数（重点）" class="headerlink" title="封装发送命令的函数（重点）"></a>封装发送命令的函数（重点）</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief        向SPI Flash发送指令 * @param        instruction —— 要发送的指令 * @param        address     —— 要发送的地址 * @param        dummyCycles    —— 空指令周期数 * @param        instructionMode —— 指令发送模式 * @param        addressMode —— 地址发送模式 * @param        addressSize    —— 地址大小 * @param        dataMode    —— 数据发送模式 * @retval        成功返回HAL_OK*/</span>HAL_StatusTypeDef <span class="token function">QSPI_Send_Command</span><span class="token punctuation">(</span>uint32_t instruction<span class="token punctuation">,</span>                                     uint32_t address<span class="token punctuation">,</span>                                     uint32_t dummyCycles<span class="token punctuation">,</span>                                     uint32_t instructionMode<span class="token punctuation">,</span>                                     uint32_t addressMode<span class="token punctuation">,</span>                                     uint32_t addressSize<span class="token punctuation">,</span>                                     uint32_t dataMode<span class="token punctuation">)</span><span class="token punctuation">{</span>    QSPI_CommandTypeDef cmd<span class="token punctuation">;</span>    cmd<span class="token punctuation">.</span>Instruction <span class="token operator">=</span> instruction<span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//指令</span>    cmd<span class="token punctuation">.</span>Address <span class="token operator">=</span> address<span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">//地址</span>    cmd<span class="token punctuation">.</span>DummyCycles <span class="token operator">=</span> dummyCycles<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//设置空指令周期数</span>    cmd<span class="token punctuation">.</span>InstructionMode <span class="token operator">=</span> instructionMode<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//指令模式</span>    cmd<span class="token punctuation">.</span>AddressMode <span class="token operator">=</span> addressMode<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//地址模式</span>    cmd<span class="token punctuation">.</span>AddressSize <span class="token operator">=</span> addressSize<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//地址长度</span>    cmd<span class="token punctuation">.</span>DataMode <span class="token operator">=</span> dataMode<span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">//数据模式</span>    cmd<span class="token punctuation">.</span>SIOOMode <span class="token operator">=</span> QSPI_SIOO_INST_EVERY_CMD<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//每次都发送指令</span>    cmd<span class="token punctuation">.</span>AlternateByteMode <span class="token operator">=</span> QSPI_ALTERNATE_BYTES_NONE<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//无交替字节</span>    cmd<span class="token punctuation">.</span>DdrMode <span class="token operator">=</span> QSPI_DDR_MODE_DISABLE<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//关闭DDR模式</span>    cmd<span class="token punctuation">.</span>DdrHoldHalfCycle <span class="token operator">=</span> QSPI_DDR_HHC_ANALOG_DELAY<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">HAL_QSPI_Command</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hqspi<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cmd<span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="封装发送数据的函数"><a href="#封装发送数据的函数" class="headerlink" title="封装发送数据的函数"></a>封装发送数据的函数</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*** @brief    QSPI发送指定长度的数据* @param    buf  —— 发送数据缓冲区首地址* @param    size —— 要发送数据的字节数 * @retval    成功返回HAL_OK */</span>HAL_StatusTypeDef <span class="token function">QSPI_Transmit</span><span class="token punctuation">(</span>uint8_t<span class="token operator">*</span> send_buf<span class="token punctuation">,</span> uint32_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    hqspi<span class="token punctuation">.</span>Instance<span class="token operator">-></span>DLR <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">//配置数据长度</span>    <span class="token keyword">return</span> <span class="token function">HAL_QSPI_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hqspi<span class="token punctuation">,</span> send_buf<span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//接收数据</span><span class="token punctuation">}</span></code></pre><h2 id="封装接收数据的函数"><a href="#封装接收数据的函数" class="headerlink" title="封装接收数据的函数"></a>封装接收数据的函数</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief      QSPI接收指定长度的数据 * @param   buf  —— 接收数据缓冲区首地址 * @param   size —— 要接收数据的字节数 * @retval    成功返回HAL_OK */</span>HAL_StatusTypeDef <span class="token function">QSPI_Receive</span><span class="token punctuation">(</span>uint8_t<span class="token operator">*</span> recv_buf<span class="token punctuation">,</span> uint32_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    hqspi<span class="token punctuation">.</span>Instance<span class="token operator">-></span>DLR <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//配置数据长度</span>    <span class="token keyword">return</span> <span class="token function">HAL_QSPI_Receive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hqspi<span class="token punctuation">,</span> recv_buf<span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//接收数据</span><span class="token punctuation">}</span></code></pre><h1 id="5-编写W25Q64的驱动程序"><a href="#5-编写W25Q64的驱动程序" class="headerlink" title="5. 编写W25Q64的驱动程序"></a>5. 编写W25Q64的驱动程序</h1><p>接下来开始利用上一节封装的宏定义和底层函数，编写W25Q64的驱动程序：</p><h2 id="读取Manufacture-ID和Device-ID"><a href="#读取Manufacture-ID和Device-ID" class="headerlink" title="读取Manufacture ID和Device ID"></a>读取Manufacture ID和Device ID</h2><p>读取 Flash 内部这两个ID有两个作用：</p><ul><li>检测SPI Flash是否存在</li><li>可以根据ID判断Flash具体型号</li></ul><p>数据手册上给出的操作时序如图：</p><p><img src="http://mculover666.cn/image/20190903/GkfvfgRgRA53.png?imageslim" alt="mark"></p><p>根据该时序，编写代码如下：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief   读取Flash内部的ID * @param   none * @retval    成功返回device_id */</span>uint16_t <span class="token function">W25QXX_ReadID</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    uint8_t recv_buf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//recv_buf[0]存放Manufacture ID, recv_buf[1]存放Device ID</span>    uint16_t device_id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>HAL_OK <span class="token operator">==</span> <span class="token function">QSPI_Send_Command</span><span class="token punctuation">(</span>ManufactDeviceID_CMD<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> QSPI_INSTRUCTION_1_LINE<span class="token punctuation">,</span> QSPI_ADDRESS_1_LINE<span class="token punctuation">,</span> QSPI_ADDRESS_24_BITS<span class="token punctuation">,</span> QSPI_DATA_1_LINE<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//读取ID</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>HAL_OK <span class="token operator">==</span> <span class="token function">QSPI_Receive</span><span class="token punctuation">(</span>recv_buf<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            device_id <span class="token operator">=</span> <span class="token punctuation">(</span>recv_buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> recv_buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> device_id<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>SPI Flash读取数据可以任意地址（地址长度32bit）读任意长度数据（最大 65535 Byte），没有任何限制，数据手册给出的时序如下：</p><p><img src="http://mculover666.cn/image/20190903/UMtHmQEcDSj5.png?imageslim" alt="mark"></p><p>根据该时序图编写代码如下：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief    读取SPI FLASH数据 * @param   dat_buffer —— 数据存储区 * @param   start_read_addr —— 开始读取的地址(最大32bit) * @param   byte_to_read —— 要读取的字节数(最大65535) * @retval  none */</span><span class="token keyword">void</span> <span class="token function">W25QXX_Read</span><span class="token punctuation">(</span>uint8_t<span class="token operator">*</span> dat_buffer<span class="token punctuation">,</span> uint32_t start_read_addr<span class="token punctuation">,</span> uint16_t byte_to_read<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">QSPI_Send_Command</span><span class="token punctuation">(</span>READ_DATA_CMD<span class="token punctuation">,</span> start_read_addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> QSPI_INSTRUCTION_1_LINE<span class="token punctuation">,</span> QSPI_ADDRESS_1_LINE<span class="token punctuation">,</span> QSPI_ADDRESS_24_BITS<span class="token punctuation">,</span> QSPI_DATA_1_LINE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">QSPI_Receive</span><span class="token punctuation">(</span>dat_buffer<span class="token punctuation">,</span> byte_to_read<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="读取状态寄存器数据并判断Flash是否忙碌"><a href="#读取状态寄存器数据并判断Flash是否忙碌" class="headerlink" title="读取状态寄存器数据并判断Flash是否忙碌"></a>读取状态寄存器数据并判断Flash是否忙碌</h2><p>上文中提到，SPI Flash的所有操作都是靠发送命令完成的，但是 Flash 接收到命令后，需要一段时间去执行该操作，这段时间内 Flash 处于“忙”状态，MCU 发送的命令无效，不能执行，在 Flash 内部有2-3个状态寄存器，指示出 Flash 当前的状态，有趣的一点是：</p><p>当 Flash 内部在执行命令时，不能再执行 MCU 发来的命令，但是 MCU 可以一直读取状态寄存器，这下就很好办了，<strong>MCU可以一直读取，然后判断Flash是否忙完</strong>：</p><p><img src="http://mculover666.cn/image/20190903/NaLt1TbTLkEQ.png?imageslim" alt="mark"></p><p>首先读取状态寄存器的代码如下：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief    读取W25QXX的状态寄存器，W25Q64一共有2个状态寄存器 * @param     reg  —— 状态寄存器编号(1~2) * @retval    状态寄存器的值 */</span>uint8_t <span class="token function">W25QXX_ReadSR</span><span class="token punctuation">(</span>uint8_t reg<span class="token punctuation">)</span><span class="token punctuation">{</span>    uint8_t cmd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">/* 读取状态寄存器1的值 */</span>            cmd <span class="token operator">=</span> READ_STATU_REGISTER_1<span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>            cmd <span class="token operator">=</span> READ_STATU_REGISTER_2<span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            cmd <span class="token operator">=</span> READ_STATU_REGISTER_1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">QSPI_Send_Command</span><span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> QSPI_INSTRUCTION_1_LINE<span class="token punctuation">,</span> QSPI_ADDRESS_NONE<span class="token punctuation">,</span> QSPI_ADDRESS_24_BITS<span class="token punctuation">,</span> QSPI_DATA_1_LINE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">QSPI_Receive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>result<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后编写<strong>阻塞判断</strong>Flash是否忙碌的函数：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief    阻塞等待Flash处于空闲状态 * @param   none * @retval  none */</span><span class="token keyword">void</span> <span class="token function">W25QXX_Wait_Busy</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">W25QXX_ReadSR</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x01</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等待BUSY位清空</span><span class="token punctuation">}</span></code></pre><h2 id="写使能-禁止"><a href="#写使能-禁止" class="headerlink" title="写使能/禁止"></a>写使能/禁止</h2><p>Flash 芯片默认禁止写数据，所以<strong>在向 Flash 写数据之前，必须发送命令开启写使能</strong>，数据手册中给出的时序如下：</p><p><img src="http://mculover666.cn/image/20190903/3AEI5vo1PAt6.png?imageslim" alt="mark"></p><p><img src="http://mculover666.cn/image/20190903/XFJeqVP2Synu.png?imageslim" alt="mark"></p><p>编写函数如下：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief    W25QXX写使能,将S1寄存器的WEL置位 * @param    none * @retval */</span><span class="token keyword">void</span> <span class="token function">W25QXX_Write_Enable</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">QSPI_Send_Command</span><span class="token punctuation">(</span>WRITE_ENABLE_CMD<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> QSPI_INSTRUCTION_1_LINE<span class="token punctuation">,</span> QSPI_ADDRESS_NONE<span class="token punctuation">,</span> QSPI_ADDRESS_8_BITS<span class="token punctuation">,</span> QSPI_DATA_NONE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">W25QXX_Wait_Busy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * @brief    W25QXX写禁止,将WEL清零 * @param    none * @retval    none */</span><span class="token keyword">void</span> <span class="token function">W25QXX_Write_Disable</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">QSPI_Send_Command</span><span class="token punctuation">(</span>WRITE_DISABLE_CMD<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> QSPI_INSTRUCTION_1_LINE<span class="token punctuation">,</span> QSPI_ADDRESS_NONE<span class="token punctuation">,</span> QSPI_ADDRESS_8_BITS<span class="token punctuation">,</span> QSPI_DATA_NONE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">W25QXX_Wait_Busy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="擦除扇区"><a href="#擦除扇区" class="headerlink" title="擦除扇区"></a>擦除扇区</h2><p>SPI Flash有个特性：</p><p><strong>数据位可以由1变为0，但是不能由0变为1。</strong></p><p>所以在向 Flash 写数据之前，必须要先进行擦除操作，并且 Flash <strong>最小只能擦除一个扇区</strong>，擦除之后该扇区所有的数据变为 <code>0xFF</code>（即全为1），数据手册中给出的时序如下：</p><p><img src="http://mculover666.cn/image/20190903/PSxaMby1uMur.png?imageslim" alt="mark"></p><p>根据此时序编写函数如下：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief    W25QXX擦除一个扇区 * @param   sector_addr    —— 扇区地址 根据实际容量设置 * @retval  none * @note    阻塞操作 */</span><span class="token keyword">void</span> <span class="token function">W25QXX_Erase_Sector</span><span class="token punctuation">(</span>uint32_t sector_addr<span class="token punctuation">)</span><span class="token punctuation">{</span>    sector_addr <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">4096</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//每个块有16个扇区，每个扇区的大小是4KB，需要换算为实际地址</span>    <span class="token function">W25QXX_Write_Enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//擦除操作即写入0xFF，需要开启写使能</span>    <span class="token function">W25QXX_Wait_Busy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//等待写使能完成</span>    <span class="token function">QSPI_Send_Command</span><span class="token punctuation">(</span>SECTOR_ERASE_CMD<span class="token punctuation">,</span> sector_addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> QSPI_INSTRUCTION_1_LINE<span class="token punctuation">,</span> QSPI_ADDRESS_1_LINE<span class="token punctuation">,</span> QSPI_ADDRESS_24_BITS<span class="token punctuation">,</span> QSPI_DATA_NONE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">W25QXX_Wait_Busy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//等待扇区擦除完成</span><span class="token punctuation">}</span></code></pre><h2 id="页写入操作"><a href="#页写入操作" class="headerlink" title="页写入操作"></a>页写入操作</h2><p>向 Flash 芯片写数据的时候，因为 Flash 内部的构造，可以按页写入：</p><p><img src="http://mculover666.cn/image/20190903/djkcs1yIqr4P.png?imageslim" alt="mark"></p><p>页写入的时序如图：</p><p><img src="http://mculover666.cn/image/20190903/N0cmYLXQXItA.png?imageslim" alt="mark"></p><p>编写代码如下：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief    页写入操作 * @param    dat —— 要写入的数据缓冲区首地址 * @param    WriteAddr —— 要写入的地址 * @param   byte_to_write —— 要写入的字节数（0-256） * @retval    none */</span><span class="token keyword">void</span> <span class="token function">W25QXX_Page_Program</span><span class="token punctuation">(</span>uint8_t<span class="token operator">*</span> dat<span class="token punctuation">,</span> uint32_t WriteAddr<span class="token punctuation">,</span> uint16_t byte_to_write<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">W25QXX_Write_Enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">QSPI_Send_Command</span><span class="token punctuation">(</span>PAGE_PROGRAM_CMD<span class="token punctuation">,</span> WriteAddr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> QSPI_INSTRUCTION_1_LINE<span class="token punctuation">,</span> QSPI_ADDRESS_1_LINE<span class="token punctuation">,</span> QSPI_ADDRESS_24_BITS<span class="token punctuation">,</span> QSPI_DATA_1_LINE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">QSPI_Transmit</span><span class="token punctuation">(</span>dat<span class="token punctuation">,</span> byte_to_write<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">W25QXX_Wait_Busy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="6-测试驱动"><a href="#6-测试驱动" class="headerlink" title="6. 测试驱动"></a>6. 测试驱动</h1><p>在 <code>main.c</code> 函数中编写代码，测试驱动：</p><p>首先定义两个缓存：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Private user code ---------------------------------------------------------*/</span><span class="token comment" spellcheck="true">/* USER CODE BEGIN 0 */</span>uint8_t dat<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"mculover666"</span><span class="token punctuation">;</span>uint8_t read_buf<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* USER CODE END 0 */</span></code></pre><p>然后在 main 函数中编写代码：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Test W25QXX...\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>device_id <span class="token operator">=</span> <span class="token function">W25QXX_ReadID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"device_id = 0x%04X\r\n\r\n"</span><span class="token punctuation">,</span> device_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 为了验证，首先读取要写入地址处的数据 */</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-------- read data before write -----------\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">W25QXX_Read</span><span class="token punctuation">(</span>read_buf<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read date is %s\r\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>read_buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 擦除该扇区 */</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-------- erase sector 0 -----------\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">W25QXX_Erase_Sector</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 写数据 */</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-------- write data -----------\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">W25QXX_Page_Program</span><span class="token punctuation">(</span>dat<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 再次读数据 */</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-------- read data after write -----------\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">W25QXX_Read</span><span class="token punctuation">(</span>read_buf<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read date is %s\r\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>read_buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* USER CODE END 2 */</span></code></pre><p>测试结果如下：</p><p><img src="http://mculover666.cn/image/20190903/lw04M0RJ7gYp.png?imageslim" alt="mark"></p><p>至此，我们已经学会<strong>如何使用硬件QSPI接口读写SPI Flash的数据</strong>，下一节将讲述如何使用硬件SDMMC接口读取SD卡数据。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX SPI Flash QSPI接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_17 | 使用硬件SPI驱动TFT-LCD（ST7789）</title>
      <link href="/posts/4251315252/"/>
      <url>/posts/4251315252/</url>
      
        <content type="html"><![CDATA[<p>本篇详细的记录了如何使用STM32CubeMX配置STM32L431RCT6的硬件SPI外设与ST7789通信，驱动16bit TFT-LCD 屏幕。</p><a id="more"></a><h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>我的一些个人观点：</p><blockquote><p>学习 SPI 外设驱动LCD屏幕没有必要手写驱动，学习这部分代码的目的是为了了解TFT-LCD的工作原理，每个像素点是如何显示的，<strong>不要花过多的精力在弄明白每个命令的意思</strong>，建议基于本驱动，学习一下打点，画线算法，画圆算法，画多边形算法等等，还可以学习显示英文字符，中文字符，最后还可以移植STemwin显示界面等等好玩的东西~</p></blockquote><p><img src="http://mculover666.cn/image/20190830/uNWWafiL7nsd.png?imageslim" alt="mark"></p><p><img src="http://mculover666.cn/image/20190830/AE6zUCi3kdTR.png?imageslim" alt="mark"></p><p><img src="http://mculover666.cn/image/20190830/H63SNPAj4yeq.png?imageslim" alt="mark"></p><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：</li></ul><p><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt="mark"></p><ul><li>LCD屏幕<br>小熊派开发板板载LCD屏幕<strong>大小1.3寸，分辨率240*240，色彩深度16bit，使用ST7789V2液晶控制器</strong>。</li></ul><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li><li>准备一个串口调试助手，这里我使用的是<code>Serial Port Utility</code>；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt="mark"></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：<br><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt="mark"></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:<br><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt="mark"></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：</p><p><img src="http://mculover666.cn/image/20190829/dBG4s5JFoXGM.png?imageslim" alt="mark"></p><h2 id="配置LCD控制GPIO"><a href="#配置LCD控制GPIO" class="headerlink" title="配置LCD控制GPIO"></a>配置LCD控制GPIO</h2><p><img src="http://mculover666.cn/image/20190829/4Y0g6NTXlmsc.png?imageslim" alt="mark"></p><h2 id="配置SPI2接口"><a href="#配置SPI2接口" class="headerlink" title="配置SPI2接口"></a>配置SPI2接口</h2><p>查看小熊派LCD接口的原理图：</p><p><img src="http://mculover666.cn/image/20190829/J5lfuBmdy0q2.png?imageslim" alt="mark"></p><p><img src="http://mculover666.cn/image/20190829/rIsAkWbeqWjH.png?imageslim" alt="mark"></p><p>引脚对应表如下：</p><table><thead><tr><th align="center">LCD引脚</th><th align="center">MCU引脚</th></tr></thead><tbody><tr><td align="center">SPI2_MOSI</td><td align="center">PC3</td></tr><tr><td align="center">SPI2_CLK</td><td align="center">PB13</td></tr><tr><td align="center">LCD_WR_RS</td><td align="center">PC6</td></tr><tr><td align="center">LCD_RESET</td><td align="center">PC7</td></tr><tr><td align="center">LCD_POWER</td><td align="center">PB15</td></tr></tbody></table><p>MCU只需要通过SPI向LCD控制器发送命令/数据即可，所以硬件上接 SPI2 的 SCK 和 MOSI 引脚，软件上将SPI2配置为发送主机模式，接下来开始配置SPI2接口：</p><p>参数设置如下：</p><p><img src="http://mculover666.cn/image/20190829/1DHh2ytSwgcp.png?imageslim" alt="mark"></p><p>SPI2默认SCK引脚是PB10，和开发板不对应，所以重新修改引脚为PB13：</p><p><img src="http://mculover666.cn/image/20190829/J0O0uJFSEap1.png?imageslim" alt="mark"></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：<br><img src="http://mculover666.cn/image/20190806/1TQg7frjRpVr.png?imageslim" alt="mark"></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/image/20190829/MQ6wAeYd1mMw.png?imageslim" alt="mark"></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：<br><img src="http://mculover666.cn/image/20190806/T6WvSK6Dfpts.png?imageslim" alt="mark"></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：<br><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt="mark"></p><h1 id="3-编写LCD驱动（ST7789）——-封装宏和底层函数"><a href="#3-编写LCD驱动（ST7789）——-封装宏和底层函数" class="headerlink" title="3. 编写LCD驱动（ST7789）—— 封装宏和底层函数"></a>3. 编写LCD驱动（ST7789）—— 封装宏和底层函数</h1><h2 id="3-1-封装控制LCD控制引脚高低电平的宏"><a href="#3-1-封装控制LCD控制引脚高低电平的宏" class="headerlink" title="3.1. 封装控制LCD控制引脚高低电平的宏"></a>3.1. 封装控制LCD控制引脚高低电平的宏</h2><p>控制引脚宏定义已经包含在 <code>main.h</code> 中，如图：</p><p><img src="http://mculover666.cn/image/20190829/X2Pj10IvIdq0.png?imageslim" alt="mark"></p><p>在编写驱动的过程中需要不断的控制这些控制引脚的电平，所以首先在 <code>lcd_spi2_drv.h</code> 头文件中编写控制这些引脚的宏：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"main.h"</span></span><span class="token macro property">#<span class="token directive keyword">define</span>    LCD_PWR(n)        (n?\                        HAL_GPIO_WritePin(LCD_PWR_GPIO_Port,LCD_PWR_Pin,GPIO_PIN_SET):\                        HAL_GPIO_WritePin(LCD_PWR_GPIO_Port,LCD_PWR_Pin,GPIO_PIN_RESET))</span><span class="token macro property">#<span class="token directive keyword">define</span>    LCD_WR_RS(n)    (n?\                        HAL_GPIO_WritePin(LCD_WR_RS_GPIO_Port,LCD_WR_RS_Pin,GPIO_PIN_SET):\                        HAL_GPIO_WritePin(LCD_WR_RS_GPIO_Port,LCD_WR_RS_Pin,GPIO_PIN_RESET))</span><span class="token macro property">#<span class="token directive keyword">define</span>    LCD_RST(n)        (n?\                        HAL_GPIO_WritePin(LCD_RST_GPIO_Port,LCD_RST_Pin,GPIO_PIN_SET):\                        HAL_GPIO_WritePin(LCD_RST_GPIO_Port,LCD_RST_Pin,GPIO_PIN_RESET))</span></code></pre><h2 id="3-2-宏定义屏幕分辨率和颜色值"><a href="#3-2-宏定义屏幕分辨率和颜色值" class="headerlink" title="3.2. 宏定义屏幕分辨率和颜色值"></a>3.2. 宏定义屏幕分辨率和颜色值</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//LCD屏幕分辨率定义</span><span class="token macro property">#<span class="token directive keyword">define</span> LCD_Width   240</span><span class="token macro property">#<span class="token directive keyword">define</span> LCD_Height  240</span><span class="token comment" spellcheck="true">//颜色定义</span><span class="token macro property">#<span class="token directive keyword">define</span> WHITE   0xFFFF    </span><span class="token comment" spellcheck="true">//白色</span><span class="token macro property">#<span class="token directive keyword">define</span> YELLOW  0xFFE0    </span><span class="token comment" spellcheck="true">//黄色</span><span class="token macro property">#<span class="token directive keyword">define</span> BRRED   0XFC07  </span><span class="token comment" spellcheck="true">//棕红色</span><span class="token macro property">#<span class="token directive keyword">define</span> PINK    0XF81F    </span><span class="token comment" spellcheck="true">//粉色</span><span class="token macro property">#<span class="token directive keyword">define</span> RED     0xF800    </span><span class="token comment" spellcheck="true">//红色</span><span class="token macro property">#<span class="token directive keyword">define</span> BROWN   0XBC40  </span><span class="token comment" spellcheck="true">//棕色</span><span class="token macro property">#<span class="token directive keyword">define</span> GRAY    0X8430  </span><span class="token comment" spellcheck="true">//灰色</span><span class="token macro property">#<span class="token directive keyword">define</span> GBLUE   0X07FF    </span><span class="token comment" spellcheck="true">//兰色</span><span class="token macro property">#<span class="token directive keyword">define</span> GREEN   0x07E0    </span><span class="token comment" spellcheck="true">//绿色</span><span class="token macro property">#<span class="token directive keyword">define</span> BLUE    0x001F  </span><span class="token comment" spellcheck="true">//蓝色</span><span class="token macro property">#<span class="token directive keyword">define</span> BLACK   0x0000    </span><span class="token comment" spellcheck="true">//黑色</span></code></pre><p>接下来开始在 <code>lcd_spi2_drv.c</code> 编写驱动程序~</p><h2 id="3-3-封装LCD控制引脚初始化函数"><a href="#3-3-封装LCD控制引脚初始化函数" class="headerlink" title="3.3. 封装LCD控制引脚初始化函数"></a>3.3. 封装LCD控制引脚初始化函数</h2><p>首先包含必要的头文件：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"lcd_spi2_drv.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"gpio.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"spi.h"</span></span></code></pre><p>这个函数只能在本文件内由LCD初始化函数调用，所以使用static修饰为静态的：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** *@brief    LCD控制引脚和通信接口初始化 *@param    none *@retval   none*/</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">LCD_GPIO_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 初始化引脚 */</span>    <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 复位LCD */</span>    <span class="token function">LCD_PWR</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_RST</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_RST</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 初始化SPI2接口 */</span>    <span class="token function">MX_SPI2_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="3-4-封装LCD发送数据和发送命令函数"><a href="#3-4-封装LCD发送数据和发送命令函数" class="headerlink" title="3.4. 封装LCD发送数据和发送命令函数"></a>3.4. 封装LCD发送数据和发送命令函数</h2><p>数据都是由 SPI2 的MOSI发送，由 LCD_WR_RS 引脚指明该数据是命令还是数据。</p><p>首先在 <code>spi.c</code> 的最后调用HAL库封装一个函数，供驱动程序调用：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* USER CODE BEGIN 1 */</span><span class="token comment" spellcheck="true">/** * @brief    SPI 发送字节函数 * @param    TxData    要发送的数据 * @param    size    发送数据的字节大小 * @return  0:写入成功,其他:写入失败 */</span>uint8_t <span class="token function">SPI_WriteByte</span><span class="token punctuation">(</span>uint8_t <span class="token operator">*</span>TxData<span class="token punctuation">,</span>uint16_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">HAL_SPI_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hspi2<span class="token punctuation">,</span>TxData<span class="token punctuation">,</span>size<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* USER CODE END 1 */</span></code></pre><blockquote><p>不要忘了在spi.h中声明该函数！</p></blockquote><p>然后基于spi发送字节函数，在<strong>驱动文件中</strong>继续封装一个向LCD发送数据的函数，一个向LCD发送命令的函数：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief   写命令到LCD * @param   cmd —— 需要发送的命令 * @return  none */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">LCD_Write_Cmd</span><span class="token punctuation">(</span>uint8_t cmd<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">LCD_WR_RS</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SPI_WriteByte</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cmd<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * @brief   写数据到LCD * @param   dat —— 需要发送的数据 * @return  none */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span>uint8_t dat<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">LCD_WR_RS</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SPI_WriteByte</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dat<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="4-编写LCD驱动（ST7789）——-对照datasheet编程"><a href="#4-编写LCD驱动（ST7789）——-对照datasheet编程" class="headerlink" title="4. 编写LCD驱动（ST7789）—— 对照datasheet编程"></a>4. 编写LCD驱动（ST7789）—— 对照datasheet编程</h1><h2 id="4-1-打开-关闭背光函数"><a href="#4-1-打开-关闭背光函数" class="headerlink" title="4.1. 打开/关闭背光函数"></a>4.1. 打开/关闭背光函数</h2><p>这两个函数比较简单，直接调用控制LCD背光的引脚控制宏即可：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @breif   打开LCD显示背光 * @param   none * @return  none */</span><span class="token keyword">void</span> <span class="token function">LCD_DisplayOn</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">LCD_PWR</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * @brief   关闭LCD显示背光 * @param   none * @return  none */</span><span class="token keyword">void</span> <span class="token function">LCD_DisplayOff</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">LCD_PWR</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="4-2-指定显示RAM操作地址"><a href="#4-2-指定显示RAM操作地址" class="headerlink" title="4.2. 指定显示RAM操作地址"></a>4.2. 指定显示RAM操作地址</h2><p>根据数据手册，当要改变某个区域像素点的颜色时，首先应该确定X方向起始地址和X方向结束地址：</p><p><img src="http://mculover666.cn/image/20190829/SfifEyv85boN.png?imageslim" alt="mark"></p><p>然后确定Y方向起始地址和Y方向结束地址：</p><p><img src="http://mculover666.cn/image/20190829/zMRTyBS1Vv9j.png?imageslim" alt="mark"></p><p>最后再确定该区域内每个像素点的值(16bit)：</p><p><img src="http://mculover666.cn/image/20190829/0CfYcB8Xj56X.png?imageslim" alt="mark"></p><p>综上，我们每次操作的时候都需要指定操作区域，所以编写该函数：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief   设置数据写入LCD显存区域 * @param   x1,y1    —— 起点坐标 * @param   x2,y2    —— 终点坐标 * @return  none */</span><span class="token keyword">void</span> <span class="token function">LCD_Address_Set</span><span class="token punctuation">(</span>uint16_t x1<span class="token punctuation">,</span> uint16_t y1<span class="token punctuation">,</span> uint16_t x2<span class="token punctuation">,</span> uint16_t y2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 指定X方向操作区域 */</span>    <span class="token function">LCD_Write_Cmd</span><span class="token punctuation">(</span><span class="token number">0x2a</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span>x1 <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span>x2 <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span>x2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 指定Y方向操作区域 */</span>    <span class="token function">LCD_Write_Cmd</span><span class="token punctuation">(</span><span class="token number">0x2b</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span>y1 <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span>y1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span>y2 <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span>y2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 发送该命令，LCD开始等待接收显存数据 */</span>    <span class="token function">LCD_Write_Cmd</span><span class="token punctuation">(</span><span class="token number">0x2C</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="4-3-清屏函数"><a href="#4-3-清屏函数" class="headerlink" title="4.3. 清屏函数"></a>4.3. 清屏函数</h2><p>编写完指定显存操作区域后，趁热打铁，编写清屏函数就很简单啦，直接调用上面编写的函数，指定操作地址为全屏幕，然后循环发送颜色值即可：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> LCD_TOTAL_BUF_SIZE    (240*240*2)</span><span class="token macro property">#<span class="token directive keyword">define</span> LCD_Buf_Size 1152</span><span class="token keyword">static</span> uint8_t lcd_buf<span class="token punctuation">[</span>LCD_Buf_Size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @brief   以一种颜色清空LCD屏 * @param   color —— 清屏颜色(16bit) * @return  none */</span><span class="token keyword">void</span> <span class="token function">LCD_Clear</span><span class="token punctuation">(</span>uint16_t color<span class="token punctuation">)</span><span class="token punctuation">{</span>    uint16_t i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    uint8_t data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//color是16bit的，每个像素点需要两个字节的显存</span>    <span class="token comment" spellcheck="true">/* 将16bit的color值分开为两个单独的字节 */</span>    data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> color <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">;</span>    data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> color<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 显存的值需要逐字节写入 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> LCD_Buf_Size <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        lcd_buf<span class="token punctuation">[</span>j <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span>  data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        lcd_buf<span class="token punctuation">[</span>j <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span>  data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* 指定显存操作地址为全屏幕 */</span>    <span class="token function">LCD_Address_Set</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> LCD_Width <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> LCD_Height <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 指定接下来的数据为数据 */</span>    <span class="token function">LCD_WR_RS</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 将显存缓冲区的数据全部写入缓冲区 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span>LCD_TOTAL_BUF_SIZE <span class="token operator">/</span> LCD_Buf_Size<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">SPI_WriteByte</span><span class="token punctuation">(</span>lcd_buf<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint16_t<span class="token punctuation">)</span>LCD_Buf_Size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="4-4-LCD初始化函数"><a href="#4-4-LCD初始化函数" class="headerlink" title="4.4. LCD初始化函数"></a>4.4. LCD初始化函数</h2><p>至此，LCD的一些操作函数全部编写完成，最后编写初始化LCD模式的函数：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief   LCD初始化 * @param   none * @return  none */</span><span class="token keyword">void</span> <span class="token function">LCD_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 初始化和LCD通信的引脚 */</span>    <span class="token function">LCD_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 关闭睡眠模式 */</span>    <span class="token function">LCD_Write_Cmd</span><span class="token punctuation">(</span><span class="token number">0x11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 开始设置显存扫描模式，数据格式等 */</span>    <span class="token function">LCD_Write_Cmd</span><span class="token punctuation">(</span><span class="token number">0x36</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x00</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* RGB 5-6-5-bit格式  */</span>    <span class="token function">LCD_Write_Cmd</span><span class="token punctuation">(</span><span class="token number">0x3A</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x65</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* porch 设置 */</span>    <span class="token function">LCD_Write_Cmd</span><span class="token punctuation">(</span><span class="token number">0xB2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x0C</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x0C</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x00</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x33</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x33</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* VGH设置 */</span>    <span class="token function">LCD_Write_Cmd</span><span class="token punctuation">(</span><span class="token number">0xB7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x72</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* VCOM 设置 */</span>    <span class="token function">LCD_Write_Cmd</span><span class="token punctuation">(</span><span class="token number">0xBB</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x3D</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* LCM 设置 */</span>    <span class="token function">LCD_Write_Cmd</span><span class="token punctuation">(</span><span class="token number">0xC0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x2C</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* VDV and VRH 设置 */</span>    <span class="token function">LCD_Write_Cmd</span><span class="token punctuation">(</span><span class="token number">0xC2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* VRH 设置 */</span>    <span class="token function">LCD_Write_Cmd</span><span class="token punctuation">(</span><span class="token number">0xC3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* VDV 设置 */</span>    <span class="token function">LCD_Write_Cmd</span><span class="token punctuation">(</span><span class="token number">0xC4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 普通模式下显存速率设置 60Mhz */</span>    <span class="token function">LCD_Write_Cmd</span><span class="token punctuation">(</span><span class="token number">0xC6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x0F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 电源控制 */</span>    <span class="token function">LCD_Write_Cmd</span><span class="token punctuation">(</span><span class="token number">0xD0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0xA4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0xA1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 电压设置 */</span>    <span class="token function">LCD_Write_Cmd</span><span class="token punctuation">(</span><span class="token number">0xE0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0xD0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x04</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x0D</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x2B</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x3F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x54</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x4C</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x0D</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x0B</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x1F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 电压设置 */</span>    <span class="token function">LCD_Write_Cmd</span><span class="token punctuation">(</span><span class="token number">0xE1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0xD0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x04</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x0C</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x2C</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x3F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x44</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x51</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x2F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x1F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x1F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Data</span><span class="token punctuation">(</span><span class="token number">0x23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 显示开 */</span>    <span class="token function">LCD_Write_Cmd</span><span class="token punctuation">(</span><span class="token number">0x21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LCD_Write_Cmd</span><span class="token punctuation">(</span><span class="token number">0x29</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 清屏为白色 */</span>    <span class="token function">LCD_Clear</span><span class="token punctuation">(</span>WHITE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*打开显示*/</span>    <span class="token function">LCD_PWR</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>至此，驱动编写完成。</p><h1 id="5-测试驱动程序"><a href="#5-测试驱动程序" class="headerlink" title="5. 测试驱动程序"></a>5. 测试驱动程序</h1><p>在 <code>main函数</code> 中编写驱动测试代码，在 <code>while(1)</code> 之前添加如下代码：</p><pre class=" language-c"><code class="language-c">  <span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span>  <span class="token function">LCD_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">LCD_Clear</span><span class="token punctuation">(</span>GREEN<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* USER CODE END 2 */</span></code></pre><p>测试结果如图：</p><p><img src="http://mculover666.cn/image/20190829/2rf6XcYSMCAE.png?imageslim" alt="mark"></p><p>绿绿的，是不是很好看哈哈(斜眼笑.jpg)~</p><p>至此，我们已经学会<strong>如何使用硬件SPI驱动LCD屏幕（ST7789）</strong>，下一节将讲述如何使用硬件QSPI接口读写SPI Flash的数据。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX TFT-LCD SPI总线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何通俗的理解CRC校验并用C语言实现</title>
      <link href="/posts/1935373145/"/>
      <url>/posts/1935373145/</url>
      
        <content type="html"><![CDATA[<p>本篇文章通俗的讲解了何谓CRC？如何生成CRC码以及如何使用CRC码校验，最后采用<strong>多种思路</strong>用C语言实现CRC校验。</p><p><img src="http://mculover666.cn/image/20190829/a5uVezmqAgdw.png?imageslim" alt="mark"></p><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在研究温湿度传感器SHT30，该传感器使用IIC接口进行通信，在读取数据时，该传感器<strong>分别</strong>在发送 <code>16bit</code> 的温度和湿度数据后，发送了 <code>8bit</code> 的CRC校验数据，如图所示：</p><p><img src="http://mculover666.cn/image/20190808/OiN41VkYPDat.png?imageslim" alt="mark"></p><p>那么，问题来了：</p><ul><li><strong>CRC是个什么东东？</strong></li><li><strong>如何计算得到CRC码？</strong></li><li><strong>如何使用CRC码校验？</strong></li><li><strong>如何用C语言实现该CRC校验？</strong></li></ul><h1 id="CRC到底是个什么东东"><a href="#CRC到底是个什么东东" class="headerlink" title="CRC到底是个什么东东"></a>CRC到底是个什么东东</h1><p>CRC学名叫做<strong>循环冗余校验</strong>，全称 <code>cyclic redundancy check</code>，这个词有两个含义：</p><ul><li>循环冗余校验<strong>功能</strong>：对要传送的数据进行多项式计算，并将所得结果跟着传送数据后发送，接收端再次进行校验；</li><li>循环冗余校验<strong>码</strong>：对要传送的数据进行多项式计算后得到的值称为循环冗余校验码。</li></ul><p>等等，好像跑题了，这个是官方解释，那么，我们该如何通俗的理解呢？接下里我带领大家在实战中领悟CRC的奥秘~</p><h1 id="计算CRC码之前的准备工作"><a href="#计算CRC码之前的准备工作" class="headerlink" title="计算CRC码之前的准备工作"></a>计算CRC码之前的准备工作</h1><h2 id="关键点1-——-模2除法"><a href="#关键点1-——-模2除法" class="headerlink" title="关键点1 —— 模2除法"></a>关键点1 —— 模2除法</h2><p>在CRC校验规则中，原始数据与给定的除数之间进行<strong>模2除法</strong>得到CRC码，发送端将原始数据和CRC码一起传送到接收端，接收端再</p><p>那么，模2除法的规则是怎样的呢？它和普通除法有什么不一样的呢？</p><p>模2除法与普通的算术除法类似，但是它有两个区别：</p><ul><li>不向上借位；</li><li>不比较除数和被除数的相同位数值的大小，只要以相同位数进行相除即可；</li></ul><p>所以在模2除法中二进制运算结果如下：</p><ul><li>1 - 1 = 0</li><li>1 - 0 = 1</li><li>0 - 1 = 1</li><li>0 - 0 = 1</li></ul><p>乍一看，这个运算规则是不是似曾相识~这就是我们熟悉的<strong>异或运算</strong>，可以总结出“模2除法”的规则：</p><pre><code>模2除法不借位，相同位置用异或。</code></pre><p>”最后用一个例子演示一下“模2除法”：</p><p><img src="http://mculover666.cn/image/20190808/cvO25i2jnBFf.png?imageslim" alt="mark"></p><h2 id="关键点2-——-确定“生成多项式”"><a href="#关键点2-——-确定“生成多项式”" class="headerlink" title="关键点2 —— 确定“生成多项式”"></a>关键点2 —— 确定“生成多项式”</h2><p>生成多项式既确定了如何改造原始数据作为被除数，也确定了除数，还确定了CRC码的位数，是整个CRC码生成过程的关键。</p><p>标准的CRC生成多项式如下表：</p><table><thead><tr><th align="center">名称</th><th align="center">生成多项式</th><th align="center">简记式</th></tr></thead><tbody><tr><td align="center">CRC-4</td><td align="center">x4+x+1</td><td align="center">3</td></tr><tr><td align="center">CRC-8</td><td align="center">x8+x5+x4+1</td><td align="center">0x31</td></tr><tr><td align="center">CRC-8</td><td align="center">x8+x2+x1+1</td><td align="center">0x07</td></tr><tr><td align="center">CRC-8</td><td align="center">x8+x6+x4+x3+x2+x1</td><td align="center">0x5E</td></tr><tr><td align="center">CRC-12</td><td align="center">x12+x11+x3+x+1</td><td align="center">0x80F</td></tr><tr><td align="center">CRC-16</td><td align="center">x16+x15+x2+1</td><td align="center">0x8005</td></tr><tr><td align="center">CRC16-CCITT</td><td align="center">x16+x12+x5+1</td><td align="center">0x1021</td></tr><tr><td align="center">CRC-32</td><td align="center">x32+x26+x23+…+x2+x+1</td><td align="center">0x04C11DB7</td></tr><tr><td align="center">CRC-32c</td><td align="center">x32+x28+x27+…+x8+x6+1</td><td align="center">0x1EDC6F41</td></tr></tbody></table><h1 id="（发送方）如何计算CRC码"><a href="#（发送方）如何计算CRC码" class="headerlink" title="（发送方）如何计算CRC码"></a>（发送方）如何计算CRC码</h1><p>假设选择的CRC生成多项式为：<br>$$<br>G(X) = X^4 + X^3 + 1<br>$$<br>要求：请写出二进制序列10110011的CRC校验码。</p><p>计算过程如下：</p><h2 id="1-将生成多项式转换成二进制数"><a href="#1-将生成多项式转换成二进制数" class="headerlink" title="1.将生成多项式转换成二进制数"></a>1.将生成多项式转换成二进制数</h2><ul><li>二进制数的总位数 = 最高位的幂次 + 1</li><li>多项式中只列出二进制值为1的位</li></ul><p>根据这个规则可以得到，该生成多项式$G(X)$对应的二进制数总共有 5 位（4+1），其中第 4 位、第 3 位、第 0 位的二进制值为1，其它位均为0，所以该生成多项式的二进制为： <code>11001</code>。</p><h2 id="2-根据生成多项式确定除数"><a href="#2-根据生成多项式确定除数" class="headerlink" title="2.根据生成多项式确定除数"></a>2.根据生成多项式确定除数</h2><p>除数就是生成多项式的二进制数，所以除数为：<code>11001</code>。</p><h2 id="3-根据生成多项式确定被除数和CRC码的位数"><a href="#3-根据生成多项式确定被除数和CRC码的位数" class="headerlink" title="3.根据生成多项式确定被除数和CRC码的位数"></a>3.根据生成多项式确定被除数和CRC码的位数</h2><ul><li>CRC码的位数 = 生成多项式的二进制位数 - 1</li></ul><p>根据之前转换的生成多项式的二进制位数，CRC码的位数为：<code>5 - 1 = 4</code>位。</p><p>在原始数据后加上 <code>CRC码的位数</code> 个0，作为被除数，即：<code>101100110000</code>。</p><h2 id="4-使用模2除法计算CRC码"><a href="#4-使用模2除法计算CRC码" class="headerlink" title="4.使用模2除法计算CRC码"></a>4.使用模2除法计算CRC码</h2><p>除数确定了，被除数也确定了，CRC码的位数也确定了，万事具备，只欠东风，接下来请出我们的“模2除法”，开始计算CRC码：</p><p><img src="http://mculover666.cn/image/20190808/r9MOz2k23mjY.png?imageslim" alt="mark"></p><p>由图上的计算过程可知，得到的CRC码为： <code>0100</code>。</p><h1 id="接收方-如何使用CRC码校验数据"><a href="#接收方-如何使用CRC码校验数据" class="headerlink" title="(接收方)如何使用CRC码校验数据"></a>(接收方)如何使用CRC码校验数据</h1><p>接收方接收到原始数据<code>10110011</code>和CRC校验码<code>0100</code>后，校验数据是否正确的方法如下：</p><h2 id="1-获取发送方所使用的生成多项式"><a href="#1-获取发送方所使用的生成多项式" class="headerlink" title="1.获取发送方所使用的生成多项式"></a>1.获取发送方所使用的生成多项式</h2><p>接收方首先要获取发送方所使用的生成多项式，然后<strong>使用该生成多项式的二进制数确定除数</strong>，即：<code>11001</code>。</p><h2 id="2-根据接收到的数据和CRC码确定被除数"><a href="#2-根据接收到的数据和CRC码确定被除数" class="headerlink" title="2.根据接收到的数据和CRC码确定被除数"></a>2.根据接收到的数据和CRC码确定被除数</h2><p>将接收到的数据和CRC码拼接起来，作为被除数，这里为：<code>101100110100</code>。</p><h2 id="3-使用模2除法校验数据正确性"><a href="#3-使用模2除法校验数据正确性" class="headerlink" title="3.使用模2除法校验数据正确性"></a>3.使用模2除法校验数据正确性</h2><p>除数确定了，被除数也确定了，接下来再次使用“模2除法”校验：</p><p><img src="http://mculover666.cn/image/20190808/S3BJImRSXHbz.png?imageslim" alt="mark"></p><p>由图上的计算过程可知，校验得到的余数为<code>0</code>，接收结果：正确！</p><p><strong>一旦接收数据和接收的CRC码中有一位改变，则计算结果余数不为0，校验失败。</strong></p><h1 id="使用C语言实现CRC校验"><a href="#使用C语言实现CRC校验" class="headerlink" title="使用C语言实现CRC校验"></a>使用C语言实现CRC校验</h1><h2 id="算法1-——-按位校验思想"><a href="#算法1-——-按位校验思想" class="headerlink" title="算法1 —— 按位校验思想"></a>算法1 —— 按位校验思想</h2><h3 id="CRC4"><a href="#CRC4" class="headerlink" title="CRC4"></a>CRC4</h3><p>对于简单的CRC-4，实现代码如下：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> CRC4_POLYNOMIAL 0xC8   </span><span class="token comment" spellcheck="true">/* 11011后面补0凑8位数：11011000*/</span>uint8_t <span class="token function">CheckCrc4</span><span class="token punctuation">(</span>uint8_t <span class="token keyword">const</span> message<span class="token punctuation">)</span><span class="token punctuation">{</span>    uint8_t  remainder<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//余数</span>    uint8_t  i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//循环变量</span>    <span class="token comment" spellcheck="true">/* 初始化，余数=原始数据 */</span>    remainder <span class="token operator">=</span> message<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 从最高位开始依次计算  */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>remainder <span class="token operator">&amp;</span> <span class="token number">0x80</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            remainder <span class="token operator">^</span><span class="token operator">=</span> POLYNOMIAL<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        remainder <span class="token operator">=</span> <span class="token punctuation">(</span>remainder <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* 返回计算的CRC码 */</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>remainder <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>测试代码如下：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    uint8_t dat <span class="token operator">=</span> <span class="token number">0xB3</span><span class="token punctuation">;</span>    uint8_t crc <span class="token operator">=</span> <span class="token function">CheckCrc4</span><span class="token punctuation">(</span>dat<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"crc = %#x\n"</span><span class="token punctuation">,</span> crc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>crc <span class="token operator">==</span> <span class="token number">0x4</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ok.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fail.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行结果如下：</p><p><img src="http://mculover666.cn/image/20190809/LcGji03UtDJ9.png?imageslim" alt="mark"></p><h3 id="CRC8"><a href="#CRC8" class="headerlink" title="CRC8"></a>CRC8</h3><p>根据一个字节数据的CRC校验实现思想，两个字节或多个字节的数据也是同样的道理，加一层循环就可以了，代码实现如下：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> CRC8_POLYNOMIAL 0x31</span>uint8_t <span class="token function">CheckCrc8</span><span class="token punctuation">(</span>uint8_t<span class="token operator">*</span> <span class="token keyword">const</span> message<span class="token punctuation">,</span> uint8_t initial_value<span class="token punctuation">)</span><span class="token punctuation">{</span>    uint8_t  remainder<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//余数</span>    uint8_t  i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//循环变量</span>    <span class="token comment" spellcheck="true">/* 初始化 */</span>    remainder <span class="token operator">=</span> initial_value<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        remainder <span class="token operator">^</span><span class="token operator">=</span> message<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 从最高位开始依次计算  */</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>remainder <span class="token operator">&amp;</span> <span class="token number">0x80</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                remainder <span class="token operator">=</span> <span class="token punctuation">(</span>remainder <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">^</span>CRC8_POLYNOMIAL<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                remainder <span class="token operator">=</span> <span class="token punctuation">(</span>remainder <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* 返回计算的CRC码 */</span>    <span class="token keyword">return</span> remainder<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>接下来用最开始在背景中提出的问题进行检，SHT30传感器的数据手册中给出了它计算CRC的生成多项式和初始值，并给出了一个示例，如图：</p><p><img src="http://mculover666.cn/image/20190809/wtLIFxbSLyon.png?imageslim" alt="mark"></p><p>接下来我们使用示例测试一下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> dat<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0xBE</span><span class="token punctuation">,</span><span class="token number">0xEF</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    uint8_t crc <span class="token operator">=</span> <span class="token function">CheckCrc8</span><span class="token punctuation">(</span>dat<span class="token punctuation">,</span> <span class="token number">0xFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"crc = %#x\n"</span><span class="token punctuation">,</span> crc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>crc <span class="token operator">==</span> <span class="token number">0x92</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ok.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fail.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>测试结果如下：</p><p><img src="http://mculover666.cn/image/20190809/VXPkJUIakUWH.png?imageslim" alt="mark"></p><h2 id="算法2-——-查表思想"><a href="#算法2-——-查表思想" class="headerlink" title="算法2 —— 查表思想"></a>算法2 —— 查表思想</h2><h3 id="生成表"><a href="#生成表" class="headerlink" title="生成表"></a>生成表</h3><p>首先需要编写一个程序，计算好所有的8位二进制数的CRC校验码，然后将它保存成一个256B大小的数组。</p><p>生成数组的代码如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    uint16_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    uint8_t crc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">256</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        crc <span class="token operator">=</span> <span class="token function">CheckCrc4</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0x%02x, "</span><span class="token punctuation">,</span> crc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">16</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>生成的表如图：</p><p><img src="http://mculover666.cn/image/20190809/ueP7lMrR9bjw.png?imageslim" alt="mark"></p><h3 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h3><p>将这张表保存为一个数组，然后编写新的校验CRC的程序：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span>uint8_t CRC4_TABLE<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//……这里数据太多，省略</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    uint8_t dat <span class="token operator">=</span> <span class="token number">0xB3</span><span class="token punctuation">;</span>    uint8_t crc <span class="token operator">=</span> CRC4_TABLE<span class="token punctuation">[</span>dat<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//直接查表</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"crc = %#x\n"</span><span class="token punctuation">,</span> crc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>crc <span class="token operator">==</span> <span class="token number">0x04</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ok.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fail.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="两种C语言实现方法比较"><a href="#两种C语言实现方法比较" class="headerlink" title="两种C语言实现方法比较"></a>两种C语言实现方法比较</h2><table><thead><tr><th align="center">实现思想</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">按位计算</td><td align="center">占用内存空间极小</td><td align="center">计算速度慢，数据长度大时计算速度会非常慢</td></tr><tr><td align="center">查找表</td><td align="center">计算速度非常快</td><td align="center">占用内存空间大，数据长度大时表会占用非常大的空间</td></tr></tbody></table><h2 id="移植第三方库-——-LibCRC"><a href="#移植第三方库-——-LibCRC" class="headerlink" title="移植第三方库 —— LibCRC"></a>移植第三方库 —— LibCRC</h2><p>CRC的计算确实是一个非常头疼的事情，所以国外有大神开源了一个库专门用于CRC计算 —— LibCRC。</p><p>Libcrc是一个C语言实现的多平台MIT许可CRC库，其官网链接为：<a href="https://www.libcrc.org/" target="_blank" rel="noopener">www.libcrc.org</a>，其Github仓库为：<a href="https://github.com/lammertb/libcrc.git" target="_blank" rel="noopener">LibCRC</a>。</p><p>有兴趣的读者可以移植分享一下~</p><h2 id="使用硬件CRC校验电路"><a href="#使用硬件CRC校验电路" class="headerlink" title="使用硬件CRC校验电路"></a>使用硬件CRC校验电路</h2><p>在STM32L4上有一个专门的CRC校验外设，可以直接使用STM32CubeMX激活CRC校验，然后使用HAL调用进行校验，后续在<code>使用硬件IIC和硬件CRC驱动SHT30</code>这篇文章中会有介绍，敬请期待~</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CRC校验算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_16 | 使用硬件CRC校验数据（以SHT30为例）</title>
      <link href="/posts/842429667/"/>
      <url>/posts/842429667/</url>
      
        <content type="html"><![CDATA[<p>本篇详细的记录了如何使用STM32CubeMX配置STM32L431RCT6的硬件CRC外设校验数据，并用SHT30温湿度传感器为例检查是否可以正确校验。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：</li></ul><p><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt="mark"></p><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li><li>准备一个串口调试助手，这里我使用的是<code>Serial Port Utility</code>；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt="mark"></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：<br><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt="mark"></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:<br><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt="mark"></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：<br><img src="http://mculover666.cn/image/20190806/k593lGGb5tlW.png?imageslim" alt="mark"></p><h2 id="配置串口"><a href="#配置串口" class="headerlink" title="配置串口"></a>配置串口</h2><p>小熊派开发板板载ST-Link并且虚拟了一个串口，原理图如下：</p><p><img src="http://mculover666.cn/image/20190814/IwyXONVefPx9.png?imageslim" alt="mark"></p><p>这里我将开关拨到<code>AT-MCU</code>模式，使PC的串口与USART1之间连接。</p><p>接下来开始配置<code>USART1</code>：</p><p><img src="http://mculover666.cn/image/20190814/nLMRMYtmzghl.png?imageslim" alt="mark"></p><h2 id="配置CRC外设"><a href="#配置CRC外设" class="headerlink" title="配置CRC外设"></a>配置CRC外设</h2><p>首先激活CRC：<br><img src="http://mculover666.cn/image/20190811/AdBDzKeEu9tX.png?imageslim" alt="mark"></p><p>然后配置CRC校验的初始值：</p><p>这里我们以SHT30为例，其数据手册中已给出，如图：</p><p><img src="http://mculover666.cn/image/20190809/wtLIFxbSLyon.png?imageslim" alt="mark"></p><p>据此，CRC外设的配置如下：<br><img src="http://mculover666.cn/image/20190811/GHPasXPYsCiX.png?imageslim" alt="mark"></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：<br><img src="http://mculover666.cn/image/20190806/1TQg7frjRpVr.png?imageslim" alt="mark"></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/image/20190811/8pAljFetp84X.png?imageslim" alt="mark"></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：<br><img src="http://mculover666.cn/image/20190806/T6WvSK6Dfpts.png?imageslim" alt="mark"></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：<br><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt="mark"></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="重定向printf-函数"><a href="#重定向printf-函数" class="headerlink" title="重定向printf( )函数"></a>重定向printf( )函数</h2><p>参考：<a href="https://www.mculover666.cn/2019/07/30/STM32Cube/【STM32Cube-09】重定向printf函数到串口输出的多种方法/">【STM32Cube_09】重定向printf函数到串口输出的多种方法</a>。</p><h2 id="测试CRC校验"><a href="#测试CRC校验" class="headerlink" title="测试CRC校验"></a>测试CRC校验</h2><p>在<code>main.c</code>文件中添加如下代码:</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* USER CODE BEGIN Includes */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token comment" spellcheck="true">/* USER CODE END Includes */</span></code></pre><p>然后修改<code>main</code>函数：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 1 */</span>    uint8_t dat<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0xBE</span><span class="token punctuation">,</span> <span class="token number">0xEF</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    uint8_t crc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* USER CODE END 1 */</span>    <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_CRC_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Test CRC check:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    crc <span class="token operator">=</span> <span class="token function">HAL_CRC_Accumulate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hcrc<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint32_t<span class="token operator">*</span><span class="token punctuation">)</span>dat<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"crc = %#x\n"</span><span class="token punctuation">,</span> crc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* USER CODE END 2 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>测试结果如下：</p><p><img src="http://mculover666.cn/image/20190811/cmbdUIcWEkcQ.png?imageslim" alt="mark"></p><p>至此，我们已经学会<strong>如何使用硬件CRC校验SHT30的数据</strong>，下一节将讲述如何使用硬件SPI驱动LCD屏幕（ST7789）。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX 温湿度传感器 SHT30 CRC校验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_15 | 使用硬件I2C读取温湿度传感器数据（SHT30）</title>
      <link href="/posts/2508748577/"/>
      <url>/posts/2508748577/</url>
      
        <content type="html"><![CDATA[<p>本篇详细的记录了如何使用STM32CubeMX配置STM32L431RCT6的硬件I2C外设，读取SHT30温湿度传感器的数据并通过串口发送。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：</li></ul><p><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt="mark"></p><ul><li>SHT30温湿度传感器<br>SHT30温湿度传感器是一个完全校准的、现行的、带有温度补偿的<strong>数字输出型</strong>传感器，具有 2.4V-5.5V 的宽电压支持，使用IIC接口进行通信，最高速率可达1M并且有两个用户可选地址，除此之外，它还具有8个引脚的DFN超小封装，如图：</li></ul><p><img src="http://mculover666.cn/image/20190808/XthdnB8dTXFW.png?imageslim" alt="mark"></p><p>SHT30的原理图如下：<br><img src="http://mculover666.cn/image/20190808/BSqAexcE2Pir.png?imageslim" alt="mark"></p><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li><li>准备一个串口调试助手，这里我使用的是<code>Serial Port Utility</code>；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt="mark"></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：<br><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt="mark"></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:<br><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt="mark"></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：<br><img src="http://mculover666.cn/image/20190806/k593lGGb5tlW.png?imageslim" alt="mark"></p><h2 id="配置串口"><a href="#配置串口" class="headerlink" title="配置串口"></a>配置串口</h2><p>小熊派开发板板载ST-Link并且虚拟了一个串口，原理图如下：</p><p><img src="http://mculover666.cn/image/20190814/IwyXONVefPx9.png?imageslim" alt="mark"></p><p>这里我将开关拨到<code>AT-MCU</code>模式，使PC的串口与USART1之间连接。</p><p>接下来开始配置<code>USART1</code>：</p><p><img src="http://mculover666.cn/image/20190814/nLMRMYtmzghl.png?imageslim" alt="mark"></p><h2 id="配置I2C接口"><a href="#配置I2C接口" class="headerlink" title="配置I2C接口"></a>配置I2C接口</h2><p>查看小熊派E53接口的原理图：<br><img src="http://mculover666.cn/image/20190808/gHWofMib3ISQ.png?imageslim" alt="mark"></p><p>接下来开始配置I2C接口1：<br><img src="http://mculover666.cn/image/20190808/GuKoTgin8iDJ.png?imageslim" alt="mark"></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：<br><img src="http://mculover666.cn/image/20190806/1TQg7frjRpVr.png?imageslim" alt="mark"></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/image/20190808/vJ8NCpGew9fg.png?imageslim" alt="mark"></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：<br><img src="http://mculover666.cn/image/20190806/T6WvSK6Dfpts.png?imageslim" alt="mark"></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：<br><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt="mark"></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="重定向printf-函数"><a href="#重定向printf-函数" class="headerlink" title="重定向printf( )函数"></a>重定向printf( )函数</h2><p>参考：<a href="https://www.mculover666.cn/2019/07/30/STM32Cube/【STM32Cube-09】重定向printf函数到串口输出的多种方法/">【STM32Cube_09】重定向printf函数到串口输出的多种方法</a>。</p><h2 id="修改I2C初始化代码的小BUG"><a href="#修改I2C初始化代码的小BUG" class="headerlink" title="修改I2C初始化代码的小BUG"></a>修改I2C初始化代码的小BUG</h2><p><img src="http://mculover666.cn/image/20190808/zGOS6y9hjXhu.png?imageslim" alt="mark"></p><h1 id="4-编写SHT30驱动程序"><a href="#4-编写SHT30驱动程序" class="headerlink" title="4. 编写SHT30驱动程序"></a>4. 编写SHT30驱动程序</h1><p>参考<a href="https://download.csdn.net/download/mculover666/11368379" target="_blank" rel="noopener">SHT30数据手册.pdf</a>进行编程。</p><h2 id="宏定义SHT30器件地址"><a href="#宏定义SHT30器件地址" class="headerlink" title="宏定义SHT30器件地址"></a>宏定义SHT30器件地址</h2><p>先来编写<code>sht30_i2c_drv.h</code>头文件，SHT30的器件地址由<code>ADDR</code>端口的高低电平决定：</p><p><img src="http://mculover666.cn/image/20190808/mYPfGe7jdXS3.png?imageslim" alt="mark"></p><p>注意数据手册中给出了8位数据，只有低7位用作地址，结合原理图，可以定义如下：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* ADDR Pin Conect to VSS */</span><span class="token macro property">#<span class="token directive keyword">define</span>    SHT30_ADDR_WRITE    0x44&lt;&lt;1         </span><span class="token comment" spellcheck="true">//10001000</span><span class="token macro property">#<span class="token directive keyword">define</span>    SHT30_ADDR_READ        (0x44&lt;&lt;1)+1        </span><span class="token comment" spellcheck="true">//10001011</span></code></pre><h2 id="枚举SHT30命令列表"><a href="#枚举SHT30命令列表" class="headerlink" title="枚举SHT30命令列表"></a>枚举SHT30命令列表</h2><p>参考数据手册，在<code>sht30_i2c_drv.h</code>头文件中给出如下枚举定义：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">enum</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 软件复位命令 */</span>    SOFT_RESET_CMD <span class="token operator">=</span> <span class="token number">0x30A2</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">/*    单次测量模式    命名格式：Repeatability_CS_CMD    CS： Clock stretching    */</span>    HIGH_ENABLED_CMD    <span class="token operator">=</span> <span class="token number">0x2C06</span><span class="token punctuation">,</span>    MEDIUM_ENABLED_CMD  <span class="token operator">=</span> <span class="token number">0x2C0D</span><span class="token punctuation">,</span>    LOW_ENABLED_CMD     <span class="token operator">=</span> <span class="token number">0x2C10</span><span class="token punctuation">,</span>    HIGH_DISABLED_CMD   <span class="token operator">=</span> <span class="token number">0x2400</span><span class="token punctuation">,</span>    MEDIUM_DISABLED_CMD <span class="token operator">=</span> <span class="token number">0x240B</span><span class="token punctuation">,</span>    LOW_DISABLED_CMD    <span class="token operator">=</span> <span class="token number">0x2416</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/*    周期测量模式    命名格式：Repeatability_MPS_CMD    MPS：measurement per second    */</span>    HIGH_0_5_CMD   <span class="token operator">=</span> <span class="token number">0x2032</span><span class="token punctuation">,</span>    MEDIUM_0_5_CMD <span class="token operator">=</span> <span class="token number">0x2024</span><span class="token punctuation">,</span>    LOW_0_5_CMD    <span class="token operator">=</span> <span class="token number">0x202F</span><span class="token punctuation">,</span>    HIGH_1_CMD     <span class="token operator">=</span> <span class="token number">0x2130</span><span class="token punctuation">,</span>    MEDIUM_1_CMD   <span class="token operator">=</span> <span class="token number">0x2126</span><span class="token punctuation">,</span>    LOW_1_CMD      <span class="token operator">=</span> <span class="token number">0x212D</span><span class="token punctuation">,</span>    HIGH_2_CMD     <span class="token operator">=</span> <span class="token number">0x2236</span><span class="token punctuation">,</span>    MEDIUM_2_CMD   <span class="token operator">=</span> <span class="token number">0x2220</span><span class="token punctuation">,</span>    LOW_2_CMD      <span class="token operator">=</span> <span class="token number">0x222B</span><span class="token punctuation">,</span>    HIGH_4_CMD     <span class="token operator">=</span> <span class="token number">0x2334</span><span class="token punctuation">,</span>    MEDIUM_4_CMD   <span class="token operator">=</span> <span class="token number">0x2322</span><span class="token punctuation">,</span>    LOW_4_CMD      <span class="token operator">=</span> <span class="token number">0x2329</span><span class="token punctuation">,</span>    HIGH_10_CMD    <span class="token operator">=</span> <span class="token number">0x2737</span><span class="token punctuation">,</span>    MEDIUM_10_CMD  <span class="token operator">=</span> <span class="token number">0x2721</span><span class="token punctuation">,</span>    LOW_10_CMD     <span class="token operator">=</span> <span class="token number">0x272A</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* 周期测量模式读取数据命令 */</span>    READOUT_FOR_PERIODIC_MODE <span class="token operator">=</span> <span class="token number">0xE000</span><span class="token punctuation">,</span><span class="token punctuation">}</span> SHT30_CMD<span class="token punctuation">;</span></code></pre><h2 id="发送命令函数"><a href="#发送命令函数" class="headerlink" title="发送命令函数"></a>发送命令函数</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief    向SHT30发送一条指令(16bit) * @param    cmd —— SHT30指令（在SHT30_MODE中枚举定义） * @retval    成功返回HAL_OK*/</span><span class="token keyword">static</span> uint8_t    <span class="token function">SHT30_Send_Cmd</span><span class="token punctuation">(</span>SHT30_CMD cmd<span class="token punctuation">)</span><span class="token punctuation">{</span>    uint8_t cmd_buffer<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    cmd_buffer<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> cmd <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">;</span>    cmd_buffer<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> cmd<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">HAL_I2C_Master_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hi2c1<span class="token punctuation">,</span> SHT30_ADDR_WRITE<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint8_t<span class="token operator">*</span> cmd_buffer<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="复位函数"><a href="#复位函数" class="headerlink" title="复位函数"></a>复位函数</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief    复位SHT30 * @param    none * @retval    none*/</span><span class="token keyword">void</span> <span class="token function">SHT30_reset</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">SHT30_Send_Cmd</span><span class="token punctuation">(</span>SOFT_RESET_CMD<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="SHT30工作模式初始化函数（周期测量模式）"><a href="#SHT30工作模式初始化函数（周期测量模式）" class="headerlink" title="SHT30工作模式初始化函数（周期测量模式）"></a>SHT30工作模式初始化函数（周期测量模式）</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief    初始化SHT30 * @param    none * @retval    成功返回HAL_OK * @note    周期测量模式*/</span>uint8_t <span class="token function">SHT30_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">SHT30_Send_Cmd</span><span class="token punctuation">(</span>MEDIUM_2_CMD<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="从SHTY30读取一次数据（周期测量模式下）"><a href="#从SHTY30读取一次数据（周期测量模式下）" class="headerlink" title="从SHTY30读取一次数据（周期测量模式下）"></a>从SHTY30读取一次数据（周期测量模式下）</h2><p>从SHT30数据手册中可以得到在周期测量模式下读取一次数据的时序，如图：</p><p><img src="http://mculover666.cn/image/20190810/et530Xi83sku.png?imageslim" alt="mark"></p><p>根据该时序可以看出，首先要发送读数据的命令，然后接收6个字节的数据，编写程序如下：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief    从SHT30读取一次数据 * @param    dat —— 存储读取数据的地址（6个字节数组） * @retval    成功 —— 返回HAL_OK*/</span>uint8_t <span class="token function">SHT30_Read_Dat</span><span class="token punctuation">(</span>uint8_t<span class="token operator">*</span> dat<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">SHT30_Send_Cmd</span><span class="token punctuation">(</span>READOUT_FOR_PERIODIC_MODE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">HAL_I2C_Master_Receive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hi2c1<span class="token punctuation">,</span> SHT30_ADDR_READ<span class="token punctuation">,</span> dat<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="从接收数据中校验并解析温度值和湿度值"><a href="#从接收数据中校验并解析温度值和湿度值" class="headerlink" title="从接收数据中校验并解析温度值和湿度值"></a>从接收数据中校验并解析温度值和湿度值</h2><p>在数据手册中可知，SHT30分别在温度数据和湿度数据之后发送了8-CRC校验码，确保了数据可靠性。</p><p>关于CRC校验请参考我的另一篇博客：<a href="https://www.mculover666.cn/2019/08/09/%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%97%E7%9A%84%E7%90%86%E8%A7%A3CRC%E6%A0%A1%E9%AA%8C%E5%B9%B6%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/">如何通俗的理解CRC校验并用C语言实现</a>。</p><p>CRC-8校验程序如下：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> CRC8_POLYNOMIAL 0x31</span>uint8_t <span class="token function">CheckCrc8</span><span class="token punctuation">(</span>uint8_t<span class="token operator">*</span> <span class="token keyword">const</span> message<span class="token punctuation">,</span> uint8_t initial_value<span class="token punctuation">)</span><span class="token punctuation">{</span>    uint8_t  remainder<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//余数</span>    uint8_t  i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//循环变量</span>    <span class="token comment" spellcheck="true">/* 初始化 */</span>    remainder <span class="token operator">=</span> initial_value<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        remainder <span class="token operator">^</span><span class="token operator">=</span> message<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 从最高位开始依次计算  */</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>remainder <span class="token operator">&amp;</span> <span class="token number">0x80</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                remainder <span class="token operator">=</span> <span class="token punctuation">(</span>remainder <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">^</span>CRC8_POLYNOMIAL<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                remainder <span class="token operator">=</span> <span class="token punctuation">(</span>remainder <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* 返回计算的CRC码 */</span>    <span class="token keyword">return</span> remainder<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>计算温度值和湿度值的公式在数据手册中已给出，如图：</p><p><img src="http://mculover666.cn/image/20190810/akji0RTvX77c.png?imageslim" alt="mark"></p><p>接下来编写解析数据的函数：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief    将SHT30接收的6个字节数据进行CRC校验，并转换为温度值和湿度值 * @param    dat  —— 存储接收数据的地址（6个字节数组） * @retval    校验成功  —— 返回0 *             校验失败  —— 返回1，并设置温度值和湿度值为0*/</span>uint8_t <span class="token function">SHT30_Dat_To_Float</span><span class="token punctuation">(</span>uint8_t<span class="token operator">*</span> <span class="token keyword">const</span> dat<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">*</span> temperature<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">*</span> humidity<span class="token punctuation">)</span><span class="token punctuation">{</span>    uint16_t recv_temperature <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    uint16_t recv_humidity <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 校验温度数据和湿度数据是否接收正确 */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">CheckCrc8</span><span class="token punctuation">(</span>dat<span class="token punctuation">,</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> <span class="token operator">!=</span> dat<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token function">CheckCrc8</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dat<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> <span class="token operator">!=</span> dat<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 转换温度数据 */</span>    recv_temperature <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint16_t<span class="token punctuation">)</span>dat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">|</span>dat<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">*</span>temperature <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">45</span> <span class="token operator">+</span> <span class="token number">175</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>recv_temperature<span class="token operator">/</span><span class="token number">65535</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 转换湿度数据 */</span>    recv_humidity <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint16_t<span class="token punctuation">)</span>dat<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">|</span>dat<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">*</span>humidity <span class="token operator">=</span> <span class="token number">100</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>recv_humidity <span class="token operator">/</span> <span class="token number">65535</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="5-测试SHT30驱动程序"><a href="#5-测试SHT30驱动程序" class="headerlink" title="5. 测试SHT30驱动程序"></a>5. 测试SHT30驱动程序</h1><p>在main函数中对该驱动进行测试，在<code>main.c</code>中添加如下代码：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"sht30_i2c_drv.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 1 */</span>    uint8_t recv_dat<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> temperature <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> humidity <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* USER CODE END 1 */</span>    <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_I2C1_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span>    <span class="token function">SHT30_Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">SHT30_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> HAL_OK<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sht30 init ok.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sht30 init fail.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* USER CODE END 2 */</span>  <span class="token comment" spellcheck="true">/* Infinite loop */</span>  <span class="token comment" spellcheck="true">/* USER CODE BEGIN WHILE */</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* USER CODE END WHILE */</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 3 */</span>        <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">SHT30_Read_Dat</span><span class="token punctuation">(</span>recv_dat<span class="token punctuation">)</span> <span class="token operator">==</span> HAL_OK<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">SHT30_Dat_To_Float</span><span class="token punctuation">(</span>recv_dat<span class="token punctuation">,</span> <span class="token operator">&amp;</span>temperature<span class="token punctuation">,</span> <span class="token operator">&amp;</span>humidity<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"temperature = %f, humidity = %f\n"</span><span class="token punctuation">,</span> temperature<span class="token punctuation">,</span> humidity<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"crc check fail.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read data from sht30 fail.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* USER CODE END 3 */</span><span class="token punctuation">}</span></code></pre><p>测试结果如图：</p><p><img src="http://mculover666.cn/image/20190810/vlDKzTOJ8cBE.png?imageslim" alt="mark"></p><p>至此，我们已经学会<strong>如何使用硬件IIC接口读取温湿度传感器数据并使用软件CRC校验（SHT30）</strong>，下一节将讲述如何使用硬件CRC校验SHT30的数据。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX 温湿度传感器 SHT30 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_14 | 使用硬件I2C读写环境光强度传感器（BH1750）</title>
      <link href="/posts/1561092257/"/>
      <url>/posts/1561092257/</url>
      
        <content type="html"><![CDATA[<p>本篇详细的记录了如何使用STM32CubeMX配置STM32L431RCT6的硬件I2C外设读取环境光强度传感器数据（BH1750）。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：</li></ul><p><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt="mark"></p><ul><li>BH1750模块<br>BH1750FV1是两线式串行总线接口（IIC）的16位数字输出型环境光强度传感器，利用它的高分辨率可以探测较大范围内的光照强度变化（1lx - 65535lx）。</li></ul><p><img src="http://mculover666.cn/image/20190827/gDUPbgs5suTo.png?imageslim" alt="mark"></p><p>BH1750的原理图如下：</p><p><img src="http://mculover666.cn/image/20190827/cX3i5JC2BU5x.png?imageslim" alt="mark"></p><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt="mark"></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：<br><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt="mark"></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:<br><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt="mark"></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：<br><img src="http://mculover666.cn/image/20190806/k593lGGb5tlW.png?imageslim" alt="mark"></p><h2 id="配置串口"><a href="#配置串口" class="headerlink" title="配置串口"></a>配置串口</h2><p>小熊派开发板板载ST-Link并且虚拟了一个串口，原理图如下：</p><p><img src="http://mculover666.cn/image/20190814/IwyXONVefPx9.png?imageslim" alt="mark"></p><p>这里我将开关拨到<code>AT-MCU</code>模式，使PC的串口与USART1之间连接。</p><p>接下来开始配置<code>USART1</code>：</p><p><img src="http://mculover666.cn/image/20190814/nLMRMYtmzghl.png?imageslim" alt="mark"></p><h2 id="配置硬件I2C"><a href="#配置硬件I2C" class="headerlink" title="配置硬件I2C"></a>配置硬件I2C</h2><p>首先查看小熊派开发板的原理图，确定EEPROM接在哪个I2C接口上，如图：</p><p><img src="http://mculover666.cn/image/20190826/fxx651qDYC6O.png?imageslim" alt="mark"></p><p>接下来开始配置I2C接口1：</p><p><img src="http://mculover666.cn/image/20190826/obFsy5wJHDXz.png?imageslim" alt="mark"></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：</p><p><img src="http://mculover666.cn/image/20190806/1TQg7frjRpVr.png?imageslim" alt="mark"></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/image/20190827/ytOSpCuIpUwV.png?imageslim" alt="mark"></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：</p><p><img src="http://mculover666.cn/image/20190806/T6WvSK6Dfpts.png?imageslim" alt="mark"></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：</p><p><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt="mark"></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="修改I2C初始化代码的小BUG"><a href="#修改I2C初始化代码的小BUG" class="headerlink" title="修改I2C初始化代码的小BUG"></a>修改I2C初始化代码的小BUG</h2><p><img src="http://mculover666.cn/image/20190826/jQbpnRxnsBF0.png?imageslim" alt="mark"></p><h2 id="重定向printf-函数"><a href="#重定向printf-函数" class="headerlink" title="重定向printf( )函数"></a>重定向printf( )函数</h2><p>参考：<a href="https://www.mculover666.cn/2019/07/30/STM32Cube/【STM32Cube-09】重定向printf函数到串口输出的多种方法/">【STM32Cube_09】重定向printf函数到串口输出的多种方法</a>。</p><h1 id="4-编写BH1750驱动程序"><a href="#4-编写BH1750驱动程序" class="headerlink" title="4. 编写BH1750驱动程序"></a>4. 编写BH1750驱动程序</h1><p>参考<a href="https://download.csdn.net/download/mculover666/11368379" target="_blank" rel="noopener">bh1750FVI中文数据手册.pdf</a>进行编程。</p><h2 id="宏定义BH1750器件地址"><a href="#宏定义BH1750器件地址" class="headerlink" title="宏定义BH1750器件地址"></a>宏定义BH1750器件地址</h2><p>BH1750的器件地址由<code>ADDR</code>端口的高低电平决定：</p><p><img src="http://mculover666.cn/image/20190827/rwX5250rtUKp.png?imageslim" alt="mark"></p><p>结合原理图，在 <code>bh1750_i2c_drv.h</code> 头文件中可以定义如下：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span>    BH1750_ADDR_WRITE    0x46    </span><span class="token comment" spellcheck="true">//01000110</span><span class="token macro property">#<span class="token directive keyword">define</span>    BH1750_ADDR_READ    0x47    </span><span class="token comment" spellcheck="true">//01000111</span></code></pre><h2 id="枚举BH1750工作模式"><a href="#枚举BH1750工作模式" class="headerlink" title="枚举BH1750工作模式"></a>枚举BH1750工作模式</h2><p>参考数据手册在 <code>bh1750_i2c_drv.h</code> 头文件中进行如下枚举定义：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">enum</span><span class="token punctuation">{</span>    POWER_OFF_CMD    <span class="token operator">=</span>    <span class="token number">0x00</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//断电：无激活状态</span>    POWER_ON_CMD    <span class="token operator">=</span>    <span class="token number">0x01</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//通电：等待测量指令</span>    RESET_REGISTER    <span class="token operator">=</span>    <span class="token number">0x07</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//重置数字寄存器（在断电状态下不起作用）</span>    CONT_H_MODE        <span class="token operator">=</span>    <span class="token number">0x10</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//连续H分辨率模式：在11x分辨率下开始测量，测量时间120ms</span>    CONT_H_MODE2    <span class="token operator">=</span>    <span class="token number">0x11</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//连续H分辨率模式2：在0.51x分辨率下开始测量，测量时间120ms</span>    CONT_L_MODE        <span class="token operator">=</span>    <span class="token number">0x13</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//连续L分辨率模式：在411分辨率下开始测量，测量时间16ms</span>    ONCE_H_MODE        <span class="token operator">=</span>    <span class="token number">0x20</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//一次高分辨率模式：在11x分辨率下开始测量，测量时间120ms，测量后自动设置为断电模式</span>    ONCE_H_MODE2    <span class="token operator">=</span>    <span class="token number">0x21</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//一次高分辨率模式2：在0.51x分辨率下开始测量，测量时间120ms，测量后自动设置为断电模式</span>    ONCE_L_MODE        <span class="token operator">=</span>    <span class="token number">0x23</span>    <span class="token comment" spellcheck="true">//一次低分辨率模式：在411x分辨率下开始测量，测量时间16ms，测量后自动设置为断电模式</span><span class="token punctuation">}</span> BH1750_MODE<span class="token punctuation">;</span></code></pre><h2 id="发送命令和读取数据"><a href="#发送命令和读取数据" class="headerlink" title="发送命令和读取数据"></a>发送命令和读取数据</h2><p>接下来编写<code>bh1750_i2c_drv.c</code>驱动文件，参考数据手册中的这部分：</p><p><img src="http://mculover666.cn/image/20190827/3C9xx1HgHlHj.png?imageslim" alt="mark"></p><p>本驱动程序底层使用 HAL 库的 IIC 初始化文件，所以包含如下头文件：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"bh1750_i2c_drv.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"i2c.h"</span></span></code></pre><p>根据上图，发送命令的函数如下：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief    向BH1750发送一条指令 * @param    cmd —— BH1750工作模式指令（在BH1750_MODE中枚举定义） * @retval    成功返回HAL_OK*/</span>uint8_t    <span class="token function">BH1750_Send_Cmd</span><span class="token punctuation">(</span>BH1750_MODE cmd<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">HAL_I2C_Master_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hi2c1<span class="token punctuation">,</span> BH1750_ADDR_WRITE<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint8_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>cmd<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>接收光照强度数据的函数如下：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief    从BH1750接收一次光强数据 * @param    dat —— 存储光照强度的地址（两个字节数组） * @retval    成功 —— 返回HAL_OK*/</span>uint8_t <span class="token function">BH1750_Read_Dat</span><span class="token punctuation">(</span>uint8_t<span class="token operator">*</span> dat<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">HAL_I2C_Master_Receive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hi2c1<span class="token punctuation">,</span> BH1750_ADDR_READ<span class="token punctuation">,</span> dat<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="数据转换函数"><a href="#数据转换函数" class="headerlink" title="数据转换函数"></a>数据转换函数</h2><p>根据数据手册中给出的公式，编写将从BH1750读出的两个字节数据转换为对应强度值的函数：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief    将BH1750的两个字节数据转换为光照强度值（0-65535） * @param    dat  —— 存储光照强度的地址（两个字节数组） * @retval    成功 —— 返回光照强度值*/</span>uint16_t <span class="token function">BH1750_Dat_To_Lux</span><span class="token punctuation">(</span>uint8_t<span class="token operator">*</span> dat<span class="token punctuation">)</span><span class="token punctuation">{</span>    uint16_t lux <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    lux <span class="token operator">=</span> dat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    lux <span class="token operator">&lt;&lt;=</span> <span class="token number">8</span><span class="token punctuation">;</span>    lux <span class="token operator">+</span><span class="token operator">=</span> dat<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    lux <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>lux <span class="token operator">/</span> <span class="token number">1.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> lux<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="5-测试驱动程序"><a href="#5-测试驱动程序" class="headerlink" title="5. 测试驱动程序"></a>5. 测试驱动程序</h1><p>在main.c中测试驱动程序是否正常：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    uint8_t dat<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//dat[0]是高字节，dat[1]是低字节</span>    <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_I2C1_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>HAL_OK <span class="token operator">==</span> <span class="token function">BH1750_Send_Cmd</span><span class="token punctuation">(</span>ONCE_H_MODE<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//printf("send ok\n");</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//printf("send fail\n");</span>        <span class="token punctuation">}</span>        <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>HAL_OK <span class="token operator">==</span> <span class="token function">BH1750_Read_Dat</span><span class="token punctuation">(</span>dat<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//printf("recv ok\n");</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"current: %5d lux\n"</span><span class="token punctuation">,</span> <span class="token function">BH1750_Dat_To_Lux</span><span class="token punctuation">(</span>dat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//printf("recv fail");</span>        <span class="token punctuation">}</span>        <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>编译下载运行，测试结果如下：</p><p><img src="http://mculover666.cn/image/20190827/sdaBrbW78OyI.png?imageslim" alt="mark"></p><p>至此，我们已经学会<strong>如何使用硬件IIC接口读取环境光强度传感器数据（BH1750）</strong>，下一节将讲述如何使用硬件IIC接口读取温湿度传感器数据并使用软件CRC校验（SHT30）。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX BH1750 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_13 | 使用硬件I2C读写EEPROM（AT24C02）</title>
      <link href="/posts/3523891062/"/>
      <url>/posts/3523891062/</url>
      
        <content type="html"><![CDATA[<p>本篇详细的记录了如何使用STM32CubeMX配置STM32L431RCT6的硬件I2C外设读取EEPROM数据（以AT24C02为例）。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板</li></ul><p>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：</p><p><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt="mark"></p><ul><li>EEPROM</li></ul><p>小熊派开发板左边的接口是E53接口，用来连接E53接口的扩展板，每个扩展板都板载了一块EEPROM用来保存信息，如图：</p><p><img src="http://mculover666.cn/image/20190826/KU3hAdAprJlG.png?imageslim" alt="mark"></p><p>AT24C02的原理图如下（<strong>该原理图中有bug，A0的上拉电阻无效，实际A0为低电平</strong>）：</p><p><img src="http://mculover666.cn/image/20190826/LySHcKjfKLSz.png?imageslim" alt="mark"></p><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt="mark"></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：<br><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt="mark"></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:<br><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt="mark"></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：<br><img src="http://mculover666.cn/image/20190806/k593lGGb5tlW.png?imageslim" alt="mark"></p><h2 id="配置串口"><a href="#配置串口" class="headerlink" title="配置串口"></a>配置串口</h2><p>小熊派开发板板载ST-Link并且虚拟了一个串口，原理图如下：</p><p><img src="http://mculover666.cn/image/20190814/IwyXONVefPx9.png?imageslim" alt="mark"></p><p>这里我将开关拨到<code>AT-MCU</code>模式，使PC的串口与USART1之间连接。</p><p>接下来开始配置<code>USART1</code>：</p><p><img src="http://mculover666.cn/image/20190814/nLMRMYtmzghl.png?imageslim" alt="mark"></p><h2 id="配置硬件I2C"><a href="#配置硬件I2C" class="headerlink" title="配置硬件I2C"></a>配置硬件I2C</h2><p>首先查看小熊派开发板的原理图，确定EEPROM接在哪个I2C接口上，如图：</p><p><img src="http://mculover666.cn/image/20190826/fxx651qDYC6O.png?imageslim" alt="mark"></p><p>接下来开始配置I2C接口1：</p><p><img src="http://mculover666.cn/image/20190826/obFsy5wJHDXz.png?imageslim" alt="mark"></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：</p><p><img src="http://mculover666.cn/image/20190806/1TQg7frjRpVr.png?imageslim" alt="mark"></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/image/20190826/xVjdv02ngKcq.png?imageslim" alt="mark"></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：</p><p><img src="http://mculover666.cn/image/20190806/T6WvSK6Dfpts.png?imageslim" alt="mark"></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：</p><p><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt="mark"></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="修改I2C初始化代码的小BUG"><a href="#修改I2C初始化代码的小BUG" class="headerlink" title="修改I2C初始化代码的小BUG"></a>修改I2C初始化代码的小BUG</h2><p><img src="http://mculover666.cn/image/20190826/jQbpnRxnsBF0.png?imageslim" alt="mark"></p><h2 id="重定向printf-函数"><a href="#重定向printf-函数" class="headerlink" title="重定向printf( )函数"></a>重定向printf( )函数</h2><p>参考：<a href="https://www.mculover666.cn/2019/07/30/STM32Cube/【STM32Cube-09】重定向printf函数到串口输出的多种方法/">【STM32Cube_09】重定向printf函数到串口输出的多种方法</a>。</p><h2 id="编写EEPROM驱动程序"><a href="#编写EEPROM驱动程序" class="headerlink" title="编写EEPROM驱动程序"></a>编写EEPROM驱动程序</h2><p>EEPROM的驱动编写篇幅过多，单独分出来一节讲述。</p><h1 id="4-AT24C02驱动的编写"><a href="#4-AT24C02驱动的编写" class="headerlink" title="4. AT24C02驱动的编写"></a>4. AT24C02驱动的编写</h1><h2 id="确定IIC器件地址"><a href="#确定IIC器件地址" class="headerlink" title="确定IIC器件地址"></a>确定IIC器件地址</h2><p>根据AT24C02的 Datasheet 可知AT24C02有<strong>2K bit，即256B，分为32页,每页8个字节</strong>，结合数据手册和原理图可以得知，板载AT24C02的读地址为<code>0xA2</code>，写地址为<code>0xA3</code>：</p><p><img src="http://mculover666.cn/image/20190826/ApkRI7A59RGs.png?imageslim" alt="mark"></p><p>首先在<code>at24c02_i2c_drv.h</code>中编写AT24C02相关的宏定义：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span>    AT24C02_ADDR_WRITE    0xA0</span><span class="token macro property">#<span class="token directive keyword">define</span>    AT24C02_ADDR_READ    0xA1</span></code></pre><p>然后在<code>at24c02_i2c_drv.c</code>中引入<code>i2c.h</code>，基于HAL提供的硬件IIC操作函数，编写AT24C02的一些底层函数，如下。</p><h2 id="任意地址写一个字节"><a href="#任意地址写一个字节" class="headerlink" title="任意地址写一个字节"></a>任意地址写一个字节</h2><p>根据AT24C02的数据手册可知，AT24C02写一个字节的格式如下：</p><p><img src="http://mculover666.cn/image/20190826/Kne5Ozz8NWO8.png?imageslim" alt="mark"></p><p>编写的函数如下：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief        AT24C02任意地址写一个字节数据 * @param        addr —— 写数据的地址（0-255） * @param        dat  —— 存放写入数据的地址 * @retval        成功 —— HAL_OK*/</span>uint8_t <span class="token function">At24c02_Write_Byte</span><span class="token punctuation">(</span>uint16_t addr<span class="token punctuation">,</span> uint8_t<span class="token operator">*</span> dat<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">HAL_I2C_Mem_Write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hi2c1<span class="token punctuation">,</span> AT24C02_ADDR_WRITE<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> I2C_MEMADD_SIZE_8BIT<span class="token punctuation">,</span> dat<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="任意地址读一个字节"><a href="#任意地址读一个字节" class="headerlink" title="任意地址读一个字节"></a>任意地址读一个字节</h2><p>根据AT24C02的数据手册可知，AT24C02读一个字节的格式如下：</p><p><img src="http://mculover666.cn/image/20190826/mKfAcbHNoD24.png?imageslim" alt="mark"></p><p>编写的函数如下：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief        AT24C02任意地址读一个字节数据 * @param        addr —— 读数据的地址（0-255） * @param        read_buf —— 存放读取数据的地址 * @retval        成功 —— HAL_OK*/</span>uint8_t <span class="token function">At24c02_Read_Byte</span><span class="token punctuation">(</span>uint16_t addr<span class="token punctuation">,</span> uint8_t<span class="token operator">*</span> read_buf<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">HAL_I2C_Mem_Read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hi2c1<span class="token punctuation">,</span> AT24C02_ADDR_READ<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> I2C_MEMADD_SIZE_8BIT<span class="token punctuation">,</span> read_buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="测试字节读写函数"><a href="#测试字节读写函数" class="headerlink" title="测试字节读写函数"></a>测试字节读写函数</h2><p>在<code>main.c</code>中测试：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    uint8_t write_dat <span class="token operator">=</span> <span class="token number">0xa5</span><span class="token punctuation">;</span>    uint8_t recv_buf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">MX_I2C1_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>HAL_OK <span class="token operator">==</span> <span class="token function">At24c02_Write_Byte</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>write_dat<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Write ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Write fail\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//写一次和读一次之间需要短暂的延时</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>HAL_OK <span class="token operator">==</span> <span class="token function">At24c02_Read_Byte</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>recv_buf<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Read ok, recv_buf = 0x%02X\n"</span><span class="token punctuation">,</span> recv_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Read fail\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>测试结果如下：</p><p><img src="http://mculover666.cn/image/20190826/3OH13P3htS3Q.png?imageslim" alt="mark"></p><h2 id="任意地址连续写多个字节"><a href="#任意地址连续写多个字节" class="headerlink" title="任意地址连续写多个字节"></a>任意地址连续写多个字节</h2><p>AT24C02连续写字节的时候需要注意，<strong>不能使用写单个字节函数连续的写入</strong>，因为AT24C02分为了32页，每页是8个字节，如果连续的单字节写入8个字节后，会重复的继续往该页写数据，所以要使用如下的写一页的格式：</p><p><img src="http://mculover666.cn/image/20190826/JPc5Vippp1jN.png?imageslim" alt="mark"></p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief        AT24C02任意地址连续写多个字节数据 * @param        addr —— 写数据的地址（0-255） * @param        dat  —— 存放写入数据的地址 * @retval        成功 —— HAL_OK*/</span>uint8_t <span class="token function">At24c02_Write_Amount_Byte</span><span class="token punctuation">(</span>uint16_t addr<span class="token punctuation">,</span> uint8_t<span class="token operator">*</span> dat<span class="token punctuation">,</span> uint16_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    uint8_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    uint16_t cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//写入字节计数</span>    <span class="token comment" spellcheck="true">/* 对于起始地址，有两种情况，分别判断 */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> addr <span class="token operator">%</span> <span class="token number">8</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 起始地址刚好是页开始地址 */</span>        <span class="token comment" spellcheck="true">/* 对于写入的字节数，有两种情况，分别判断 */</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">8</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//写入的字节数不大于一页，直接写入</span>            <span class="token keyword">return</span> <span class="token function">HAL_I2C_Mem_Write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hi2c1<span class="token punctuation">,</span> AT24C02_ADDR_WRITE<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> I2C_MEMADD_SIZE_8BIT<span class="token punctuation">,</span> dat<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//写入的字节数大于一页，先将整页循环写入</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> size<span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token function">HAL_I2C_Mem_Write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hi2c1<span class="token punctuation">,</span> AT24C02_ADDR_WRITE<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> I2C_MEMADD_SIZE_8BIT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dat<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                addr <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>                cnt <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//将剩余的字节写入</span>            <span class="token keyword">return</span> <span class="token function">HAL_I2C_Mem_Write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hi2c1<span class="token punctuation">,</span> AT24C02_ADDR_WRITE<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> I2C_MEMADD_SIZE_8BIT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dat<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">,</span> size <span class="token operator">-</span> cnt<span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 起始地址偏离页开始地址 */</span>        <span class="token comment" spellcheck="true">/* 对于写入的字节数，有两种情况，分别判断 */</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token number">8</span> <span class="token operator">-</span> addr<span class="token operator">%</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 在该页可以写完 */</span>            <span class="token keyword">return</span> <span class="token function">HAL_I2C_Mem_Write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hi2c1<span class="token punctuation">,</span> AT24C02_ADDR_WRITE<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> I2C_MEMADD_SIZE_8BIT<span class="token punctuation">,</span> dat<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 该页写不完 */</span>            <span class="token comment" spellcheck="true">//先将该页写完</span>            cnt <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">8</span> <span class="token operator">-</span> addr<span class="token operator">%</span><span class="token number">8</span><span class="token punctuation">;</span>            <span class="token function">HAL_I2C_Mem_Write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hi2c1<span class="token punctuation">,</span> AT24C02_ADDR_WRITE<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> I2C_MEMADD_SIZE_8BIT<span class="token punctuation">,</span> dat<span class="token punctuation">,</span> cnt<span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            addr <span class="token operator">+</span><span class="token operator">=</span> cnt<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//循环写整页数据</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">-</span> cnt<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token function">HAL_I2C_Mem_Write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hi2c1<span class="token punctuation">,</span> AT24C02_ADDR_WRITE<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> I2C_MEMADD_SIZE_8BIT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dat<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                addr <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>                cnt <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//将剩下的字节写入</span>            <span class="token keyword">return</span> <span class="token function">HAL_I2C_Mem_Write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hi2c1<span class="token punctuation">,</span> AT24C02_ADDR_WRITE<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> I2C_MEMADD_SIZE_8BIT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dat<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">,</span> size <span class="token operator">-</span> cnt<span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="任意地址连续读多个字节"><a href="#任意地址连续读多个字节" class="headerlink" title="任意地址连续读多个字节"></a>任意地址连续读多个字节</h2><p>AT24C02连续读多个字节没有限制，直接读取即可，代码如下：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief        AT24C02任意地址连续读多个字节数据 * @param        addr —— 读数据的地址（0-255） * @param        dat  —— 存放读出数据的地址 * @retval        成功 —— HAL_OK*/</span>uint8_t <span class="token function">At24c02_Read_Amount_Byte</span><span class="token punctuation">(</span>uint16_t addr<span class="token punctuation">,</span> uint8_t<span class="token operator">*</span> recv_buf<span class="token punctuation">,</span> uint16_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">HAL_I2C_Mem_Read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hi2c1<span class="token punctuation">,</span> AT24C02_ADDR_READ<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> I2C_MEMADD_SIZE_8BIT<span class="token punctuation">,</span> recv_buf<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="测试任意地址连续读写多个字节"><a href="#测试任意地址连续读写多个字节" class="headerlink" title="测试任意地址连续读写多个字节"></a>测试任意地址连续读写多个字节</h2><p>在<code>main.c</code>中测试：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    uint8_t write_dat<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    uint8_t recv_buf<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">MX_I2C1_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">22</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        write_dat<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%02X "</span><span class="token punctuation">,</span> write_dat<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">16</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>HAL_OK <span class="token operator">==</span> <span class="token function">At24c02_Write_Amount_Byte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> write_dat<span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"write ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"write fail\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>HAL_OK <span class="token operator">==</span> <span class="token function">HAL_I2C_Mem_Read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hi2c1<span class="token punctuation">,</span> AT24C02_ADDR_READ<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> I2C_MEMADD_SIZE_8BIT<span class="token punctuation">,</span> recv_buf<span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">22</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0x%02X "</span><span class="token punctuation">,</span> recv_buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read fail\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>测试结果：</p><p><img src="http://mculover666.cn/image/20190826/MjzEoRshe1it.png?imageslim" alt="mark"></p><p>将上面的读写地址由0改为5，再次测试：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>HAL_OK <span class="token operator">==</span> <span class="token function">At24c02_Write_Amount_Byte</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> write_dat<span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>测试结果：</p><p><img src="http://mculover666.cn/image/20190826/EbiIkU1mSSg2.png?imageslim" alt="mark"></p><p>至此，我们已经学会<strong>如何使用硬件IIC接口读写EEPROM</strong>，下一节将讲述如何使用硬件IIC接口读取环境光强度传感器数据（BH1750）。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX EEPROM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_12 | 使用通用定时器产生PWM驱动蜂鸣器</title>
      <link href="/posts/650884631/"/>
      <url>/posts/650884631/</url>
      
        <content type="html"><![CDATA[<p>本篇详细的记录了如何使用STM32CubeMX配置STM32L431RCT6的通用定时器外设，产生PWM驱动无源蜂鸣器。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：</li></ul><p><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt=""></p><ul><li>蜂鸣器</li></ul><p>这里我直接使用扩展板上的蜂鸣器，如图：</p><p><img src="http://mculover666.cn/image/20190807/egsTj4DhhwM8.png?imageslim" alt=""></p><p>蜂鸣器的原理图如下：</p><p><img src="http://mculover666.cn/image/20190807/kjUo6ctmGGXS.png?imageslim" alt=""></p><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt=""></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：<br><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt=""></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:<br><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt=""></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：<br><img src="http://mculover666.cn/image/20190806/k593lGGb5tlW.png?imageslim" alt=""></p><h2 id="配置通用定时器TIM16"><a href="#配置通用定时器TIM16" class="headerlink" title="配置通用定时器TIM16"></a>配置通用定时器TIM16</h2><blockquote><p>知识小卡片——STM32L431的定时器</p></blockquote><p>STM32L431xx 系列有 1 个高级定时器（TIM1）, 3 个通用定时器（TIM2、TIM15、TIM16），两个基本定时器（TIM6、TIM7），还有两个低功耗定时器（LPTIM1、LPTIM2）。</p><p>STM32L431 的通用 TIMx (TIM2、TIM15、TIM16)定时器功能包括：</p><ul><li><p>16 位(TIM15,TIM16)/32 位(TIM2)向上、向下、向上/向下自动装载计数器，注意：<br>TIM15、TIM16 只支持向上（递增）计数方式；</p></li><li><p>16 位可编程(可以实时修改)预分频器，计数器时钟频率的分频系数为 1～65535 之间的任<br>意数值。</p></li><li><p>4 个独立通道（TIMx_CH1~4， 其中 TIM15 最多 2 个通道， TIM16 最多 1 个<br>通道），这些通道可以用来作为：</p><ul><li>输入捕获</li><li>输出比较</li><li>PWM 生成(边缘或中间对齐模式)</li><li>单脉冲模式输出</li></ul></li><li><p>可使用外部信号控制定时器和定时器互连的同步电路。</p></li><li><p>如下事件发生时产生中断/DMA：</p><ul><li>更新：计数器向上溢出/向下溢出，计数器初始化(通过软件或者内部/外部触发)</li><li>触发事件(计数器启动、停止、初始化或者由内部/外部触发计数)</li><li>输入捕获</li><li>输出比较</li></ul></li></ul><blockquote><p>知识小卡片结束啦~</p></blockquote><p>接下来开始配置TIM16定时器的PWM功能：</p><p>首先选择<code>TIM</code>，选择通道1的功能，默认的CH1是<code>PA6</code>引脚，但是开发板上是与 PB8 连接的，所以在右边将PB8配置为<code>TIM16_CH1</code>：<br><img src="http://mculover666.cn/image/20190807/3Ru6wXY95H7s.png?imageslim" alt=""></p><p>接下来是对TIM16的参数设置，参照数据手册中的RCC时钟树，TIM16内部时钟来源是<code>PCLK2 = 80Mhz</code>，我们的目的是产生<code>1khz</code>的PWM，所以预分频系数设置为<code>80-1</code>，自动重载值为<code>1000-1</code>，得到的计时器更新中断频率即为<code>80000000/80/1000 = 1000 Hz = 1K Hz</code>：</p><p><img src="http://mculover666.cn/blog/20191202/K3Biuuw5VTzB.png?imageslim" alt=""></p><p>其余的一些设置保持默认即可，最后配置PWM占空比：<br><img src="http://mculover666.cn/image/20190807/kVj0GfgtTFw9.png?imageslim" alt=""></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：<br><img src="http://mculover666.cn/image/20190806/1TQg7frjRpVr.png?imageslim" alt=""></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/image/20190807/UibRvxrbe4JC.png?imageslim" alt=""></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：<br><img src="http://mculover666.cn/image/20190806/T6WvSK6Dfpts.png?imageslim" alt=""></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：<br><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt=""></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="启动定时器并产生PWM"><a href="#启动定时器并产生PWM" class="headerlink" title="启动定时器并产生PWM"></a>启动定时器并产生PWM</h2><p>最后在<code>main</code>函数中开启TIM2并使能其中断（TIM2初始化代码之后）：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">HAL_TIM_PWM_Start</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>htim16<span class="token punctuation">,</span>TIM_CHANNEL_1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">HAL_TIM_PWM_Stop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>htim16<span class="token punctuation">,</span>TIM_CHANNEL_1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>编译下载后即可听到无源蜂鸣器开始工作。</p><p>至此，我们已经学会<strong>如何使用通用定时器产生PWM驱动蜂鸣器</strong>，下一节将讲述如何使用硬件IIC接口读写EEPROM。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_11 | 使用通用定时器闪烁LED</title>
      <link href="/posts/1598873035/"/>
      <url>/posts/1598873035/</url>
      
        <content type="html"><![CDATA[<p>本篇详细的记录了如何使用STM32CubeMX配置STM32L431RCT6的通用定时器外设，以中断的方式使LED闪烁。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：</li></ul><p><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt=""></p><ul><li>测试LED</li></ul><p>这里我直接使用板载LED，原理图如下：<br><img src="http://mculover666.cn/image/20190807/mvxaRos96773.png?imageslim" alt=""></p><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt=""></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：<br><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt=""></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:<br><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt=""></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：<br><img src="http://mculover666.cn/image/20190806/k593lGGb5tlW.png?imageslim" alt=""></p><h2 id="配置LED的GPIO引脚"><a href="#配置LED的GPIO引脚" class="headerlink" title="配置LED的GPIO引脚"></a>配置LED的GPIO引脚</h2><p>查看小熊派开发板的原理图，如下：</p><p><img src="http://mculover666.cn/image/20190812/5iCtQUfKbgzA.png?imageslim" alt=""></p><p>所以接下来我们选择配置<code>PC13</code>引脚：</p><p><img src="http://mculover666.cn/image/20190812/Ad3UrGCsgjXr.png?imageslim" alt=""></p><p>给PC13引脚设置一个user_label:</p><p><img src="http://mculover666.cn/blog/20191203/Xs7BxveXoyYs.png?imageslim" alt=""></p><blockquote><p>这里给PC13引脚添加一个user_label后，cubemx软件会在<code>main.h</code>文件中添加一个宏定义，如图，我们可以使用<code>LED_GPIO_Port</code>, <code>LED_Pin</code>来表示这个引脚，提高了程序的可移植性。如果没有该user_label，就需要使用<code>GPIOC</code>，<code>GPIO_PIN_13</code> 来表示这个引脚。</p></blockquote><p><img src="http://mculover666.cn/blog/20191203/fvPWgmNK4NU7.png?imageslim" alt=""></p><h2 id="配置通用定时器TIM2"><a href="#配置通用定时器TIM2" class="headerlink" title="配置通用定时器TIM2"></a>配置通用定时器TIM2</h2><blockquote><p>知识小卡片——STM32L431的定时器</p></blockquote><p>STM32L431xx 系列有 1 个高级定时器（TIM1）, 3 个通用定时器（TIM2、TIM15、TIM16），两个基本定时器（TIM6、TIM7），还有两个低功耗定时器（LPTIM1、LPTIM2）。</p><p>STM32L431 的通用 TIMx (TIM2、TIM15、TIM16)定时器功能包括：</p><ul><li><p>16 位(TIM15,TIM16)/32 位(TIM2)向上、向下、向上/向下自动装载计数器，注意：<br>TIM15、TIM16 只支持向上（递增）计数方式；</p></li><li><p>16 位可编程(可以实时修改)预分频器，计数器时钟频率的分频系数为 1～65535 之间的任<br>意数值。</p></li><li><p>4 个独立通道（TIMx_CH1~4， 其中 TIM15 最多 2 个通道， TIM16 最多 1 个<br>通道），这些通道可以用来作为：</p><ul><li>输入捕获</li><li>输出比较</li><li>PWM 生成(边缘或中间对齐模式)</li><li>单脉冲模式输出</li></ul></li><li><p>可使用外部信号控制定时器和定时器互连的同步电路。</p></li><li><p>如下事件发生时产生中断/DMA：</p><ul><li>更新：计数器向上溢出/向下溢出，计数器初始化(通过软件或者内部/外部触发)</li><li>触发事件(计数器启动、停止、初始化或者由内部/外部触发计数)</li><li>输入捕获</li><li>输出比较</li></ul></li></ul><blockquote><p>知识小卡片结束啦~</p></blockquote><h3 id="配置定时器TIM2"><a href="#配置定时器TIM2" class="headerlink" title="配置定时器TIM2"></a>配置定时器TIM2</h3><p>首先选择<code>TIM2</code>，时钟源选择内部时钟：<br><img src="http://mculover666.cn/image/20190807/NltQViLTCKmj.png?imageslim" alt=""></p><p>接下来是对TIM2的参数设置，参照数据手册中的RCC时钟树，TIM2内部时钟来源是<code>PCLK1 = 80Mhz</code>，我们的目的是每秒钟产生2次中断，所以预分频系数设置为<code>40000-1</code>，自动重载值为<code>1000-1</code>，得到的计时器更新中断频率即为<code>80000000/40000/1000=2Hz</code>：<br><img src="http://mculover666.cn/image/20190807/FsrFLXtFVJBc.png?imageslim" alt=""></p><p>其余的一些设置保持默认即可，最后开启TIM2中断：<br><img src="http://mculover666.cn/image/20190807/q8syGvcE19c0.png?imageslim" alt=""></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：<br><img src="http://mculover666.cn/image/20190806/1TQg7frjRpVr.png?imageslim" alt=""></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/image/20190807/RmgpLb30TEyD.png?imageslim" alt=""></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：<br><img src="http://mculover666.cn/image/20190806/T6WvSK6Dfpts.png?imageslim" alt=""></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：<br><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt=""></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="编写中断回调函数"><a href="#编写中断回调函数" class="headerlink" title="编写中断回调函数"></a>编写中断回调函数</h2><p>在<code>stm32l4xx_it.c</code>中生成的中断处理函数如下，定时器TIM2所有的中断都会调用该中断服务函数<code>TIM2_IRQHandler</code>：</p><p><img src="http://mculover666.cn/image/20190807/j4GAcl4onlAR.png?imageslim" alt=""></p><p>在中断处理函数中自动生成了<code>HAL_TIM_IRQHandler(&amp;htim2)</code>代码，该代码会自动根据中断事件回调相应的函数，这里我们需要处理<strong>更新中断的事件</strong>，回调函数默认是<code>__weak</code>定义的，所以在<code>tim.c</code>中重新定义该回调函数，并且在该函数中添加功能的时候，因为该回调函数会被所有的定时器共用，所以需要先判断是哪个定时器在调用：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HAL_TIM_PeriodElapsedCallback</span><span class="token punctuation">(</span>TIM_HandleTypeDef<span class="token operator">*</span> tim_baseHandle<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tim_baseHandle<span class="token operator">-></span>Instance <span class="token operator">==</span> htim2<span class="token punctuation">.</span>Instance<span class="token punctuation">)</span>        <span class="token function">HAL_GPIO_TogglePin</span><span class="token punctuation">(</span>LED_GPIO_Port<span class="token punctuation">,</span> LED_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="启动定时器并使能中断"><a href="#启动定时器并使能中断" class="headerlink" title="启动定时器并使能中断"></a>启动定时器并使能中断</h2><p>最后在<code>main</code>函数中开启TIM2并使能其中断（TIM2初始化代码之后，while之前）：</p><pre class=" language-c"><code class="language-c"><span class="token function">HAL_TIM_Base_Start_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>htim2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>编译下载后即可看到LED以 2 Hz的频率闪烁。</p><p>至此，我们已经学会<strong>如何使用通用定时器闪烁LED</strong>，下一节将讲述如何使用通用定时器产生PWM驱动蜂鸣器。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_10 | 使用ADC读取气体传感器数据（MQ-2）</title>
      <link href="/posts/1249993360/"/>
      <url>/posts/1249993360/</url>
      
        <content type="html"><![CDATA[<p>本篇详细的记录了如何使用STM32CubeMX配置STM32L431RCT6的ADC外设，读取MQ-2气体传感器的数据并通过串口发送。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：<br><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt="mark"></li><li>MQ-2模块<br>MQ-2气体传感器一般用于家庭和工厂的气体泄漏监测装置，适用于液化气、丁烷、丙烷、甲烷、酒精、氢气、烟雾等的探测，如图：<br><img src="http://mculover666.cn/image/20190806/DYWw34Cxn6Jl.png?imageslim" alt="mark"></li></ul><p>MQ-2的原理图如下：<br><img src="http://mculover666.cn/image/20190806/39fP6PTeK7OD.png?imageslim" alt="mark"></p><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li><li>准备一个串口调试助手，这里我使用的是<code>Serial Port Utility</code>；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt="mark"></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：<br><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt="mark"></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:<br><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt="mark"></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：<br><img src="http://mculover666.cn/image/20190806/k593lGGb5tlW.png?imageslim" alt="mark"></p><h2 id="配置串口"><a href="#配置串口" class="headerlink" title="配置串口"></a>配置串口</h2><p>小熊派开发板板载ST-Link并且虚拟了一个串口，原理图如下：</p><p><img src="http://mculover666.cn/image/20190814/IwyXONVefPx9.png?imageslim" alt="mark"></p><p>这里我将开关拨到<code>AT-MCU</code>模式，使PC的串口与USART1之间连接。</p><p>接下来开始配置<code>USART1</code>：</p><p><img src="http://mculover666.cn/image/20190814/nLMRMYtmzghl.png?imageslim" alt="mark"></p><h2 id="配置ADC"><a href="#配置ADC" class="headerlink" title="配置ADC"></a>配置ADC</h2><blockquote><p>知识小卡片 —— ADC</p></blockquote><p>ADC全称 Analog-to-Digital Converter，即模拟-数字转换器，可以将连续变化的模拟信号转换为离散的数字信号，进而使用数字电路进行处理，称之为数字信号处理。</p><p>STM32L431xx 系列有 1 个 ADC，ADC 分辨率高达 12 位，每个 ADC 具有多达 20 个的采集<br>通道，这些通道的 A/D 转换可以单次、连续、扫描或间断模式执行。 ADC 的结果可以左对齐<br>或右对齐方式存储在 16 位数据寄存器中。</p><p>STM32L431 的 ADC 最大的转换速率为 5.33Mhz，也就是转换时间为 0.188us（12 位分辨率<br>时），ADC 的转换时间与 AHB 总线时钟频率无关。</p><blockquote><p>知识小卡片结束啦~对ADC有没有了解呢？</p></blockquote><h3 id="确定ADC通道"><a href="#确定ADC通道" class="headerlink" title="确定ADC通道"></a>确定ADC通道</h3><p>查看小熊派E53接口的原理图：<br><img src="http://mculover666.cn/image/20190806/whMjICDhBLkz.png?imageslim" alt="mark"></p><h3 id="配置ADC（单次转换模式）"><a href="#配置ADC（单次转换模式）" class="headerlink" title="配置ADC（单次转换模式）"></a>配置ADC（单次转换模式）</h3><p>首先选择<code>ADC1</code>，开启通道3：<br><img src="http://mculover666.cn/image/20190806/4W3UD4FP2vfB.png?imageslim" alt="mark"></p><p>接下来是对ADC的设置，这里我们保持默认即可：<br><img src="http://mculover666.cn/image/20190806/y1bnlxAf4IOd.png?imageslim" alt="mark"></p><p>最后设置ADC的转换规则：<br><img src="http://mculover666.cn/image/20190806/TnzK4JjLXoeD.png?imageslim" alt="mark"></p><p>其余的一些设置保持默认即可。</p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：<br><img src="http://mculover666.cn/image/20190806/1TQg7frjRpVr.png?imageslim" alt="mark"></p><p><img src="http://mculover666.cn/image/20190808/EVKCwrQNEWcl.png?imageslim" alt="mark"></p><p><img src="http://mculover666.cn/image/20190806/Dje8nuTMdpQY.png?imageslim" alt="mark"></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/image/20190806/0siSY6f3zQJV.png?imageslim" alt="mark"></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：<br><img src="http://mculover666.cn/image/20190806/T6WvSK6Dfpts.png?imageslim" alt="mark"></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：<br><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt="mark"></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="重定向printf-函数"><a href="#重定向printf-函数" class="headerlink" title="重定向printf( )函数"></a>重定向printf( )函数</h2><p>参考：<a href="https://blog.csdn.net/Mculover666/article/details/95975461" target="_blank" rel="noopener">【STM32Cube】（八）基于串口发送函数实现printf()</a>。</p><h2 id="编写读取数据的测试代码"><a href="#编写读取数据的测试代码" class="headerlink" title="编写读取数据的测试代码"></a>编写读取数据的测试代码</h2><p>修改<code>main</code>函数如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    uint16_t smoke_value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_ADC1_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">HAL_ADC_Start</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hadc1<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//启动ADC单次转换</span>        <span class="token function">HAL_ADC_PollForConversion</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hadc1<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//等待ADC转换完成</span>        smoke_value <span class="token operator">=</span> <span class="token function">HAL_ADC_GetValue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hadc1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//读取ADC转换数据</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"smoke_value = %d\n"</span><span class="token punctuation">,</span> smoke_value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="http://mculover666.cn/image/20190806/6jtuYrH0Mdot.png?imageslim" alt="mark"></p><p>至此，我们已经学会<strong>如何使用ADC读取MQ-2传感器的值</strong>，下一节将讲述如何使用通用定时器闪烁LED。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX 气体传感器MQ-2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_09 | 重定向printf函数到串口输出的多种方法</title>
      <link href="/posts/2251182441/"/>
      <url>/posts/2251182441/</url>
      
        <content type="html"><![CDATA[<p>本文详细的介绍了如何重定向printf输出到串口输出的多种方法，包括调用MDK微库（MicroLib）的方法，调用标准库的方法，以及适用于 <code>GNUC</code> 系列编译器的方法。</p><a id="more"></a><h1 id="1-printf与fputc"><a href="#1-printf与fputc" class="headerlink" title="1.printf与fputc"></a>1.printf与fputc</h1><p>对于 printf 函数相信大家都不陌生，第一个C语言程序就是使用 printf 函数在屏幕上的控制台打印出<code>Hello World</code>，之后使用 printf 函数输出各种类型的数据，使用格式控制输出各种长度的字符，甚至输出各种各样的图案。</p><p>除此之外，在程序出错的时候，懒得调试，直接简单粗暴的加个 printf 找bug，有时候也不失为一种有效的方法。</p><p>对于已经习惯的 printf 函数，你了解多少呢？</p><p>printf 定义在 <code>&lt;stdio.h&gt;</code> 头文件中，如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>printf 函数根据 <code>format</code> 字符串给出的格式打印输出到 <code>stdout</code>（标准输出）中，当然，<strong>printf 函数是不会一个字符一个字符去输出，它会调用更底层的 I/O 函数：<code>fputc</code>去逐个字符打印</strong>。</p><p>fputc 也定义于头文件 <code>&lt;stdio.h&gt;</code>中，如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token keyword">int</span> ch<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>fputc 函数写入字符 ch 到给定输出流 stream，printf函数在调用该函数时，会向stream参数传入<code>stdout</code>从而打印数据到标准输出。</p><p>那么，要实现printf打印到串口就变得非常简单了，<strong>只需要重新定义fputc函数，在fputc的函数中将数据通过串口发送，称之为：fputc重定向或者printf重定向。</strong></p><h1 id="2-在MDK中使用MicroLib重定向printf"><a href="#2-在MDK中使用MicroLib重定向printf" class="headerlink" title="2.在MDK中使用MicroLib重定向printf"></a>2.在MDK中使用MicroLib重定向printf</h1><h2 id="勾选Use-MicroLib"><a href="#勾选Use-MicroLib" class="headerlink" title="勾选Use MicroLib"></a>勾选Use MicroLib</h2><p>MicroLib是对标准C库进行了高度优化之后的库，供MDK默认使用，相比之下，MicroLIB的代码更少，资源占用更少：</p><p><img src="http://mculover666.cn/image/20190819/oFhTzahaD7Kk.png?imageslim" alt="mark"></p><h2 id="重定义fputc到串口"><a href="#重定义fputc到串口" class="headerlink" title="重定义fputc到串口"></a>重定义fputc到串口</h2><p>重新实现fputc函数，编写代码将这个字符通过串口发送，因为发送每个字符时都会调用该函数，所以<strong>为了效率</strong>，不再调用库函数 <code>HAL_UART_Transmit</code> 发送，而是直接操作寄存器发送。</p><ul><li>检测串口当前状态</li></ul><p>STM32L431的USART串口外设有一个 <code>ISR</code> 寄存器，全名 <code>Interrupt and status register</code>， 用来指示当前串口的状态，如图：</p><p><img src="http://mculover666.cn/image/20190819/2hNLPDdErguD.png?imageslim" alt="mark"></p><p>其中 <code>BIT6 TC</code>用来指示当前串口是否发送完成，如图：</p><p><img src="http://mculover666.cn/image/20190819/HqS3iDUO5Ce7.png?imageslim" alt="mark"></p><p>可以通过判断该位来判断串口当前是否处于发送状态，代码如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>USART1<span class="token operator">-></span>ISR <span class="token operator">&amp;</span> <span class="token number">0X40</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>串口发送字符ch</li></ul><p>同样，为了提高发送效率，直接使用寄存器来操作：</p><pre class=" language-c"><code class="language-c">USART1<span class="token operator">-></span>TDR <span class="token operator">=</span> <span class="token punctuation">(</span>uint8_t<span class="token punctuation">)</span> ch<span class="token punctuation">;</span></code></pre><p>最后实现fputc函数就变的非常简单了，这里我放在<code>usart.c</code>文件的末尾：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* USER CODE BEGIN 1 */</span><span class="token macro property">#<span class="token directive keyword">if</span> 1</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token keyword">int</span> ch<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 堵塞判断串口是否发送完成 */</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>USART1<span class="token operator">-></span>ISR <span class="token operator">&amp;</span> <span class="token number">0X40</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 串口发送完成，将该字符发送 */</span>    USART1<span class="token operator">-></span>TDR <span class="token operator">=</span> <span class="token punctuation">(</span>uint8_t<span class="token punctuation">)</span> ch<span class="token punctuation">;</span>    <span class="token keyword">return</span> ch<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment" spellcheck="true">/* USER CODE END 1 */</span></code></pre><blockquote><p>注意：如果是STM32F1系列，上面这段代码不适用，请使用下面的代码：</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* USER CODE BEGIN 1 */</span><span class="token macro property">#<span class="token directive keyword">if</span> 1</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token keyword">int</span> ch<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 堵塞判断串口是否发送完成 */</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>USART1<span class="token operator">-></span>SR <span class="token operator">&amp;</span> <span class="token number">0X40</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 串口发送完成，将该字符发送 */</span>    USART1<span class="token operator">-></span>DR <span class="token operator">=</span> <span class="token punctuation">(</span>uint8_t<span class="token punctuation">)</span> ch<span class="token punctuation">;</span>    <span class="token keyword">return</span> ch<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment" spellcheck="true">/* USER CODE END 1 */</span></code></pre><h2 id="测试printf"><a href="#测试printf" class="headerlink" title="测试printf"></a>测试printf</h2><p>在main函数中测试一下printf函数是否可以正常使用：</p><pre class=" language-c"><code class="language-c">    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello, i am %s\n"</span><span class="token punctuation">,</span> <span class="token string">"mculover666"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Test int: i = %d"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Test float: i = %f"</span><span class="token punctuation">,</span> <span class="token number">1.234</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Test hex: i = 0x%2x"</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* USER CODE END 2 */</span></code></pre><p>结果如下：</p><p><img src="http://mculover666.cn/image/20190819/l3kwHp8d4DPW.png?imageslim" alt="mark"></p><h1 id="3-在MDK中使用标准库重定向printf"><a href="#3-在MDK中使用标准库重定向printf" class="headerlink" title="3.在MDK中使用标准库重定向printf"></a>3.在MDK中使用标准库重定向printf</h1><p>printf 函数使用了半主机模式，所以直接使用标准库会导致程序无法运行，因此必须提前告知编译器不使用半主机模式：</p><ul><li>不使用半主机模式<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 告知连接器不从C库链接使用半主机的函数 */</span><span class="token macro property">#<span class="token directive keyword">pragma</span> import(__use_no_semihosting)</span></code></pre></li></ul><p>/* 定义 _sys_exit() 以避免使用半主机模式 */<br>void _sys_exit(int x)<br>{<br>    x = x;<br>}</p><pre><code>所以，重定向fputc()函数完整的代码如下：```c#if 1#include &lt;stdio.h&gt;/* 告知连接器不从C库链接使用半主机的函数 */#pragma import(__use_no_semihosting)/* 定义 _sys_exit() 以避免使用半主机模式 */void _sys_exit(int x){    x = x;}/* 标准库需要的支持类型 */struct __FILE{    int handle;};FILE __stdout;/*  */int fputc(int ch, FILE *stream){    /* 堵塞判断串口是否发送完成 */    while((USART1-&gt;ISR &amp; 0X40) == 0);    /* 串口发送完成，将该字符发送 */    USART1-&gt;TDR = (uint8_t) ch;    return ch;}#endif</code></pre><h2 id="测试printf-1"><a href="#测试printf-1" class="headerlink" title="测试printf"></a>测试printf</h2><p>测试printf函数的代码不变，在MDK设置中取消勾选<code>USE MICROLIB</code>，然后重新编译，下载代码后试验现象如下：</p><p><img src="http://mculover666.cn/image/20190819/8zhddFdIleFV.png?imageslim" alt="mark"></p><h1 id="4-在GCC中使用标准库重定向printf"><a href="#4-在GCC中使用标准库重定向printf" class="headerlink" title="4.在GCC中使用标准库重定向printf"></a>4.在GCC中使用标准库重定向printf</h1><p><strong>不同的编译器对于C库的底层实现机制是不同的，所以上面两种在MDK中的实现方法，在使用Gcc编译器的时候是不可行的。</strong></p><p>在Gcc中重定向printf函数时注意两个关键点：</p><ul><li>与重定义fputs()函数一样，在使用Gcc编译器的时候，需要重新定义<code>_write</code>函数；</li><li>Gcc中没有MicroLib，只能使用标准库；</li></ul><p>所以重定向printf函数的代码如下：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* USER CODE BEGIN 1 */</span><span class="token macro property">#<span class="token directive keyword">if</span> 1</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">_write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint8_t<span class="token operator">*</span><span class="token punctuation">)</span>ptr<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment" spellcheck="true">/* USER CODE END 1 */</span></code></pre><p>使用STM32CubeMX生成makefile，然后使用arm-none-eabi-gcc编译没有问题，再使用STM32 ST-LINK utility 下载后实验现象如下：</p><p><img src="http://mculover666.cn/image/20190819/PDr0G8VvtqN9.png?imageslim" alt="mark"></p><p>至此，我们已经学会<strong>实现printf()函数的多种方法</strong>，下一节将讲述如何使用ADC读取MQ-2气体传感器的值。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_08 | 使用USART发送和接收数据（DMA模式）</title>
      <link href="/posts/1606619423/"/>
      <url>/posts/1606619423/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要介绍如何使用STM32CubeMX初始化STM32L431RCT6的USART，并使用<strong>DMA模式</strong>发送数据和接收数据。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：</li></ul><p><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt="mark"></p><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li><li>准备一个串口调试助手，这里我使用的是<code>Serial Port Utility</code>；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt="mark"></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：</p><p><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt="mark"></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:</p><p><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt="mark"></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：</p><p><img src="http://mculover666.cn/image/20190806/k593lGGb5tlW.png?imageslim" alt="mark"></p><h2 id="配置串口"><a href="#配置串口" class="headerlink" title="配置串口"></a>配置串口</h2><p>小熊派开发板板载ST-Link并且虚拟了一个串口，原理图如下：</p><p><img src="http://mculover666.cn/image/20190814/IwyXONVefPx9.png?imageslim" alt="mark"></p><p>这里我将开关拨到<code>AT-MCU</code>模式，使PC的串口与USART1之间连接。</p><p>接下来开始配置<code>USART1</code>：</p><p><img src="http://mculover666.cn/image/20190814/nLMRMYtmzghl.png?imageslim" alt="mark"></p><h2 id="USART-DMA配置"><a href="#USART-DMA配置" class="headerlink" title="USART DMA配置"></a>USART DMA配置</h2><blockquote><p>知识小卡片 —— DMA</p></blockquote><p>DMA 全称 <code>Direct Memory Access</code>(直接存储器访问)， 是STM32的一个外设，它的特点在于：</p><p>在<strong>不占用CPU的情况下</strong>将数据从存储器直接搬运到外设，或者从外设直接搬运到存储器，当然也可以从存储器直接搬运到存储器。</p><p>比如在需要串口发送大量数据的时候，CPU只需要<strong>发起DMA传输请求</strong>，然后就可以去做别的事情了，DMA会将数据传输到串口发送，<strong>DMA传输完之后会触发中断</strong>，CPU如果有需要，可以对该中断进行处理，这样一来CPU的效率是不是大大提高了？</p><p>在STM32L431RCT6中有 2 个 DMA 外设：DMA1 和 DMA2，每个DMA外设有 7 个通道，每个通道都是独立的，配置DMA的时候有几个关键点：</p><ul><li>数据从哪里来？</li><li>数据到哪里去？</li><li>有多少数据？</li></ul><blockquote><p>知识小卡片结束啦~对STM32的DMA外设有没有了解呢？</p></blockquote><p>接下来我们配置DMA，将存储器（SRAM）中的数据直接搬运到串口外设去发送：</p><p><img src="http://mculover666.cn/image/20190816/mJTMlVPgHSCJ.png?imageslim" alt="mark"></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：</p><p><img src="http://mculover666.cn/image/20190806/1TQg7frjRpVr.png?imageslim" alt="mark"></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/image/20190816/RUWz76PbSunq.png?imageslim" alt="mark"></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：</p><p><img src="http://mculover666.cn/image/20190812/PwTCS6QzHiyG.png?imageslim" alt="mark"></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：</p><p><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt="mark"></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="定义发送数据区域"><a href="#定义发送数据区域" class="headerlink" title="定义发送数据区域"></a>定义发送数据区域</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Private user code ---------------------------------------------------------*/</span><span class="token comment" spellcheck="true">/* USER CODE BEGIN 0 */</span>uint8_t dat<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello, I am Mculover666.\n"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* USER CODE END 0 */</span></code></pre><h2 id="在main函数中发起DMA传输"><a href="#在main函数中发起DMA传输" class="headerlink" title="在main函数中发起DMA传输"></a>在main函数中发起DMA传输</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span>  <span class="token function">HAL_UART_Transmit_DMA</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint8_t<span class="token operator">*</span><span class="token punctuation">)</span>dat<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>dat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* USER CODE END 2 */</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="实验现象"><a href="#实验现象" class="headerlink" title="实验现象"></a>实验现象</h2><p>编译下载运行后，实验现象如下：</p><p><img src="http://mculover666.cn/image/20190816/pNmCADptVjqr.png?imageslim" alt="mark"></p><h1 id="4-使用DMA接收串口数据"><a href="#4-使用DMA接收串口数据" class="headerlink" title="4. 使用DMA接收串口数据"></a>4. 使用DMA接收串口数据</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>使用HAL库的时候不能同时使用DMA发送和接收数据，会出错。</li><li>所有的步骤和发送时一样，这里我只给出需要修改的部分。</li></ul><h2 id="修改串口DMA配置"><a href="#修改串口DMA配置" class="headerlink" title="修改串口DMA配置"></a>修改串口DMA配置</h2><p><img src="http://mculover666.cn/image/20190818/CqyMnF113eWT.png?imageslim" alt="mark"></p><h2 id="添加串口接收缓冲区"><a href="#添加串口接收缓冲区" class="headerlink" title="添加串口接收缓冲区"></a>添加串口接收缓冲区</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Private user code ---------------------------------------------------------*/</span><span class="token comment" spellcheck="true">/* USER CODE BEGIN 0 */</span>uint8_t dat<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello, I am Mculover666.\n"</span><span class="token punctuation">;</span>uint8_t recv_buf<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//串口接收缓冲区</span><span class="token comment" spellcheck="true">/* USER CODE END 0 */</span></code></pre><h2 id="修改main函数"><a href="#修改main函数" class="headerlink" title="修改main函数"></a>修改main函数</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">MX_DMA_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span>  <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint8_t<span class="token operator">*</span><span class="token punctuation">)</span>dat<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>dat<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">HAL_UART_Receive_DMA</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> recv_buf<span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//使能DMA接收</span>  <span class="token comment" spellcheck="true">/* USER CODE END 2 */</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="添加串口接收中断回调函数"><a href="#添加串口接收中断回调函数" class="headerlink" title="添加串口接收中断回调函数"></a>添加串口接收中断回调函数</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* USER CODE BEGIN 4 */</span><span class="token keyword">void</span> <span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//将接收到的数据再发送</span>    <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span>recv_buf<span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* USER CODE END 4 */</span></code></pre><h2 id="实验现象-1"><a href="#实验现象-1" class="headerlink" title="实验现象"></a>实验现象</h2><p><img src="http://mculover666.cn/image/20190818/lgWCp78edRWz.png?imageslim" alt="mark"></p><p>至此，我们已经学会了<strong>如何配置USART使用DMA模式发送数据和接收数据</strong>，下一节将讨论实现printf()函数的多种方法。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_07 | 使用USART发送和接收数据（中断模式）</title>
      <link href="/posts/1803605667/"/>
      <url>/posts/1803605667/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要介绍如何使用STM32CubeMX初始化STM32L431RCT6的USART，并使用<strong>中断模式</strong>发送和接收数据。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：</li></ul><p><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt="mark"></p><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li><li>准备一个串口调试助手，这里我使用的是<code>Serial Port Utility</code>；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt="mark"></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：</p><p><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt="mark"></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:</p><p><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt="mark"></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：</p><p><img src="http://mculover666.cn/image/20190806/k593lGGb5tlW.png?imageslim" alt="mark"></p><h2 id="配置串口"><a href="#配置串口" class="headerlink" title="配置串口"></a>配置串口</h2><p>小熊派开发板板载ST-Link并且虚拟了一个串口，原理图如下：</p><p><img src="http://mculover666.cn/image/20190814/IwyXONVefPx9.png?imageslim" alt="mark"></p><p>这里我将开关拨到<code>AT-MCU</code>模式，使PC的串口与USART1之间连接。</p><p>接下来开始配置<code>USART1</code>：</p><p><img src="http://mculover666.cn/image/20190814/nLMRMYtmzghl.png?imageslim" alt="mark"></p><h2 id="NVIC配置"><a href="#NVIC配置" class="headerlink" title="NVIC配置"></a>NVIC配置</h2><p>在NVIC中配置USART中断优先级：</p><p><img src="http://mculover666.cn/image/20190816/Uw6jxzmblvJW.png?imageslim" alt="mark"></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：</p><p><img src="http://mculover666.cn/image/20190806/1TQg7frjRpVr.png?imageslim" alt="mark"></p><p><img src="http://mculover666.cn/image/20190814/AITGSflAXS45.png?imageslim" alt="mark"></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/image/20190816/RUWz76PbSunq.png?imageslim" alt="mark"></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：</p><p><img src="http://mculover666.cn/image/20190812/PwTCS6QzHiyG.png?imageslim" alt="mark"></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：</p><p><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt="mark"></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="定义发送和接收缓冲区"><a href="#定义发送和接收缓冲区" class="headerlink" title="定义发送和接收缓冲区"></a>定义发送和接收缓冲区</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Private user code ---------------------------------------------------------*/</span><span class="token comment" spellcheck="true">/* USER CODE BEGIN 0 */</span>uint8_t hello<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"USART1 is ready...\n"</span><span class="token punctuation">;</span>uint8_t recv_buf<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* USER CODE END 0 */</span></code></pre><h2 id="重新实现中断回调函数"><a href="#重新实现中断回调函数" class="headerlink" title="重新实现中断回调函数"></a>重新实现中断回调函数</h2><p>在NVIC一讲中我们探索了HAL库的中断处理机制，HAL中弱定义了一个中断回调函数 <code>HAL_UART_RxCpltCallback</code>， 我们需要在用户文件中重新定义该函数，放在哪都可以，这里我放在 <code>main.c</code> 中：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* USER CODE BEGIN 4 */</span><span class="token comment" spellcheck="true">/* 中断回调函数 */</span><span class="token keyword">void</span> <span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 判断是哪个串口触发的中断 */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>huart <span class="token operator">-></span>Instance <span class="token operator">==</span> USART1<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//将接收到的数据发送</span>        <span class="token function">HAL_UART_Transmit_IT</span><span class="token punctuation">(</span>huart<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint8_t<span class="token operator">*</span><span class="token punctuation">)</span>recv_buf<span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//重新使能串口接收中断</span>        <span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span>huart<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint8_t<span class="token operator">*</span><span class="token punctuation">)</span>recv_buf<span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* USER CODE END 4 */</span></code></pre><h2 id="修改main函数"><a href="#修改main函数" class="headerlink" title="修改main函数"></a>修改main函数</h2><p>在main函数中首先开启串口中断接收，然后发送提示信息：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span>  <span class="token comment" spellcheck="true">//使能串口中断接收</span>  <span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint8_t<span class="token operator">*</span><span class="token punctuation">)</span>recv_buf<span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//发送提示信息</span>  <span class="token function">HAL_UART_Transmit_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint8_t<span class="token operator">*</span><span class="token punctuation">)</span>hello<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* USER CODE END 2 */</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h2><p>编译整个工程：</p><p><img src="http://mculover666.cn/image/20190816/u6VALN7Rhqr0.png?imageslim" alt="mark"></p><h2 id="设置下载器"><a href="#设置下载器" class="headerlink" title="设置下载器"></a>设置下载器</h2><p><img src="http://mculover666.cn/image/20190812/PHve6DYPkO9M.png?imageslim" alt="mark"></p><p><img src="http://mculover666.cn/image/20190812/djSNbMCj6Hh6.png?imageslim" alt="mark"></p><h2 id="实验现象"><a href="#实验现象" class="headerlink" title="实验现象"></a>实验现象</h2><p>下载运行后，实验现象如下：</p><p><img src="http://mculover666.cn/image/20190816/RJHLbTakyimI.png?imageslim" alt="mark"></p><p>至此，我们已经学会了<strong>如何配置USART使用中断模式发送和接收数据</strong>，下一节将讨论实现printf()函数的多种方法。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_06 | 使用USART发送和接收数据（查询模式）</title>
      <link href="/posts/2064921339/"/>
      <url>/posts/2064921339/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要介绍如何使用STM32CubeMX初始化STM32L431RCT6的USART，并使用查询模式发送数据，使用查询模式接收数据。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：</li></ul><p><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt="mark"></p><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li><li>准备一个串口调试助手，这里我使用的是<code>Serial Port Utility</code>；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt="mark"></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：</p><p><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt="mark"></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:</p><p><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt="mark"></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：</p><p><img src="http://mculover666.cn/image/20190806/k593lGGb5tlW.png?imageslim" alt="mark"></p><h2 id="配置串口"><a href="#配置串口" class="headerlink" title="配置串口"></a>配置串口</h2><p>小熊派开发板板载ST-Link并且虚拟了一个串口，原理图如下：</p><p><img src="http://mculover666.cn/image/20190814/IwyXONVefPx9.png?imageslim" alt="mark"></p><p>这里我将开关拨到<code>AT-MCU</code>模式，使PC的串口与USART1之间连接。</p><p>接下来开始配置<code>USART1</code>：</p><p><img src="http://mculover666.cn/image/20190814/nLMRMYtmzghl.png?imageslim" alt="mark"></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：</p><p><img src="http://mculover666.cn/image/20190806/1TQg7frjRpVr.png?imageslim" alt="mark"></p><p><img src="http://mculover666.cn/image/20190814/AITGSflAXS45.png?imageslim" alt="mark"></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/image/20190814/4Bb6RzhdGGnH.png?imageslim" alt="mark"></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：</p><p><img src="http://mculover666.cn/image/20190812/PwTCS6QzHiyG.png?imageslim" alt="mark"></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：</p><p><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt="mark"></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="编写查询模式发送和接收代码"><a href="#编写查询模式发送和接收代码" class="headerlink" title="编写查询模式发送和接收代码"></a>编写查询模式发送和接收代码</h2><p>编写 <code>main</code> 函数如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* USER CODE BEGIN 1 */</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello World\n"</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> recv_buf<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* USER CODE END 1 */</span>  <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span>    <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint8_t<span class="token operator">*</span><span class="token punctuation">)</span>str<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* USER CODE END 2 */</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* USER CODE END WHILE */</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 3 */</span>    <span class="token comment" spellcheck="true">//接收12个字节的数据，不超时</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>HAL_OK <span class="token operator">==</span> <span class="token function">HAL_UART_Receive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint8_t<span class="token operator">*</span><span class="token punctuation">)</span>recv_buf<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//将接收到的数据发送</span>      <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint8_t<span class="token operator">*</span><span class="token punctuation">)</span>recv_buf<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* USER CODE END 3 */</span><span class="token punctuation">}</span></code></pre><h2 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h2><p>编译整个工程：</p><p><img src="http://mculover666.cn/image/20190814/cQclXS2zTHaV.png?imageslim" alt="mark"></p><h2 id="设置下载器"><a href="#设置下载器" class="headerlink" title="设置下载器"></a>设置下载器</h2><p><img src="http://mculover666.cn/image/20190812/PHve6DYPkO9M.png?imageslim" alt="mark"></p><p><img src="http://mculover666.cn/image/20190812/djSNbMCj6Hh6.png?imageslim" alt="mark"></p><h2 id="实验现象"><a href="#实验现象" class="headerlink" title="实验现象"></a>实验现象</h2><p>下载运行后，实验现象如下：</p><p><img src="http://mculover666.cn/image/20190814/kQYbI27K2aQP.png?imageslim" alt="mark"></p><p>至此，我们已经学会了<strong>如何配置USART使用查询模式发送和接收数据</strong>，下一节将讲述如何配置USART使用中断模式接收数据。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_05 | 使用EXIT中断检测按键</title>
      <link href="/posts/2504113390/"/>
      <url>/posts/2504113390/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要介绍如何使用STM32CubeMX初始化STM32L431RCT6的EXIT检测按键，讲述了一些NVIC的小知识，并一步一步探索了HAL库的中断处理机制。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：</li></ul><p><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt="mark"></p><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt="mark"></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：</p><p><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt="mark"></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:</p><p><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt="mark"></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：</p><p><img src="http://mculover666.cn/image/20190806/k593lGGb5tlW.png?imageslim" alt="mark"></p><h2 id="配置LED的GPIO引脚"><a href="#配置LED的GPIO引脚" class="headerlink" title="配置LED的GPIO引脚"></a>配置LED的GPIO引脚</h2><p>查看小熊派开发板的原理图，如下：</p><p><img src="http://mculover666.cn/image/20190812/5iCtQUfKbgzA.png?imageslim" alt="mark"></p><p>所以接下来我们选择配置<code>PC13</code>引脚：</p><p><img src="http://mculover666.cn/image/20190812/Ad3UrGCsgjXr.png?imageslim" alt="mark"></p><p>设置用户标签为LED：</p><p><img src="http://mculover666.cn/image/20190813/ClKDFmVJYceI.png?imageslim" alt="mark"></p><p>给PC13引脚设置一个user_label:</p><p><img src="http://mculover666.cn/blog/20191203/Xs7BxveXoyYs.png?imageslim" alt=""></p><blockquote><p>这里给PC13引脚添加一个user_label后，cubemx软件会在<code>main.h</code>文件中添加一个宏定义，如图，我们可以使用<code>LED_GPIO_Port</code>, <code>LED_Pin</code>来表示这个引脚，提高了程序的可移植性。如果没有该user_label，就需要使用<code>GPIOC</code>，<code>GPIO_PIN_13</code> 来表示这个引脚。</p></blockquote><p><img src="http://mculover666.cn/blog/20191203/fvPWgmNK4NU7.png?imageslim" alt=""></p><h2 id="配置GPIO引脚为外部中断引脚"><a href="#配置GPIO引脚为外部中断引脚" class="headerlink" title="配置GPIO引脚为外部中断引脚"></a>配置GPIO引脚为外部中断引脚</h2><p>查看小熊派开发板的原理图，如下：</p><p><img src="http://mculover666.cn/image/20190813/QNbG5i6QKGk3.png?imageslim" alt="mark"></p><p>所以接下来我们选择配置<code>PB2</code>引脚和<code>PB3</code>引脚为外部中断引脚：</p><p><img src="http://mculover666.cn/image/20190814/uqRDYJldwiwk.png?imageslim" alt="mark"></p><p>因为没有设置硬件上拉，所以我们配置开启上拉电阻，并设置用户标签为<code>KEY1</code>和<code>KEY2</code>，接下来是最重要的一步：</p><ul><li>开启下降沿触发中断：即在<strong>按下按键时</strong>电平由高变为低时触发</li><li>开启上升沿触发中断：即在<strong>按下按键后松开时</strong>电平由低变为高时触发</li><li>开启下降沿上升沿都触发中断：即在<strong>按下时触发，松开时再次触发</strong></li></ul><p>这里我选择开启下降沿触发中断：</p><p><img src="http://mculover666.cn/image/20190814/Kt7hrzxmbjVq.png?imageslim" alt="mark"></p><h2 id="配置NVIC设置中断优先级"><a href="#配置NVIC设置中断优先级" class="headerlink" title="配置NVIC设置中断优先级"></a>配置NVIC设置中断优先级</h2><blockquote><p>知识小卡片 —— NVIC</p></blockquote><p>NVIC全称<code>Nested vectored interrupt controller</code>，即嵌套向量中断控制器，用来决定<strong>中断的优先级</strong>。</p><p>NVIC在 ARM Conrtex-M 内核中，用一个 8 位的寄存器来配置，总共可以配置$2^8=256$级中断，但是 ST 公司在生产 STM32 的时候，发现一个小小的单片机根本用不了这么多，纯属浪费，所以将该寄存器的<code>低 4 位</code> 全部置0，只使用<code>高 4 位</code>来配置，这样一来 STM32 就只有$2^4=16$级中断啦。</p><p>简化为16级中断后，ST发现 STM32 内部这么丰富的外设，还是不方便配置，干脆<strong>人工给这4位来个分组</strong>，划分出了5个分组：</p><table><thead><tr><th align="center">优先级分组</th><th align="center">抢占优先级占的位数</th><th align="center">子优先级占的位数</th></tr></thead><tbody><tr><td align="center">NVIC_PriorityGroup_0</td><td align="center">0 bit</td><td align="center">4 bit</td></tr><tr><td align="center">NVIC_PriorityGroup_1</td><td align="center">1 bit</td><td align="center">3 bit</td></tr><tr><td align="center">NVIC_PriorityGroup_2</td><td align="center">2 bit</td><td align="center">2 bit</td></tr><tr><td align="center">NVIC_PriorityGroup_3</td><td align="center">3 bit</td><td align="center">1 bit</td></tr><tr><td align="center">NVIC_PriorityGroup_4</td><td align="center">4 bit</td><td align="center">0 bit</td></tr></tbody></table><p>再次强调一下，这5种中断分组规则是人为的，用哪种规则，之后设置具体的优先级时对应就行，STM32默认使用的规则是 NVIC_PriorityGroup_0 。</p><p>STM32 的CPU判断优先级的方法如下：</p><ul><li>先判断抢占优先级，数字越小，优先级越高；</li><li>若抢占优先级相同，判断子优先级，同样，数字越小，优先级越高；</li></ul><blockquote><p>知识小卡片结束啦~ 对NVIC有没有了解呢？</p></blockquote><p>接下来在STM32CubeMX中配置中断优先级：</p><h3 id="配置优先级分组"><a href="#配置优先级分组" class="headerlink" title="配置优先级分组"></a>配置优先级分组</h3><p>这里我配置使用中断优先级分组规则 NVIC_PriorityGroup_2：</p><p><img src="http://mculover666.cn/image/20190814/bfVkymV1nHBy.png?imageslim" alt="mark"></p><h3 id="配置具体的优先级大小"><a href="#配置具体的优先级大小" class="headerlink" title="配置具体的优先级大小"></a>配置具体的优先级大小</h3><p>根据中断优先级分组规则 NVIC_PriorityGroup_2来设置具体的优先级大小：</p><p><img src="http://mculover666.cn/image/20190814/SvOnnceuPG9n.png?imageslim" alt="mark"></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：</p><p><img src="http://mculover666.cn/image/20190806/1TQg7frjRpVr.png?imageslim" alt="mark"></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/image/20190814/H2VnDFkiF0JQ.png?imageslim" alt="mark"></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：</p><p><img src="http://mculover666.cn/image/20190812/PwTCS6QzHiyG.png?imageslim" alt="mark"></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：</p><p><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt="mark"></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="STM32-HAL库中断处理机制"><a href="#STM32-HAL库中断处理机制" class="headerlink" title="STM32 HAL库中断处理机制"></a>STM32 HAL库中断处理机制</h2><p>先打开<code>stm32l4xx_it.c</code>文件：</p><p><img src="http://mculover666.cn/image/20190814/U0mhU0pBakNc.png?imageslim" alt="mark"></p><p>可以看到其中处理EXIT2和EXIT3中断都调用了同一个函数，但是EXIT2和EXIT3向该函数传入的参数不同：</p><pre class=" language-c"><code class="language-c"><span class="token function">HAL_GPIO_EXTI_IRQHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>那么，HAL库对于中断是如何处理的呢？我们打开 <code>stm32l4xx_hal_gpio.c</code> 文件，看一下该函数的原型，一探究竟：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/**  * @brief  Handle EXTI interrupt request.  * @param  GPIO_Pin Specifies the port pin connected to corresponding EXTI line.  * @retval None  */</span><span class="token keyword">void</span> <span class="token function">HAL_GPIO_EXTI_IRQHandler</span><span class="token punctuation">(</span>uint16_t GPIO_Pin<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* EXTI line interrupt detected */</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">__HAL_GPIO_EXTI_GET_IT</span><span class="token punctuation">(</span>GPIO_Pin<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0x00u</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">__HAL_GPIO_EXTI_CLEAR_IT</span><span class="token punctuation">(</span>GPIO_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">HAL_GPIO_EXTI_Callback</span><span class="token punctuation">(</span>GPIO_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到，在该函数中首先读取了一下中断寄存器，确认该中断是否发生，确认之后又调用了一个函数，并将接收到的参数 <code>GPIO_Pin</code> 继续传给该函数：</p><pre class=" language-c"><code class="language-c"><span class="token function">HAL_GPIO_EXTI_Callback</span><span class="token punctuation">(</span>GPIO_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>该函数称为EXIT中断的回调函数，用来处理所有发生的EXIT中断事件。</strong></p><p>那么，这个函数又干了什么呢？接着探索哈哈哈~</p><p>同样在<code>stm32l4xx_hal_gpio.c</code>文件中找到该函数的原型：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/**  * @brief  EXTI line detection callback.  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.  * @retval None  */</span>__weak <span class="token keyword">void</span> <span class="token function">HAL_GPIO_EXTI_Callback</span><span class="token punctuation">(</span>uint16_t GPIO_Pin<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* Prevent unused argument(s) compilation warning */</span>  <span class="token function">UNUSED</span><span class="token punctuation">(</span>GPIO_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* NOTE: This function should not be modified, when the callback is needed,           the HAL_GPIO_EXTI_Callback could be implemented in the user file   */</span><span class="token punctuation">}</span></code></pre><p>哈哈哈，这下是不是非常清楚了~</p><p>该回调函数使用<code>__weak</code>进行了弱定义，所以<strong>用户可以再次定义该函数</strong>，并且这个<code>note</code>写的非常清楚：</p><blockquote><p>这个函数不应该被改变，如果需要使用回调函数，请重新在用户文件中实现该函数。</p></blockquote><h2 id="自己实现EXIT中断处理回调函数"><a href="#自己实现EXIT中断处理回调函数" class="headerlink" title="自己实现EXIT中断处理回调函数"></a>自己实现EXIT中断处理回调函数</h2><p>这个函数放在哪都行，为了方便，我们放在<code>gpio.c</code>的最后。</p><p>实现的基本思想是：</p><ul><li>因为所有的EXIT中断都会调用该函数，所以首先判断具体的中断事件；</li><li>对该中断事件进行处理</li></ul><p>实现代码如下：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* USER CODE BEGIN 2 */</span><span class="token comment" spellcheck="true">/** * @brief    EXIT中断回调函数 * @param GPIO_Pin —— 触发中断的引脚 * @retval    none*/</span><span class="token keyword">void</span> <span class="token function">HAL_GPIO_EXTI_Callback</span><span class="token punctuation">(</span>uint16_t GPIO_Pin<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 判断哪个引脚触发了中断 */</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>GPIO_Pin<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">case</span> GPIO_PIN_2<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">/* 处理GPIO2发生的中断 */</span>            <span class="token comment" spellcheck="true">//点亮LED</span>            <span class="token function">HAL_GPIO_WritePin</span><span class="token punctuation">(</span>LED_GPIO_Port<span class="token punctuation">,</span>LED_Pin<span class="token punctuation">,</span>GPIO_PIN_SET<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> GPIO_PIN_3<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">/* 处理GPIO3发生的中断 */</span>            <span class="token comment" spellcheck="true">//熄灭LED</span>            <span class="token function">HAL_GPIO_WritePin</span><span class="token punctuation">(</span>LED_GPIO_Port<span class="token punctuation">,</span>LED_Pin<span class="token punctuation">,</span>GPIO_PIN_RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* USER CODE END 2 */</span></code></pre><h2 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h2><p>编译整个工程：</p><p><img src="http://mculover666.cn/image/20190814/cQclXS2zTHaV.png?imageslim" alt="mark"></p><h2 id="设置下载器"><a href="#设置下载器" class="headerlink" title="设置下载器"></a>设置下载器</h2><p><img src="http://mculover666.cn/image/20190812/PHve6DYPkO9M.png?imageslim" alt="mark"></p><p><img src="http://mculover666.cn/image/20190812/djSNbMCj6Hh6.png?imageslim" alt="mark"></p><h2 id="实验现象"><a href="#实验现象" class="headerlink" title="实验现象"></a>实验现象</h2><p>下载运行后，实验现象如下：</p><ul><li>上电复位时LED处于熄灭状态；</li><li>按下KEY1，LED点亮；</li><li>按下KEY2，LED熄灭；</li></ul><p><img src="http://mculover666.cn/image/20190814/M5YtUckjugDP.png?imageslim" alt="mark"></p><p>至此，我们已经学会了<strong>如何配置NVIC使用外部中断检测按键</strong>，并了解了NVIC和HAL库中断处理机制的一些基本知识，下一节讲述如何配置USART以及实现<code>printf</code>函数。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_04 | 使用GPIO进行按键检测</title>
      <link href="/posts/1763774108/"/>
      <url>/posts/1763774108/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要介绍如何使用STM32CubeMX初始化STM32L431RCT6的GPIO，并扫描检测按键。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：</li></ul><p><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt="mark"></p><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt="mark"></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：</p><p><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt="mark"></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:</p><p><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt="mark"></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：</p><p><img src="http://mculover666.cn/image/20190806/k593lGGb5tlW.png?imageslim" alt="mark"></p><h2 id="配置LED的GPIO引脚"><a href="#配置LED的GPIO引脚" class="headerlink" title="配置LED的GPIO引脚"></a>配置LED的GPIO引脚</h2><p>查看小熊派开发板的原理图，如下：</p><p><img src="http://mculover666.cn/image/20190812/5iCtQUfKbgzA.png?imageslim" alt="mark"></p><p>所以接下来我们选择配置<code>PC13</code>引脚：</p><p><img src="http://mculover666.cn/image/20190812/Ad3UrGCsgjXr.png?imageslim" alt="mark"></p><p>设置用户标签为LED：</p><p><img src="http://mculover666.cn/image/20190813/ClKDFmVJYceI.png?imageslim" alt="mark"></p><p>给PC13引脚设置一个user_label:</p><p><img src="http://mculover666.cn/blog/20191203/Xs7BxveXoyYs.png?imageslim" alt=""></p><blockquote><p>这里给PC13引脚添加一个user_label后，cubemx软件会在<code>main.h</code>文件中添加一个宏定义，如图，我们可以使用<code>LED_GPIO_Port</code>, <code>LED_Pin</code>来表示这个引脚，提高了程序的可移植性。如果没有该user_label，就需要使用<code>GPIOC</code>，<code>GPIO_PIN_13</code> 来表示这个引脚。</p></blockquote><p><img src="http://mculover666.cn/blog/20191203/fvPWgmNK4NU7.png?imageslim" alt=""></p><h2 id="配置按键的GPIO引脚"><a href="#配置按键的GPIO引脚" class="headerlink" title="配置按键的GPIO引脚"></a>配置按键的GPIO引脚</h2><p>查看小熊派开发板的原理图，如下：</p><p><img src="http://mculover666.cn/image/20190813/QNbG5i6QKGk3.png?imageslim" alt="mark"></p><p>所以接下来我们选择配置<code>PB2</code>引脚和<code>PB3</code>引脚：</p><p><img src="http://mculover666.cn/image/20190813/3fRF4dWxJ6iw.png?imageslim" alt="mark"></p><p>因为没有设置硬件上拉，所以我们配置开启上拉电阻，并设置用户标签为<code>KEY1</code>和<code>KEY2</code>：</p><p><img src="http://mculover666.cn/image/20190813/sjhFpsdWkQSB.png?imageslim" alt="mark"></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：</p><p><img src="http://mculover666.cn/image/20190806/1TQg7frjRpVr.png?imageslim" alt="mark"></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/image/20190813/4cGrWhVnjEdp.png?imageslim" alt="mark"></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：</p><p><img src="http://mculover666.cn/image/20190812/PwTCS6QzHiyG.png?imageslim" alt="mark"></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：</p><p><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt="mark"></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="编写用户代码"><a href="#编写用户代码" class="headerlink" title="编写用户代码"></a>编写用户代码</h2><p>进入<code>MDK-ARM</code>目录，打开工程，在<code>main.c</code>中的main函数中编写简单的用户代码：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 3 */</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> <span class="token function">HAL_GPIO_ReadPin</span><span class="token punctuation">(</span>KEY1_GPIO_Port<span class="token punctuation">,</span> KEY1_Pin<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">HAL_GPIO_WritePin</span><span class="token punctuation">(</span>LED_GPIO_Port<span class="token punctuation">,</span>LED_Pin<span class="token punctuation">,</span>GPIO_PIN_SET<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> <span class="token function">HAL_GPIO_ReadPin</span><span class="token punctuation">(</span>KEY2_GPIO_Port<span class="token punctuation">,</span> KEY2_Pin<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">HAL_GPIO_WritePin</span><span class="token punctuation">(</span>LED_GPIO_Port<span class="token punctuation">,</span>LED_Pin<span class="token punctuation">,</span>GPIO_PIN_RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* USER CODE END 3 */</span><span class="token punctuation">}</span></code></pre><h2 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h2><p>编译整个工程：</p><p><img src="http://mculover666.cn/image/20190813/T9TxAoP6pyiI.png?imageslim" alt="mark"></p><h2 id="设置下载器"><a href="#设置下载器" class="headerlink" title="设置下载器"></a>设置下载器</h2><p><img src="http://mculover666.cn/image/20190812/PHve6DYPkO9M.png?imageslim" alt="mark"></p><p><img src="http://mculover666.cn/image/20190812/djSNbMCj6Hh6.png?imageslim" alt="mark"></p><h2 id="实验现象"><a href="#实验现象" class="headerlink" title="实验现象"></a>实验现象</h2><p>下载运行后，实验现象如下：</p><ul><li>上电复位时LED处于熄灭状态；</li><li>按下KEY1，LED点亮；</li><li>按下KEY2，LED熄灭；</li></ul><p><img src="http://mculover666.cn/image/20190813/jrREJBcJukl3.png?imageslim" alt="mark"></p><p>至此，我们已经学会了<strong>如何使用STM32CubeMX快速生成MDK的工程</strong>，以及<strong>如何使用 STM32CubeMX初始化GPIO进行按键检测</strong>，下一节讲述如何配置NVIC使用外部中断检测按键。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_03 | 使用GPIO点亮一个LED</title>
      <link href="/posts/2046075734/"/>
      <url>/posts/2046075734/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要介绍如何使用STM32CubeMX初始化STM32L431RCT6的GPIO，并点亮一个LED。</p><a id="more"></a><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul><li>开发板<br>首先需要准备一个开发板，这里我准备的是STM32L4的开发板（BearPi）：</li></ul><p><img src="http://mculover666.cn/image/20190806/9uiPTi5odYSj.png?imageslim" alt="mark"></p><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ul><li>需要安装好Keil - MDK及芯片对应的包，以便编译和下载生成的代码；</li></ul><blockquote><p>Keil MDK和串口助手Serial Port Utility 的安装包都可以<strong>在文末关注公众号获取</strong>，回复关键字获取相应的安装包：</p></blockquote><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt="mark"></p><h1 id="2-生成MDK工程"><a href="#2-生成MDK工程" class="headerlink" title="2.生成MDK工程"></a>2.生成MDK工程</h1><blockquote><p>如果使用的是STM32F1系列，请先看这篇文章！！！（<a href="https://blog.csdn.net/Mculover666/article/details/104802410" target="_blank" rel="noopener">STM32CubeMX生成F1的工程中造成 下载器无法下载 问题的解决方案</a>）</p></blockquote><h2 id="选择芯片型号"><a href="#选择芯片型号" class="headerlink" title="选择芯片型号"></a>选择芯片型号</h2><p>打开STM32CubeMX，打开MCU选择器：</p><p><img src="http://mculover666.cn/image/20190806/gBP6glmUSH80.png?imageslim" alt="mark"></p><p>搜索并选中芯片<code>STM32L431RCT6</code>:</p><p><img src="http://mculover666.cn/image/20190806/gnyHwdl53uVD.png?imageslim" alt="mark"></p><h2 id="配置时钟源"><a href="#配置时钟源" class="headerlink" title="配置时钟源"></a>配置时钟源</h2><ul><li>如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</li><li>如果使用默认内部时钟（HSI），这一步可以略过；</li></ul><p>这里我都使用外部时钟：</p><p><img src="http://mculover666.cn/image/20190806/k593lGGb5tlW.png?imageslim" alt="mark"></p><h2 id="配置GPIO引脚"><a href="#配置GPIO引脚" class="headerlink" title="配置GPIO引脚"></a>配置GPIO引脚</h2><p>查看小熊派开发板的原理图，如下：</p><p><img src="http://mculover666.cn/image/20190812/5iCtQUfKbgzA.png?imageslim" alt="mark"></p><p>所以接下来我们选择配置<code>PC13</code>引脚：</p><p><img src="http://mculover666.cn/image/20190812/Ad3UrGCsgjXr.png?imageslim" alt="mark"></p><p>给PC13引脚设置一个user_label:</p><p><img src="http://mculover666.cn/blog/20191203/Xs7BxveXoyYs.png?imageslim" alt=""></p><blockquote><p>这里给PC13引脚添加一个user_label后，cubemx软件会在<code>main.h</code>文件中添加一个宏定义，如图，我们可以使用<code>LED_GPIO_Port</code>, <code>LED_Pin</code>来表示这个引脚，提高了程序的可移植性。如果没有该user_label，就需要使用<code>GPIOC</code>，<code>GPIO_PIN_13</code> 来表示这个引脚。</p></blockquote><p><img src="http://mculover666.cn/blog/20191203/fvPWgmNK4NU7.png?imageslim" alt=""></p><h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32L4的最高主频到80M，所以配置PLL，最后使<code>HCLK = 80Mhz</code>即可：</p><p><img src="http://mculover666.cn/image/20190806/1TQg7frjRpVr.png?imageslim" alt="mark"></p><h2 id="生成工程设置"><a href="#生成工程设置" class="headerlink" title="生成工程设置"></a>生成工程设置</h2><p><img src="http://mculover666.cn/image/20190812/JRur8DQQ4saC.png?imageslim" alt="mark"></p><h2 id="代码生成设置"><a href="#代码生成设置" class="headerlink" title="代码生成设置"></a>代码生成设置</h2><p>最后设置生成独立的初始化文件：</p><p><img src="http://mculover666.cn/image/20190812/PwTCS6QzHiyG.png?imageslim" alt="mark"></p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>点击<code>GENERATE CODE</code>即可生成MDK-V5工程：</p><p><img src="http://mculover666.cn/image/20190806/s0jGhLBWW6Cm.png?imageslim" alt="mark"></p><h2 id="生成成功"><a href="#生成成功" class="headerlink" title="生成成功"></a>生成成功</h2><p><img src="http://mculover666.cn/image/20190812/Rut0y7ovQGsf.png?imageslim" alt="mark"></p><h1 id="3-在MDK中编写、编译、下载用户代码"><a href="#3-在MDK中编写、编译、下载用户代码" class="headerlink" title="3. 在MDK中编写、编译、下载用户代码"></a>3. 在MDK中编写、编译、下载用户代码</h1><h2 id="编写用户代码"><a href="#编写用户代码" class="headerlink" title="编写用户代码"></a>编写用户代码</h2><p>STM32CubeMX生成的代码目录如下：</p><p><img src="http://mculover666.cn/image/20190812/yEi9PbChnxjU.png?imageslim" alt="mark"></p><p>进入<code>MDK-ARM</code>目录，打开工程：</p><p><img src="http://mculover666.cn/image/20190812/wsGU4swrhD4b.png?imageslim" alt="mark"></p><p>在<code>main.c</code>中的main函数中编写简单的用户代码：</p><pre class=" language-c"><code class="language-c">  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* USER CODE END WHILE */</span>    <span class="token comment" spellcheck="true">/* USER CODE BEGIN 3 */</span>    <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">HAL_GPIO_TogglePin</span><span class="token punctuation">(</span>GPIOC<span class="token punctuation">,</span> GPIO_PIN_13<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><h2 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h2><p>编译整个工程：</p><p><img src="http://mculover666.cn/image/20190812/Rh3CJlu7Hx8o.png?imageslim" alt="mark"></p><h2 id="设置下载器"><a href="#设置下载器" class="headerlink" title="设置下载器"></a>设置下载器</h2><p><img src="http://mculover666.cn/image/20190812/PHve6DYPkO9M.png?imageslim" alt="mark"></p><p><img src="http://mculover666.cn/image/20190812/djSNbMCj6Hh6.png?imageslim" alt="mark"></p><h2 id="下载运行"><a href="#下载运行" class="headerlink" title="下载运行"></a>下载运行</h2><p><img src="http://mculover666.cn/image/20190812/lLANsFr5iOb7.png?imageslim" alt="mark"></p><h2 id="实验现象"><a href="#实验现象" class="headerlink" title="实验现象"></a>实验现象</h2><p><img src="http://mculover666.cn/image/20190812/YCAOK10iYrQN.png?imageslim" alt="mark"></p><p>至此，我们已经学会了<strong>如何使用STM32CubeMX快速生成MDK的工程</strong>，点亮一个LED，接下来一节讲述如何使用 STM32CubeMX初始化GPIO进行按键检测。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_02 | 获取并安装STM32CubeMX</title>
      <link href="/posts/2106737533/"/>
      <url>/posts/2106737533/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要介绍如何获取并安装STM32CubeMX。</p><a id="more"></a><p>本文中涉及到的安装包可以在官网下载到，速度比较慢，为了方便大家，我已上传到百度网盘，为了确保资源的更新，我没有直接放上链接，可以在<strong>文末</strong>关注我的微信公众号，回复“<strong>STM32CubeMX</strong>”获取，敬请原谅~</p><p><img src="http://mculover666.cn/image/20190814/gubaOwmETp1w.png?imageslim" alt="mark"></p><h1 id="1-安装Java环境（JRE）"><a href="#1-安装Java环境（JRE）" class="headerlink" title="1.安装Java环境（JRE）"></a>1.安装Java环境（JRE）</h1><p>因为STM32CubeMX是采用Java语言编写的，所以需要<strong>先在电脑上安装Java运行环境</strong>（JRE，Java runtime Environment），安装JRE时建议<strong>选择Java 8或者以后的版本</strong>。</p><p>安装JRE有两种方式：</p><ul><li>单独的安装Jre；</li><li>直接安装开发者套件JDK，其中就包括了JRE，这样以后还能用于开发Java。</li></ul><p>这里我选择第二种，安装JDK8不是本文的重点，具体请参考我的Java系列文章或者网上自行搜索。</p><h1 id="2-获取STM32CubeMX"><a href="#2-获取STM32CubeMX" class="headerlink" title="2.获取STM32CubeMX"></a>2.获取STM32CubeMX</h1><p>STM32CubeMX可以访问STM32官网( <a href="https://www.st.com/en/development-tools/stm32cubemx.html" target="_blank" rel="noopener">https://www.st.com/en/development-tools/stm32cubemx.html</a> )获取：</p><p><img src="http://mculover666.cn/image/20190811/bWTWrfuJnhX5.png?imageslim" alt="mark"></p><p>然后同意下载协议，填写一些信息，ST会向填写的邮箱中发送一封邮件，点击邮件中的链接即可下载。</p><h1 id="3-安装STM32CubeMX"><a href="#3-安装STM32CubeMX" class="headerlink" title="3.安装STM32CubeMX"></a>3.安装STM32CubeMX</h1><p>解压下载的压缩包，其中包含三个平台的安装包和一个发布说明，这里我们选择Windows平台的安装包：</p><p><img src="http://mculover666.cn/image/20190811/JmkwIDTsSWo1.png?imageslim" alt="mark"></p><p>双击运行安装程序，安装过程如下：</p><p><img src="http://mculover666.cn/image/20190811/QRiGcKFGel1T.png?imageslim" alt="mark"></p><p>选择是否同意许可协议：</p><p><img src="http://mculover666.cn/image/20190811/P8S8GriWkoyG.png?imageslim" alt="mark"></p><p><img src="http://mculover666.cn/image/20190811/1c4D5wBFVV9e.png?imageslim" alt="mark"></p><p>选择STM32CubeMX安装目录，注意<strong>不能有中文或者空格</strong>：</p><p><img src="http://mculover666.cn/image/20190811/YH9UCGaHSIX7.png?imageslim" alt="mark"></p><p>如果这个目录不存在，会提示是否创建该目录：</p><p><img src="http://mculover666.cn/image/20190811/3933VlaP8fHp.png?imageslim" alt="mark"></p><p>选择创建桌面快捷方式：</p><p><img src="http://mculover666.cn/image/20190811/xwgbSVuGHgdb.png?imageslim" alt="mark"></p><p>安装中…</p><p><img src="http://mculover666.cn/image/20190811/aAvl1nIYwYBj.png?imageslim" alt="mark"></p><p>安装完成后如图：</p><p><img src="http://mculover666.cn/image/20190811/DoLwzbrlsDT6.png?imageslim" alt="mark"></p><p>最后选择是否记录刚刚安装的过程，并创建一个安装脚本，下次直接执行脚本就可以完成这个安装过程了，这里选择不创建：</p><p><img src="http://mculover666.cn/image/20190811/VcnP9F8j04bS.png?imageslim" alt="mark"></p><p>桌面图标如下：</p><p><img src="http://mculover666.cn/image/20190811/1EcyTM3NGxL7.png?imageslim" alt="mark"></p><h1 id="4-获取并安装STM32Cube-MCU-Packages"><a href="#4-获取并安装STM32Cube-MCU-Packages" class="headerlink" title="4. 获取并安装STM32Cube MCU Packages"></a>4. 获取并安装STM32Cube MCU Packages</h1><p>STM32Cube MCU Packages的安装方式有两种：</p><ul><li>在STM32CubeMX中<strong>在线安装</strong>；</li><li>在ST官网获取STM32Cube MCU Packages，然后<strong>离线安装</strong>；</li></ul><h2 id="在线安装STM32Cube-MCU-Packages"><a href="#在线安装STM32Cube-MCU-Packages" class="headerlink" title="在线安装STM32Cube MCU Packages"></a>在线安装STM32Cube MCU Packages</h2><p>打开STM32CubeMX，选择<code>Help</code>-&gt;<code>Manage embedded software packages</code>：</p><p><img src="http://mculover666.cn/image/20190811/28Oclq0pEvP3.png?imageslim" alt="mark"></p><p>在packages列表中勾选上需要的 <code>MCU Packages</code>， 点击<code>Install Now</code> ：</p><p><img src="http://mculover666.cn/image/20190811/plS5zNQiSzAo.png?imageslim" alt="mark"></p><p>安装中（下载速度还比较快哈哈哈）：</p><p><img src="http://mculover666.cn/image/20190811/FSVTgvBenHS5.png?imageslim" alt="mark"></p><h2 id="离线安装STM32Cube-MCU-Packages"><a href="#离线安装STM32Cube-MCU-Packages" class="headerlink" title="离线安装STM32Cube MCU Packages"></a>离线安装STM32Cube MCU Packages</h2><p>首先在<a href="https://www.st.com/content/st_com/en/stm32cube-ecosystem.html" target="_blank" rel="noopener">ST官网的packages列表</a>找到需要的packages，点击名字即可跳转：</p><p><img src="http://mculover666.cn/image/20190811/ts9NYzyepz08.png?imageslim" alt="mark"></p><p>跳转过去之后点击获取，开始下载packages：</p><p><img src="http://mculover666.cn/image/20190811/kuiYBrE14cre.png?imageslim" alt="mark"></p><p>下载之后如图（<strong>不要解压</strong>）：</p><p><img src="http://mculover666.cn/image/20190811/nflkfFhiwRq3.png?imageslim" alt="mark"></p><h3 id="导入package到STM32CubeMX"><a href="#导入package到STM32CubeMX" class="headerlink" title="导入package到STM32CubeMX"></a>导入package到STM32CubeMX</h3><p>打开STM32CubeMX的包管理器（方法同上），点击<code>From Local</code>：</p><p><img src="http://mculover666.cn/image/20190811/i384oOghVbBU.png?imageslim" alt="mark"></p><p>选择打开要导入的package：</p><p><img src="http://mculover666.cn/image/20190811/bDoB6uLWc3rR.png?imageslim" alt="mark"></p><p>点击打开即可成功导入。</p><p>至此，我们已经安装好了STM32CubeMX和STM32L4的MCU Package，下一节中讲述如何使用STM32CubeMX快速生成MDK的工程，点亮一个LED。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_01 | 初识 STM32Cube 生态系统</title>
      <link href="/posts/1350058916/"/>
      <url>/posts/1350058916/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要介绍STM32Cube生态系统。</p><a id="more"></a><h1 id="STM32Cube-Ecosystem"><a href="#STM32Cube-Ecosystem" class="headerlink" title="STM32Cube Ecosystem"></a>STM32Cube Ecosystem</h1><p><a href="https://www.st.com/content/st_com/en/stm32cube-ecosystem.html" target="_blank" rel="noopener">STM32Cube</a>是ST公司开发的一套生态系统，致力于使STM32的开发变的更简单，并且100%开源免费。</p><p>在开始介绍之前，先放上两段ST官方的视频，作以欣赏了解：</p><ul><li><a href="https://www.bilibili.com/video/av52092742" target="_blank" rel="noopener">STM32Cube生态系统宣传片</a></li><li><a href="https://www.bilibili.com/video/av58474599/" target="_blank" rel="noopener">STM32Cube产品概览 - 使STM32开发更简单</a></li></ul><p>STM32Cube生态系统包括两大部分：</p><ul><li>PC软件工具：STM32CubeMX、STM32CubeIDE、STM32CubeProgrammer、STM32CubeMnitor等</li><li>软件库：STM32 Embedded Software bricks </li></ul><p><img src="http://mculover666.cn/image/20190810/U1EMmSu41E2Y.png?imageslim" alt="mark"></p><h2 id="STM32Cube-PC-Tools"><a href="#STM32Cube-PC-Tools" class="headerlink" title="STM32Cube PC Tools"></a>STM32Cube PC Tools</h2><ul><li><a href="https://www.st.com/en/development-tools/stm32cubemx.html" target="_blank" rel="noopener">STM32Cube MX</a>：<strong>适用于任何STM32设备的配置工具</strong><br>该工具用Java编写，所以可以在Windows、Linux、Mac上运行，它可以使用户通过图形用户界面对微控制器进行配置，然后为Cortex-M内核生成初始化C代码，或者为Cortex-A内核生成Linux设备树源（下面两张图对STM32CubeMX的作用作以诠释）：</li></ul><p><img src="http://mculover666.cn/image/20190810/VnUNz6EJlc6F.png?imageslim" alt="mark"></p><p><img src="http://mculover666.cn/image/20190810/GsSG2OKAfAPt.png?imageslim" alt="mark"></p><ul><li><a href="https://www.st.com/en/development-tools/stm32cubeide.html" target="_blank" rel="noopener">STM32CubeIDE</a>：<strong>集成开发环境</strong><br>该工具是基于Eclipse+GNU C/C++工具链的，除了基本的编辑和编译功能，还包括代码编译报告功能和高级调试功能，另外，该IDE还集成了CubeMX。</li></ul><p><img src="http://mculover666.cn/image/20190810/DO71YWc0Rpio.png?imageslim" alt="mark"></p><ul><li><a href="https://www.st.com/en/development-tools/stm32cubeprog.html" target="_blank" rel="noopener">STM32CubeProgrammer</a>：<strong>编程工具（给编程指给单片机烧录程序）</strong><br>该工具通过各种可用的通信方式（比如<code>JTAG，SWD，UART，USB DFU，I2C，SPI，CAN</code>等），提供了易于使用且高效的环境，用于读取，写入和验证存储器。</li></ul><p><img src="http://mculover666.cn/image/20190810/SnlnTMBgOkpg.png?imageslim" alt="mark"></p><ul><li><code>STM32CubeMnitor</code>：<strong>强大的监控工具</strong><br>帮助开发人员实时调试和监控应用程序的行为和性能。</li></ul><p>这四个工具伴随着整个STM32的开发流程：</p><p><img src="http://mculover666.cn/image/20190810/90UpnSazgV9e.png?imageslim" alt="mark"></p><h2 id="STM32-Embedded-Software"><a href="#STM32-Embedded-Software" class="headerlink" title="STM32 Embedded Software"></a>STM32 Embedded Software</h2><p> STM32 Embedded Softwares是STM32Cube提供的软件包，包括两大部分：</p><ul><li>STM32Cube MCU Packages</li><li>STM32Cube Expansion</li></ul><h3 id="STM32Cube-MCU-Packages"><a href="#STM32Cube-MCU-Packages" class="headerlink" title="STM32Cube MCU Packages"></a>STM32Cube MCU Packages</h3><p>STM32Cube MCU Packages是STM32Cube提供的对于每个MCU产品的软件包，其中包括：</p><ul><li>底层库代码</li><li>中间件代码</li><li>用户代码</li></ul><h4 id="底层库代码"><a href="#底层库代码" class="headerlink" title="底层库代码"></a>底层库代码</h4><p>STM32Cube提供的HAL库或者LL库，<strong>覆盖STM32全系列</strong>，包括：</p><p><img src="http://mculover666.cn/image/20190810/zIeIjybfYev2.png?imageslim" alt="mark"></p><h4 id="中间件代码"><a href="#中间件代码" class="headerlink" title="中间件代码"></a>中间件代码</h4><p>STM32Cube提供的中间件代码非常丰富，包括：</p><p><img src="http://mculover666.cn/image/20190810/Obq52NRryhXo.png?imageslim" alt="mark"></p><h4 id="用户代码"><a href="#用户代码" class="headerlink" title="用户代码"></a>用户代码</h4><p>STM32Cube提供初步写好的用户代码，开发者可以在此基础上开发各种应用：</p><p><img src="http://mculover666.cn/image/20190810/TnMsuJf7jvu0.png?imageslim" alt="mark"></p><p>截止2019年2月，STM32Cube软件包对STM32全系列产品的支持情况如下表：</p><p><img src="http://mculover666.cn/image/20190810/G4zgELzVrWTW.png?imageslim" alt="mark"></p><h3 id="STM32Cube-Expansion"><a href="#STM32Cube-Expansion" class="headerlink" title="STM32Cube Expansion"></a>STM32Cube Expansion</h3><p><a href="https://www.st.com/en/embedded-software/stm32cube-expansion-packages.html#overview" target="_blank" rel="noopener">STM32Cube扩展包</a><strong>补充了STM32Cube MCU Packages的功能</strong>，目前已有的软件扩展包有：</p><ul><li>用于云连接的即用型扩展包（Amazon AWS，Microsoft Azure，IBW Watson等）</li><li>LoRa</li><li>蜂窝连接</li><li>NFC</li><li>工业通信协议</li><li>加密库</li><li>传感器驱动程序</li><li>电机控制算法</li><li>安全自测库</li><li>……</li></ul><p>至此，对STM32Cube生态系统的介绍完毕，下一节讲述如何获取STM32Cube生态系统中的PC tools和Embeded Software。</p><p><strong><font color="#FF0000">更多精彩文章及资源，请关注我的微信公众号：『mculover666』。</font></strong></p><p><img src="http://mculover666.cn/image/20190814/NQqt1eRxrl1K.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> STM32CubeMX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32CubeMX </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
